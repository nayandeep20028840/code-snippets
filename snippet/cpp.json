


{
	"simple_main.": {
		"prefix": "man",
		"body": [
			"#include<bits/stdc++.h> ",
			"using namespace std ; ",
			"",
			"int main() { ",
			"    ",
			"\t$1",
			"    ",
			"    return 0 ;",
			"}"
		],
		"description": "simple_main."
	},
	"input output file": {
		"prefix": "input output file",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\",\"r\",stdin);",
			"    freopen(\"output.txt\",\"w\",stdout);",
			"    freopen(\"error.txt\", \"w\", stderr);",
			"#endif "
		],
		"description": "input output file"
	},
	"Mathematics": {
		"prefix": "Mathematics",
		"body": [
			"const int MOD = 1000000007 ; // 998244353 ",
			"const long long inf = 1000000000000000000LL; // 18 zero's // LLONG_MAX = 9223372036854775807 - 19 digits",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor",
			"int LCM(int a, int b){return ((long long)a / (long long)GCD(a, b) * (long long)b) ;}",
			"int modpower(int x, int y, int m){long long res = 1; x = x % m; while(y > 0){if(y&1) res = (res * (long long)x) % MOD; y = y >> 1; x = ((long long)x * (long long)x) % MOD ;}return res ;} ",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_DIVISION(int a, int b, int m){a %= m , b %= m; return mod_MULTIPLICATION(a , modpower(b , m - 2 , MOD) , m);}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modinv(int x){return modpower(x , MOD - 2 , MOD) ;} ",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.first != b.first){return a.first < b.first ;}return a.second > b.second ;}"
		],
		"description": "Mathematics"
	},
	"my hash define": {
		"prefix": "my hash define",
		"body": [
			"#define nl                \"\\n\"",
			"#define ll                long long",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			"#define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << nl ;",
			"#define no                cout << \"NO\" << nl ;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<nl ;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<nl ; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<nl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<nl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9"
		],
		"description": "my hash define"
	},
	"pbds": {
		"prefix": "pbds",
		"body": [
			"// Policy based data structures(PBDS) C++ STL",
			"// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			"// order_of_key(k): returns count of elements strictly smaller than k ",
			"// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template<class T > using pbds_SET = tree< T , null_type , less<T>, rb_tree_tag, tree_order_statistics_node_update > ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree_SET<pair<int , int > > s; for pairs",
			"template<class T > using pbds_MULTISET = tree< T , null_type , less_equal<T>, rb_tree_tag, tree_order_statistics_node_update > ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree_MULTISET<pair<int , int > > s; for pairs"
		],
		"description": "pbds"
	},
	"main2": {
		"prefix": "main2",
		"body": [
			"#include<bits/stdc++.h> ",
			"using namespace std; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(3, \"Ofast\", \"inline\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"#define int long long",
			"",
			"bool solve()",
			"{",
			"\t$1",
			"    return true;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"    int t;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        if (solve())",
			"        {",
			"            ",
			"        }",
			"        else",
			"        {",
			"            ",
			"        }",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": "main2"
	},
	"main1": {
		"prefix": "main1",
		"body": [
			"#include<bits/stdc++.h> ",
			"using namespace std; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(3, \"Ofast\", \"inline\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"#define int long long",
			"",
			"bool solve()",
			"{",
			"\t$1",
			"    return true;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"    int t = 1;",
			"    while (t--)",
			"    {",
			"        if (solve())",
			"        {",
			"            ",
			"        }",
			"        else",
			"        {",
			"            ",
			"        }",
			"    }",
			"    return 0;",
			"}",
			"",
			""
		],
		"description": "main1"
	},
	"jaishrimahakal": {
		"prefix": "leetcode",
		"body": [
			"#include<bits/stdc++.h> ",
			"using namespace std; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(3, \"Ofast\", \"inline\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"auto init = []() ",
			"{",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout.tie(nullptr);",
			"    return 'c';",
			"}();",
			"",
			""
		],
		"description": "jaishrimahakal"
	},
	"lambda-": {
		"prefix": "lambda",
		"body": [
			"function<void(int,int)> func=[&](int child,int parent)->void{",
			"\t$1",
			"};"
		],
		"description": "lambda-"
	},
	"deadlypillow": {
		"prefix": "deadlypillowncr",
		"body": [
			"const int N = 2e6 + 1; // Don't forget to change the value of N, Written is Maximum Value",
			"int F[N], iF[N]; // Factorial, Inverse Factorial Array",
			"const int MOD = 1e9 + 7; // if you want to use without any mod than mod will be INF ",
			"",
			"int binexp(int a, int b){",
			"    int res = 1;",
			"    while(b > 0){",
			"        if(b % 2){",
			"            res = (res * a) % MOD;",
			"        }",
			"        a = (a * a) % MOD;",
			"        b /= 2;",
			"    }",
			"    return res;",
			"}",
			"void init(){",
			"    F[0] = 1;",
			"    for(int i = 1; i < N; ++i){",
			"        F[i] = (F[i - 1] * i) % MOD;",
			"    }",
			"    iF[N - 1] = binexp(F[N - 1], MOD - 2); // it finds the inverse of F[N - 1] ",
			"    for (int i = N - 2; i >= 0; --i){",
			"        iF[i] = iF[i + 1] * (i + 1) % MOD;",
			"    }",
			"}",
			"int NCR(int n, int r){",
			"    if (r > n || r < 0){",
			"        return 0;",
			"    }",
			"    return ((iF[r] * F[n]) % MOD * iF[n - r]) % MOD;",
			"}"
		],
		"description": "deadlypillow"
	},
	"lps-longestPrefixSuffix": {
		"prefix": "lps-longestPrefixSuffix",
		"body": [
			"",
			"",
			"// T.C. O(n)",
			"// S.C. O(n)",
			"",
			"vector<int> longestPrefixSuffix(string text){",
			"    int n = text.size();",
			"    vector<int > lps(n, 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(text[i] == text[len]){",
			"            len++;  ",
			"            lps[i] = len;",
			"            i++;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1];",
			"            }else{",
			"                lps[i] = 0;",
			"                i++;",
			"            }",
			"        }",
			"    }",
			"    return lps;",
			"}"
		],
		"description": "lps-longestPrefixSuffix"
	},
	"kmp": {
		"prefix": "kmp",
		"body": [
			"",
			"// T.C. O(n + m)",
			"// S.C. O(m)",
			"",
			"vector<int> longestPrefixSuffix(string pattern){",
			"    int n = pattern.size();",
			"    vector<int> LPS(n, 0);",
			"    LPS[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while (i < n) {",
			"        if (pattern[i] == pattern[len]) {",
			"            len++;",
			"            LPS[i] = len;",
			"            i++;",
			"        } else {",
			"            if (len != 0) {",
			"                len = LPS[len - 1];",
			"            } else {",
			"                LPS[i] = 0;",
			"                i++;",
			"            }",
			"        }",
			"    }",
			"    return LPS;",
			"}",
			"",
			"int kmp(string pattern, string text){",
			"    int patternLen = pattern.size(); // pattern length // we have to find this pattern in the string ",
			"    int textLen = text.size(); // string length ",
			"    if (patternLen == 0) return 0; // if string length is zero ",
			"    vector<int> patternLPS = longestPrefixSuffix(pattern);",
			"    int len = 0;",
			"    int i = 0;",
			"    int cnt = 0;",
			"    while (i < textLen) {",
			"        if(text[i] == pattern[len]){",
			"            len++;",
			"            i++;",
			"        } else {",
			"            if (len != 0) {",
			"                len = patternLPS[len - 1];",
			"            } else {",
			"                i++;",
			"            }",
			"        }",
			"        if (len == patternLen) {",
			"            cnt++;",
			"            len = patternLPS[len - 1];",
			"        }",
			"    }",
			"    return cnt; // cnt is the number of times the pattern occurs in the string text",
			"}"
		],
		"description": "kmp"
	},
	"zFunction": {
		"prefix": "zFunction",
		"body": [
			"",
			"vector<int> zFunction(string text){",
			"    int n = text.size();",
			"    int i = 1;",
			"    int l = 0;",
			"    int r = 0;",
			"",
			"    vector<int> z(n, 0);",
			"    while (i < n) {",
			"        if (i <= r) {",
			"            z[i] = min(z[i - l], r - i + 1);",
			"        }",
			"",
			"        while (i + z[i] < n && text[z[i]] == text[i + z[i]]) {",
			"            z[i]++;",
			"        }",
			"",
			"        if (i + z[i] - 1 > r) {",
			"            l = i;",
			"            r = i + z[i] - 1;",
			"        }",
			"        i++;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "zFunction"
	},
	"rabinKarp": {
		"prefix": "rabinKarp",
		"body": [
			"vector<int> rabinKarp(string const &pattern, string const &text) {",
			"    const int primeValue = 31;",
			"    const int MOD = 1e9 + 9;",
			"    int patternLen = pattern.size(); // pattern size // we need to find this pattern in the text ",
			"    int textLen = text.size();",
			"",
			"    vector<long long> precomputePowers(max(patternLen, textLen));",
			"",
			"    precomputePowers[0] = 1;",
			"    for (int i = 1; i < precomputePowers.size(); i++) {",
			"        precomputePowers[i] = (precomputePowers[i-1] * primeValue) % MOD;",
			"    }",
			"",
			"    vector<long long> h(textLen + 1, 0);",
			"    for (int i = 0; i < textLen; i++) {",
			"        h[i + 1] = (h[i] + (text[i] - 'a' + 1) * precomputePowers[i]) % MOD;",
			"    }",
			"",
			"    long long hashValue = 0;",
			"    for (int i = 0; i < patternLen; i++) {",
			"        hashValue = (hashValue + (pattern[i] - 'a' + 1) * precomputePowers[i]) % MOD;",
			"    }",
			"",
			"    vector<int> occurrences;",
			"    for (int i = 0; i + patternLen - 1 < textLen; i++) {",
			"        long long curHashValue = (h[i + patternLen] + MOD - h[i]) % MOD;",
			"        if (curHashValue == hashValue * precomputePowers[i] % MOD) {",
			"            occurrences.push_back(i);",
			"        }",
			"    }",
			"",
			"    return occurrences;",
			"}"
		],
		"description": "rabinKarp"
	},
	"manacher": {
		"prefix": "manacher",
		"body": [
			"// USES - Longest Palindromic Substring , ",
			"// Pattern Matching:to find occurrences of a specific",
			"// palindromic pattern within a given text.",
			"/*",
			"",
			"aba -->#a#b#a#",
			"abba -->#a#b#b#a#",
			"",
			"how to build manacher",
			"m.build(s);",
			"",
			"*/",
			"struct manacher {",
			"    vector<int > p ;",
			"    int n ;",
			"    string s1 ;",
			"    void run_manacher(string s) {",
			"        int n = s.length() ;",
			"        s = \"$\" + s + \"^\" ;",
			"        // cout << s << \"\\n\" ; ",
			"        s1 = s; ",
			"        p.assign(n + 2, 0); // don't use resize(fcuk)",
			"        int l = 1; // l and r are not inclusive ",
			"        int r = 1;",
			"        for(int i = 1; i <= n; ++i){",
			"            p[i] = max(0ll, min(p[l + r - i] , r - i));",
			"            while(i - p[i] >= 0 && i + p[i] <= n && s[i - p[i]] == s[i + p[i]]){",
			"                p[i]++;",
			"            }",
			"            if(i + p[i] > r){ // or",
			"                l = i - p[i];",
			"                r = i + p[i];",
			"            }",
			"        }",
			"        // for(auto &v : p){",
			"        //     cout << v << \" \" ;",
			"        // }",
			"        // cout << \"\\n\" ;",
			"    }",
			"    void build(string s){ // so that every substring is odd length ",
			"        string t;",
			"        for (auto it : s){",
			"            t += string(\"#\") + it; // making every substring odd length ",
			"        }",
			"        run_manacher(t + \"#\");",
			"    }",
			"    vector<int> get_vector_p(){",
			"        return p;",
			"    }",
			"    string get_string_s(){",
			"        return s1;",
			"    }",
			"    // abbabba // 0 based indexing ",
			"    // centre = 1, odd = 1 length = 1 this means we have to odd length palindrome with centre as 1 ",
			"    // centre = 1, odd = 0 length = 4 this means we have to even length palindrome with centre as 1 ",
			"    int getlongest(int centre, bool odd){ // I can't understanding this(fcuk) ",
			"        int pos = 2 * centre + odd + 1 + (!odd);",
			"        return (p[pos] - 1);",
			"    }",
			"    bool checkPal(int l, int r) {",
			"        if ((r - l + 1) <= getlongest((r + l) / 2, l % 2 == r % 2)) {",
			"            return 1;",
			"        }",
			"        return 0;",
			"    }",
			"} man;",
			""
		],
		"description": "manacher"
	},
	"dsu simple": {
		"prefix": "dsu simple",
		"body": [
			"",
			"struct Node {",
			"    int p; int siz;",
			"};",
			"",
			"struct DSU {",
			"    vector<Node> dsu;",
			"",
			"    DSU(int n) { ",
			"        for (int i = 0; i < n; ++i) {",
			"            Node tmp;",
			"            tmp.p = i; tmp.siz = 1;",
			"            dsu.push_back(tmp);",
			"        }",
			"    }",
			"",
			"    int parent(int u) {",
			"        if (dsu[u].p == u) return u;",
			"        dsu[u].p = parent(dsu[u].p); // Time Complexity O(log n)",
			"        return dsu[u].p;",
			"    }",
			"",
			"    void mergeBySize(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if (u == v) return;",
			"        if (dsu[u].siz < dsu[v].siz) swap(u, v);",
			"        dsu[v].p = u;",
			"        dsu[u].siz += dsu[v].siz; ",
			"    }",
			"",
			"    bool same(int u, int v) {",
			"        if (parent(u) == parent(v)) return true;",
			"        return false;",
			"    }",
			"",
			"    int getSize(int u) {",
			"        return dsu[parent(u)].siz;",
			"    }",
			"};"
		],
		"description": "dsu simple"
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"struct Node{",
			"    int sum;",
			"    Node(){",
			"        sum = 0;",
			"    }",
			"    Node(int val){",
			"        sum = val;",
			"    }",
			"    void merge(Node &low, Node &high){",
			"        sum = (low.sum + high.sum);",
			"    }",
			"};",
			"",
			"struct SegmentTree{",
			"    vector<Node> tree;",
			"    vector<int> arr;",
			"    int N;",
			"    SegmentTree(int n, vector<int> &vec){",
			"        N = n;",
			"        arr = vec;",
			"        tree.resize(4 * n, Node()); // 4 * n is the size of the segment tree",
			"    }",
			"    void build(int index, int start, int end){",
			"        if(start == end){",
			"            tree[index] = Node(arr[start]);",
			"            return;",
			"        }",
			"        int mid = (end + start) / 2;",
			"        build(index * 2, start, mid);",
			"        build(index * 2 + 1, mid + 1, end);",
			"        tree[index].merge(tree[index * 2] , tree[index * 2 + 1]);",
			"    }",
			"    void update(int index, int start, int end, int update_start, int update_end, int val){",
			"        if(end < update_start || start > update_end){",
			"            return;",
			"        }",
			"        if(start == end){",
			"            tree[index].sum += val;",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        update(index * 2, start, mid, update_start, update_end, val);",
			"        update(index * 2 + 1, mid + 1, end, update_start, update_end, val);",
			"        tree[index].merge(tree[index * 2], tree[index * 2 + 1]);",
			"    }",
			"    Node query(int index, int start, int end, int query_start, int query_end){",
			"        if(end < query_start || start > query_end){",
			"            return Node();",
			"        }",
			"        if(start >= query_start and end <= query_end){",
			"            return tree[index];",
			"        }",
			"        int mid = (start + end) / 2;",
			"        Node left = query(index * 2, start, mid, query_start, query_end);",
			"        Node right = query(index * 2 + 1, mid + 1, end, query_start, query_end);",
			"        Node result;",
			"        result.merge(left, right);",
			"        return result;",
			"    }",
			"};"
		],
		"description": "SegmentTree"
	},
	"Simple_LazySegmentTree": {
		"prefix": "Simple_LazySegmentTree",
		"body": [
			"struct Node{",
			"    int sum;",
			"    int lazy;",
			"    Node(){",
			"        sum = 0;",
			"        lazy = 0;",
			"    }",
			"    Node(int val){",
			"        sum = val;",
			"        lazy = 0;",
			"    }",
			"    void merge(Node &low, Node &high){",
			"        sum = (low.sum + high.sum);",
			"    }",
			"};",
			"",
			"struct LazySegmentTree{",
			"    vector<Node> tree;",
			"    vector<int> arr;",
			"    int N;",
			"    LazySegmentTree(int n, vector<int> &vec){",
			"        N = n;",
			"        arr = vec;",
			"        tree.resize(4 * n, Node());",
			"    }",
			"    void build(int index, int start, int end){",
			"        if(start == end){",
			"            tree[index] = Node(arr[start]);",
			"            return;",
			"        }",
			"        int mid = (end + start) / 2;",
			"        build(index * 2, start, mid);",
			"        build(index * 2 + 1, mid + 1, end);",
			"        tree[index].merge(tree[index * 2] , tree[index * 2 + 1]);",
			"    }",
			"    void update(int index, int start, int end, int update_start, int update_end, int val){",
			"        push(index, start, end);",
			"        if(end < update_start || start > update_end){",
			"            return;",
			"        }",
			"        if(update_start <= start and end <= update_end){",
			"            tree[index].lazy += val;",
			"            push(index, start, end);",
			"            return;",
			"        }",
			"        int mid = (end + start) / 2;",
			"        update(index * 2, start, mid, update_start, update_end, val);",
			"        update(index * 2 + 1, mid + 1, end, update_start, update_end, val);",
			"        tree[index].merge(tree[index * 2], tree[index * 2 + 1]);",
			"    }",
			"    void push(int index, int start, int end){ // make update to this than push",
			"        if(tree[index].lazy){",
			"            // if there is a lazy, apply and push down",
			"            // apply logic",
			"            tree[index].sum += (end - start + 1) * tree[index].lazy;",
			"",
			"            // push down logic",
			"            if(start != end){",
			"                tree[index * 2].lazy += tree[index].lazy;",
			"                tree[index * 2 + 1].lazy += tree[index].lazy;",
			"            }",
			"",
			"            tree[index].lazy = 0;",
			"        }",
			"    }",
			"    Node query(int index, int start, int end, int q_start, int q_end){",
			"        push(index, start, end);",
			"",
			"        if(end < q_start || q_end < start){",
			"            return Node();",
			"        } ",
			"        if(q_start <= start && end <= q_end){",
			"            return tree[index];",
			"        }",
			"        int mid = (start + end) / 2;",
			"        Node left = query(index * 2, start, mid, q_start, q_end);",
			"        Node right = query(index * 2 + 1, mid + 1, end, q_start, q_end);",
			"        Node ans = Node();",
			"        ans.merge(left, right);",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "Simple_LazySegmentTree"
	},
	"binary indexed tree": {
		"prefix": "binary indexed tree",
		"body": [
			"template <typename T> class BIT {",
			"public:",
			"    vector<T> bit;",
			"    int n;",
			"",
			"    BIT() { n = 0; }",
			"",
			"    BIT(int _n) {",
			"        n = _n;",
			"        bit.assign(n, 0);",
			"    }",
			"",
			"    void inc(int idx, T val) {",
			"        for (int i = idx + 1; i <= n; i += (i & -i))",
			"            bit[i - 1] += val;",
			"    }",
			"",
			"    T query(int idx) {",
			"        T res = 0;",
			"        for (int i = idx + 1; i > 0; i -= (i & -i))",
			"            res += bit[i - 1];",
			"        return res;",
			"    }",
			"",
			"    T at(int idx) {",
			"        return query(idx) - (idx - 1 >= 0 ? query(idx - 1) : 0);",
			"    }",
			"",
			"    T at(int l, int r) {",
			"        return query(r) - (l - 1 >= 0 ? query(l - 1) : 0);",
			"    }",
			"};",
			"",
			"template <typename T> class FT {",
			"public:",
			"    BIT<T> f1, f2;",
			"    int n;",
			"",
			"    FT() { n = 0; }",
			"",
			"    FT(int _n) {",
			"        n = _n;",
			"        f1 = f2 = BIT<T>(_n + 1);",
			"    }",
			"",
			"    void inc(int idx, T val) {",
			"        inc(idx, idx, val);",
			"    }",
			"",
			"    void inc(int l, int r, T val) {",
			"        f1.inc(l, val);",
			"        f1.inc(r + 1, -val);",
			"        f2.inc(l, val * (l - 1));",
			"        f2.inc(r + 1, -val * r);",
			"    }",
			"",
			"    T query(int idx) {",
			"        return f1.query(idx) * idx - f2.query(idx);",
			"    }",
			"",
			"    T at(int idx) {",
			"        return query(idx) - (idx - 1 >= 0 ? query(idx - 1) : 0);",
			"    }",
			"",
			"    T at(int l, int r) {",
			"        return query(r) - (l - 1 >= 0 ? query(l - 1) : 0);",
			"    }",
			"};"
		],
		"description": "binary indexed tree"
	},
	"mosAlgorithm": {
		"prefix": "mosAlgorithm",
		"body": [
			"const int NN = 2e5+1 ; // warning don't exceed 1e7+1e6 ;",
			"int block_size;",
			"vector<int> v(NN);",
			"vector<int> freq(NN);",
			"int answer = 0;",
			"",
			"struct Query { // name of the structure",
			"    int l, r, idx;",
			"",
			"    Query(int _l, int _r, int _idx) : l(_l), r(_r), idx(_idx) { // These lines initialize the member variables with the values passed as arguments to the constructor.",
			"",
			"    } // defining a constructor for a structure. The constructor initializes three member variables: l, r, and idx, presumably within the context of that structure.",
			"",
			"    bool operator<(Query other) const // sort the queries",
			"    {",
			"        return make_pair(l / block_size, r) <            // jaadu",
			"                make_pair(other.l / block_size, other.r);",
			"    }",
			"};",
			"",
			"void remove(int idx) { // TODO: remove value at idx from data structure",
			"    ",
			"}  ",
			"void add(int idx) {  // TODO: add value at idx from data structure",
			"    ",
			"}    ",
			"int get_answer() { // TODO: extract the current answer of the data structure",
			"    return answer;",
			"}  ",
			"",
			"vector<int > mo_s_algorithm(vector<Query > queries) {",
			"    vector<int > answers(queries.size());",
			"    sort(queries.begin(), queries.end());",
			"",
			"    // TODO: initialize data structure",
			"",
			"    int cur_l = 0;",
			"    int cur_r = -1;",
			"    // invariant: data structure will always reflect the range [cur_l, cur_r]",
			"    for (Query q : queries){",
			"        while (cur_l > q.l){",
			"            cur_l--;",
			"            freq[v[cur_l]] += 1;",
			"            add(cur_l);",
			"        }",
			"        while (cur_r < q.r) {",
			"            cur_r++;",
			"            freq[v[cur_r]] += 1;",
			"            add(cur_r);",
			"        }",
			"        while (cur_l < q.l) {",
			"            remove(cur_l);",
			"            freq[v[cur_l]] -= 1;",
			"            cur_l++;",
			"        }",
			"        while (cur_r > q.r){",
			"            remove(cur_r);",
			"            freq[v[cur_r]] -= 1;",
			"            cur_r--;",
			"        }",
			"        answers[q.idx] = get_answer();",
			"    }",
			"    return answers;",
			"}",
			"",
			"/*",
			"",
			"    Time complexity : very important O(Q * logQ) for sorting +(plus) Q * root(n)",
			"    for all query combined maximum range covered is root(n)",
			"",
			"    define block_size as",
			"    {",
			"        int sq = sqrtl(n);",
			"        block_size = sqrtl(n) + (n % sq == 0 ? 0 : 1);",
			"    }",
			"",
			"    vector<Query > queries ;",
			"    vector<int > got_it = mo_s_algorithm(queries);",
			"    for(int i = 0; i < q; ++i){",
			"        cout << got_it[i] << endl;",
			"    }",
			"",
			"*/"
		],
		"description": "mosAlgorithm"
	},
	"Template 1": {
		"prefix": "dsu complex",
		"body": [
			"struct DSU {",
			"    struct node {",
			"        int p; int siz; int rnk; // by rank, it's based on the height of the trees, while by size, it's based on the number of elements in the sets. ",
			"        // Merging the smaller tree into the larger one helps maintain a more balanced structure.",
			"    };",
			"    vector<node> dsu;",
			"    vector<pair<int, node>> history; // Store history for rollback",
			"",
			"    DSU(int n) { ",
			"        for(int i = 0; i < n; ++i) {",
			"            node tmp; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp);",
			"        }",
			"    }",
			"",
			"    void reset(int n) {",
			"        dsu.clear();",
			"        S = n;",
			"        for(int i = 0; i < n; ++i) {",
			"            node tmp;",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp);",
			"        }",
			"    }",
			"",
			"    int parent(int u) {",
			"        if(dsu[u].p == u) return u;",
			"        dsu[u].p = parent(dsu[u].p); // amortized time complexity almost constant",
			"        return dsu[u].p;",
			"    }",
			"",
			"    void mergeBySize(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return;",
			"        if(dsu[u].siz < dsu[v].siz) swap(u , v);",
			"        dsu[v].p = u;",
			"        dsu[u].siz += dsu[v].siz; ",
			"        history.push_back({u, dsu[u]});",
			"        history.push_back({v, dsu[v]});",
			"    }",
			"",
			"    void mergebyrank(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return;",
			"        history.push_back({u, dsu[u]});",
			"        history.push_back({v, dsu[v]});",
			"        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v;",
			"        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u;",
			"        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1; ",
			"    }",
			"",
			"    void rollback() { // Each union operation typically involves merging two sets (represented by their representatives) into one. Therefore, when rolling back a union operation, you need to undo the changes for both sets involved in that operation.",
			"        if(history.empty()) return; // Nothing to rollback",
			"        auto &i = history.back(); // Retrieve the information about the last union operation",
			"        int u = i.first;",
			"        auto state_u = i.second;",
			"        history.pop_back();",
			"        dsu[u] = state_u;",
			"",
			"        if(!history.empty()) {",
			"            pair<int,node> ii = history.back(); // Retrieve the information about the second-to-last union operation",
			"            int v = ii.first;",
			"            node state_v = ii.second; // try to avoid auto because it makes error while using long long",
			"            history.pop_back();",
			"            dsu[v] = state_v;",
			"        }",
			"    }",
			"",
			"    bool same(int u, int v) {",
			"        if(parent(u) == parent(v)) return true; ",
			"        return false; ",
			"    }",
			"",
			"    int getSize(int u) {",
			"        return dsu[parent(u)].siz; ",
			"    }",
			"};"
		],
		"description": "Template 1"
	},
	"binary lifting and lca": {
		"prefix": "binary lifting and lca",
		"body": [
			"",
			"int n;",
			"vector<vector<int>> adj; // adjacency list of the tree",
			"vector<vector<int>> parent; // parent[i][j] is the 2^j-th ancestor of node i",
			"vector<int> level;",
			"int maxlog = 30; // maximum value of x such that 2^x <= n",
			"vector<int> logValues; // logValues[] is the largest x such that 2^x <= i",
			"vector<bool> visited;",
			"",
			"void BinaryLifting(int n, int root){",
			"    parent.resize(n);",
			"    level.resize(n);",
			"    visited.resize(n);",
			"    for (int i = 0; i < n; ++i){",
			"        parent[i].resize(maxlog + 1);",
			"        for (int j = 0; j <= maxlog; ++j){",
			"            parent[i][j] = -1;",
			"        }",
			"    }",
			"    precomputeLogs();",
			"    getLevel(root, -1);",
			"    dfsBinaryLifting(root, visited);",
			"    fillParentTable(root);",
			"}",
			"",
			"void fillParentTable(int root){",
			"    int intermediate = -1;",
			"    for (int i = 1; i <= maxlog; ++i){",
			"        for (int j = 0; j < n; ++j){",
			"            intermediate = parent[j][i - 1];",
			"            if (intermediate != -1){",
			"                parent[j][i] = parent[intermediate][i - 1];",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"void dfsBinaryLifting(int root, vector<bool> &visited){",
			"    visited[root] = true;",
			"    for (auto &i: adj[root]){",
			"        if (!visited[i]){",
			"            parent[i][0] = root; // 2^0-th parent of i",
			"            dfsBinaryLifting(i, visited);",
			"        }",
			"    }",
			"}",
			"",
			"void getLevel(int root, int parent){",
			"    for (auto &i: adj[root]){ // ",
			"        if (i != parent){",
			"            level[i] = level[root] + 1;",
			"            getLevel(i, root);",
			"        }",
			"    }",
			"}",
			"",
			"void precomputeLogs(){",
			"    logValues.resize(maxlog + 1);",
			"    logValues[1] = 0;",
			"    for (int i = 2; i <= maxlog; ++i){",
			"        logValues[i] = logValues[i / 2] + 1;",
			"    }",
			"}",
			"",
			"int getLog(int x){ // returns the largest x such that 2^x <= i",
			"    return logValues[x];",
			"}",
			"",
			"int kthParent(int start, int k){ // k can be upto 1e9, In this we have only one node and we have to calculate its parent by traversing in powers of 2 ",
			"    int a = start;",
			"    while(k > 0){ // k is the distance from the start node",
			"        int x = getLog(k);",
			"        a = parent[a][x]; // 2^x-th parent of a",
			"        if(a == -1){",
			"            return a;",
			"        }",
			"        k -= (1 << x);",
			"    }",
			"    return a;",
			"}",
			"",
			"int getLCA(int a, int b){",
			"    if (level[a] > level[b]){",
			"        swap(a, b);",
			"    }",
			"    // for calculating distance multiply by two",
			"    b = kthParent(b, level[b] - level[a]); // kth parent of b at level (level[b] - level[a])",
			"    if (a == b){",
			"        return a;",
			"    }",
			"    for (int i = maxlog; i >= 0; --i){",
			"        if (parent[a][i] != parent[b][i] && parent[a][i] != -1 && parent[b][i] != -1){",
			"            a = parent[a][i];",
			"            b = parent[b][i];",
			"        }",
			"    }",
			"    return parent[a][0];",
			"}",
			""
		],
		"description": "binary lifting and lca"
	},
	"SCC": {
		"prefix": "Strongly Connected Component",
		"body": [
			"struct SCC{ // only valid for directed graph // scc_using_kosaraju_algorithm_not_using_tarjan_algorithm ",
			"    vector<vector<int>> edges, redges;",
			"    vector<bool> used;",
			"    vector<int> order, component;",
			"    int n;",
			"",
			"    void init(int _n) {",
			"        n = _n;",
			"        edges = vector<vector<int>> (n);",
			"        redges = vector<vector<int>> (n);",
			"        order.clear();",
			"        component.clear();",
			"    }",
			"",
			"    void edge(int u, int v){",
			"        edges[u].push_back(v);",
			"        redges[v].push_back(u);",
			"    }",
			"",
			"    void dfs1(int v) {",
			"        used[v] = true;",
			"        for (int i = 0; i < edges[v].size(); ++i) {",
			"            if (!used[edges[v][i]]) {",
			"                dfs1(edges[v][i]);",
			"            }",
			"        }",
			"        order.push_back(v); // time of exit from the node matters (starting time and finishing time) ",
			"    }",
			"",
			"    void dfs2(int v) {",
			"        used[v] = true;",
			"        component.push_back(v);",
			"        for(int i = 0; i < redges[v].size(); ++i) {",
			"            if(!used[redges[v][i]]) {",
			"                dfs2(redges[v][i]);",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<vector<int>>run(){",
			"        vector<vector<int>>components;",
			"        used.assign(n, false);",
			"        for(int i = 0; i < n; ++i) {",
			"            if(!used[i]) {",
			"                dfs1(i);",
			"            }",
			"        }",
			"",
			"        used.assign(n, false);",
			"        for(int i = 0; i < n; ++i){",
			"            int v = order[n - 1 - i];",
			"            if(!used[v]){",
			"                dfs2(v);",
			"                components.push_back(component);",
			"                component.clear();",
			"            }",
			"        }",
			"",
			"        return components;",
			"    }",
			"",
			"};"
		],
		"description": "SCC"
	},
	"sparse": {
		"prefix": "sparsetable",
		"body": [
			"// O(1) for idempotent O(logN) for general",
			"",
			"struct SparseTable {",
			"    struct Node {",
			"        int val;",
			"        Node(){",
			"            val = 0;",
			"        }",
			"        Node(int v){",
			"            val = v;",
			"        }",
			"        void merge(Node &l , Node &r){",
			"            val = (l.val ^ r.val);",
			"        }",
			"    };",
			"    vector<vector<Node>> table;",
			"    vector<int> logValues;",
			"    int n;",
			"    int maxLog;",
			"    vector<int> a;",
			"    SparseTable(int n, vector<int> &arr){",
			"        this->n = n;",
			"        a = arr;",
			"        table.resize(n + 1);",
			"        maxLog = 60;",
			"        logValues.resize(max(maxLog, n + 1));",
			"        logValues[1] = 0;",
			"        // 0 1 1 2 2 2 2 3 3 3  3  3  3  3  3  4  . . . . // log values ",
			"        // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . . . . ",
			"        for(int i = 2; i <= n; ++i){",
			"            logValues[i] = logValues[i / 2] + 1;",
			"        }",
			"        for(int i = 0; i < n; ++i){",
			"            table[i].resize(maxLog + 1);",
			"            fill(all(table[i]), Node());",
			"        }",
			"        build();",
			"    }",
			"    void build(){",
			"        for(int i = 0; i < n; i++){",
			"            table[i][0] = Node(a[i]);",
			"        }",
			"        for(int i = 1; i <= maxLog; ++i){",
			"            for(int j = 0; (j + (1ll << i)) <= n; ++j){",
			"                table[j][i].merge(table[j][i - 1], table[j + (1ll << (i - 1))][i - 1]);",
			"            }",
			"        }",
			"    }",
			"    Node queryNormal(int left, int right){ // O(log(n))",
			"        Node ans = Node();",
			"        for(int j = logValues[right - left + 1]; j >= 0; --j){",
			"            if((1 << j) <= right - left + 1){",
			"                ans.merge(ans, table[left][j]);",
			"                left += (1ll << j) ; // will not be (j - 1)",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    Node queryIdempotent(int left, int right){ // O(1)",
			"        int j = logValues[right - left + 1];",
			"        Node ans = Node();",
			"        ans.merge(table[left][j], table[right - (1ll << j) + 1][j]);",
			"        return ans;",
			"    }",
			"};",
			""
		],
		"description": "sparse"
	},
	"trie string": {
		"prefix": "trie string",
		"body": [
			"struct Node {",
			"    Node* links[26];",
			"    int cntEndWith = 0;",
			"    int cntPrefix = 0; ",
			"    Node() {",
			"        for (int i = 0; i < 26; i++) {",
			"            links[i] = NULL; ",
			"        }",
			"    }",
			"    bool containsKey(char ch) {",
			"        return (links[ch - 'a'] != NULL); ",
			"    }",
			"    Node* get(char ch) {",
			"        return links[ch - 'a']; ",
			"    }",
			"    void put(char ch, Node* node) {",
			"        links[ch - 'a'] = node;",
			"    }",
			"    void increaseEnd() {",
			"        cntEndWith++; ",
			"    }",
			"    void increasePrefix() {",
			"        cntPrefix++;",
			"    }",
			"    void deleteEnd() {",
			"        cntEndWith--; ",
			"    }",
			"    void reducePrefix() {",
			"        cntPrefix--; ",
			"    }",
			"};",
			"",
			"class Trie {",
			"private:",
			"    Node* root;",
			"public:",
			"    Trie() {",
			"        root = new Node();",
			"    }",
			"    void insert(string word) {",
			"        Node* node = root;",
			"        for (int i = 0; i < word.size(); i++) {",
			"            if (!node->containsKey(word[i])) {",
			"                node->put(word[i], new Node());",
			"            }",
			"            node = node->get(word[i]);",
			"            node->increasePrefix();",
			"        }",
			"        node->increaseEnd(); ",
			"    }",
			"    int countWordsEqualTo(string word) {",
			"        Node* node = root;",
			"        for (int i = 0; i < word.size(); i++) {",
			"            if (node->containsKey(word[i])) {",
			"                node = node->get(word[i]);",
			"            } else {",
			"                return 0;",
			"            }",
			"        }",
			"        return node->cntEndWith;",
			"    }",
			"    int countWordsStartingWith(string word) {",
			"        Node* node = root;",
			"        for (int i = 0; i < word.size(); i++) {",
			"            if (node->containsKey(word[i])) {",
			"                node = node->get(word[i]);",
			"            } else {",
			"                return 0;",
			"            }",
			"        }",
			"        return node->cntPrefix;",
			"    }",
			"    void erase(string word) {",
			"        Node* node = root;",
			"        for (int i = 0; i < word.size(); i++) {",
			"            if (node->containsKey(word[i])) {",
			"                node = node->get(word[i]);",
			"                node->reducePrefix();",
			"            } else {",
			"                return;",
			"            }",
			"        }",
			"        node->deleteEnd();",
			"    }",
			"};"
		],
		"description": "trie string"
	},
	"bitwise": {
		"prefix": "bitwise_TRIE",
		"body": [
			"struct BITS_TRIE {",
			"private:",
			"    struct node {",
			"        int start = 0;",
			"        int end = 0;",
			"        bool flag = false;",
			"        int cnt = 0;",
			"        node* next[2];",
			"        node() {",
			"            next[1] = next[0] = NULL;",
			"        }",
			"    };",
			"    node* root = new node(); // declares a instance of the node // root node serves as the starting point or root of the trie",
			"public:",
			"    void insert(int val) {",
			"        node* temp = root; // temp is a pointer to the root node // &root is the address of the root node",
			"        temp->cnt++;",
			"        for(int i = 31; i >= 0; --i){",
			"            int bit = 1;",
			"            if((val & (1 << i)) == 0){",
			"                bit = 0;",
			"            }",
			"            if(temp->next[bit] == NULL){",
			"                temp->next[bit] = new node();",
			"            }",
			"            temp = temp->next[bit];",
			"            temp->cnt++;",
			"        }",
			"    }",
			"    void remove(int val) {",
			"        node* temp = root;",
			"        temp->cnt--;",
			"        for(int i = 31; i >= 0; --i){",
			"            int bit = 1;",
			"            if((val & (1 << i)) == 0){",
			"                bit = 0;",
			"            }",
			"            temp = temp->next[bit];",
			"            temp->cnt--;",
			"        }",
			"    }",
			"    int max_xor(int val) {",
			"        int ans = 0;",
			"        node* temp = root;",
			"        for(int i = 31; i >= 0; --i){",
			"            int bit = 1;",
			"            if((val & (1 << i)) == 0){",
			"                bit = 0;",
			"            }",
			"            int req = 1 - bit; // what we want to maximize opposite of bit because 1 ^ 0 = 1 and 0 ^ 1 = 1",
			"            if(temp->next[req] == NULL){",
			"                temp = temp->next[1 - req];",
			"            }",
			"            else if(temp->next[req]->cnt == 0){",
			"                temp = temp->next[1 - req];",
			"            }",
			"            else {",
			"                ans += (1 << i);",
			"                temp = temp->next[req];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    int min_xor(int val){",
			"        int ans = 0;",
			"        node* temp = root;",
			"        for(int i = 31; i >= 0; --i){",
			"            int bit = 1;",
			"            if((val & (1 << i)) == 0){",
			"                bit = 0;",
			"            }",
			"            int req = bit; // what we want to minimize",
			"            if(temp->next[req] == NULL){",
			"                ans += (1 << i);",
			"                temp = temp->next[1 - req];",
			"            }",
			"            else if(temp->next[req]->cnt == 0){",
			"                ans += (1 << i);",
			"                temp=temp->next[1 - req];",
			"            }",
			"            else{",
			"                temp = temp->next[req];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "bitwise"
	},
	"General_Trie": {
		"prefix": "General_Trie",
		"body": [
			"class Trie {",
			"public:",
			"    struct General_Trie{",
			"        struct node{",
			"            node* next[10]; // declare size of next according to the problem",
			"            int cnt; // declare cnt according to the problem",
			"            node() {",
			"                cnt = 0;",
			"                for(int i = 0; i < 10; ++i){",
			"                    next[i] = NULL;",
			"                }",
			"            }",
			"        };",
			"",
			"        node* root;",
			"",
			"        void add(vector<int> &val){",
			"            node* temp = root;",
			"            for(auto &ele : val){",
			"                if(temp->next[ele] == NULL){",
			"                    temp->next[ele] = new node();",
			"                }",
			"                temp = temp->next[ele];",
			"                temp->cnt++;",
			"            }",
			"        }",
			"",
			"        void remove(vector<int> &val){",
			"            node* temp = root;",
			"            for(auto &ele : val){",
			"                if(temp->next[ele] == NULL){",
			"                    break;",
			"                }",
			"                temp = temp->next[ele];",
			"                temp->cnt--;",
			"            }",
			"        }",
			"",
			"        int query(vector<int> &val){",
			"            node* temp = &root;",
			"            int ans = 0;",
			"            for(auto &ele : val){",
			"                if(temp->next[ele] == NULL){",
			"                    break;",
			"                }",
			"                ans++;",
			"                temp = temp->next[ele];",
			"            }",
			"            return ans;",
			"        }",
			"    };",
			"};"
		],
		"description": "General_Trie"
	},
	"Extended Euclidean Algorithm": {
		"prefix": "Extended Euclidean Algorithm",
		"body": [
			"// used to find the greatest common divisor (GCD) of two integers.",
			"// also finds the coefficients of Bézout's identity. Bézout's identity states",
			"// that for any two integers a and b, there exist integers x and y such that:",
			"// ax + by = gcd(a, b)",
			"int ex_gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"",
			"    int x1, y1;",
			"    int d = ex_gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"",
			"    return d;",
			"}",
			""
		],
		"description": "Extended Euclidean Algorithm"
	},
	"Linear Diophantine Equation": {
		"prefix": "Linear Diophantine Equation",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"    g = gcd(abs(a), abs(b), x0, y0);",
			"    if (c % g) {",
			"        return false;",
			"    }",
			"",
			"    x0 *= c / g;",
			"    y0 *= c / g;",
			"    if (a < 0) x0 = -x0;",
			"    if (b < 0) y0 = -y0;",
			"    return true;",
			"}",
			"",
			"void shift_solution(int & x, int & y, int a, int b, int cnt) {",
			"    x += cnt * b;",
			"    y -= cnt * a;",
			"}",
			"",
			"int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {",
			"    int x, y, g;",
			"    if (!find_any_solution(a, b, c, x, y, g))",
			"        return 0;",
			"    a /= g;",
			"    b /= g;",
			"",
			"    int sign_a = a > 0 ? +1 : -1;",
			"    int sign_b = b > 0 ? +1 : -1;",
			"",
			"    shift_solution(x, y, a, b, (minx - x) / b);",
			"    if (x < minx)",
			"        shift_solution(x, y, a, b, sign_b);",
			"    if (x > maxx)",
			"        return 0;",
			"    int lx1 = x;",
			"",
			"    shift_solution(x, y, a, b, (maxx - x) / b);",
			"    if (x > maxx)",
			"        shift_solution(x, y, a, b, -sign_b);",
			"    int rx1 = x;",
			"",
			"    shift_solution(x, y, a, b, -(miny - y) / a);",
			"    if (y < miny)",
			"        shift_solution(x, y, a, b, -sign_a);",
			"    if (y > maxy)",
			"        return 0;",
			"    int lx2 = x;",
			"",
			"    shift_solution(x, y, a, b, -(maxy - y) / a);",
			"    if (y > maxy)",
			"        shift_solution(x, y, a, b, sign_a);",
			"    int rx2 = x;",
			"",
			"    if (lx2 > rx2)",
			"        swap(lx2, rx2);",
			"    int lx = max(lx1, lx2);",
			"    int rx = min(rx1, rx2);",
			"",
			"    if (lx > rx)",
			"        return 0;",
			"    return (rx - lx) / abs(b) + 1;",
			"}"
		],
		"description": "Linear Diophantine Equation"
	},
	"Chinese Remainder Theorem": {
		"prefix": "Chinese Remainder Theorem",
		"body": [
			"int mod_inv(int c, int m) {",
			"    int m0 = m;",
			"    int y = 0, x = 1;",
			"",
			"    if (m == 1) return 0;",
			"",
			"    while (c > 1) {",
			"        int q = c / m;",
			"        int t = m;",
			"        m = c % m;",
			"        c = t;",
			"        t = y;",
			"        y = x - q * y;",
			"        x = t;",
			"    }",
			"",
			"    if (x < 0) x += m0;",
			"    return x;",
			"}",
			"",
			"int CRT(vector<pair<int, int>> congru) {",
			"    int M = 1;",
			"",
			"    for (auto var : congru) {",
			"        M *= var.second;",
			"    }",
			"",
			"    int solution = 0;",
			"",
			"    for (auto var : congru) {",
			"        int a_i = var.first;",
			"        int M_i = M / var.second;",
			"        int N_i = mod_inv(M_i, var.second);",
			"        solution = (solution + a_i * (M_i % M) * N_i) % M;",
			"    }",
			"",
			"    return solution;",
			"}",
			""
		],
		"description": "Chinese Remainder Theorem"
	},
	"matrix expo": {
		"prefix": "matrix expo",
		"body": [
			"template<typename T>",
			"class Matrix {",
			"public:",
			"    vector<vector<T>> mat;",
			"",
			"    Matrix() {}",
			"",
			"    Matrix(int _n, int _m, T init) {",
			"        mat = vector<vector<T>>(_n, vector<T>(_m, init));",
			"    }",
			"",
			"    Matrix(const vector<vector<T>>& a) {",
			"        mat = a;",
			"    }",
			"",
			"    void set(T init) {",
			"        for(int i = 0; i < rows(); i++) {",
			"            for(int j = 0; j < cols(); j++) {",
			"                mat[i][j] = init;",
			"            }",
			"        }",
			"    }",
			"",
			"    int rows() const {",
			"        return mat.size();",
			"    }",
			"",
			"    int cols() const {",
			"        return mat[0].size();",
			"    }",
			"",
			"    Matrix operator*(const Matrix<T>& obj) const {",
			"        assert(cols() == obj.rows());",
			"        vector<vector<T>> res(rows(), vector<T>(obj.cols()));",
			"        for(int r = 0; r < rows(); r++) {",
			"            for(int c = 0; c < obj.cols(); c++) {",
			"                for(int k = 0; k < cols(); k++) {",
			"                    res[r][c] += mat[r][k] * obj.mat[k][c];",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<T>& operator[](int index) {",
			"        return mat[index];",
			"    }",
			"};",
			"",
			"template<typename T>",
			"ostream& operator<<(ostream& os, Matrix<T>& mat) {",
			"    int n = mat.rows(), m = mat.cols();",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < m; j++) {",
			"            os << mat[i][j] << \" \";",
			"        }",
			"        os << \"\\n\";",
			"    }",
			"    return os;",
			"}",
			"",
			"template<typename T>",
			"Matrix<T> power(Matrix<T> res, Matrix<T> a, long long b) {",
			"    while(b > 0){",
			"        if(b & 1){",
			"            res = a * res;",
			"        }",
			"        a = a * a;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "matrix expo"
	},
	"convexhullgrahamscan": {
		"prefix": "convexhull",
		"body": [
			"void cc(vector<pair<ll, ll>>& points) {",
			" ",
			"    auto ccw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) > 0;",
			"    };",
			"    auto cw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) < 0;",
			"    };",
			" ",
			"    auto cmp = [](pair<ll, ll>& p, pair<ll, ll>& pp) {",
			"        if (p.first == pp.first) return p.second < pp.second;",
			"        return p.first < pp.first;",
			"    };",
			" ",
			"    sort(all(points), cmp); ll n = points.size();",
			"    pair<ll, ll>a = points[0], c = points[n - 1];",
			"    vector<pair<ll, ll>>up, down;",
			"    up.push_back(a); down.push_back(a);",
			"    for (ll i = 1; i < points.size(); i++) {",
			"        if (i == n - 1 || !ccw(a, points[i], c)) {",
			"            // upper half and colinear",
			"            while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], points[i])) {",
			"                up.pop_back();",
			"            }",
			"            up.push_back(points[i]);",
			"        }",
			"        if (i == n - 1 || !cw(a, points[i], c)) {",
			"            //lower Half and colinear",
			"            while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], points[i])) {",
			"                down.pop_back();",
			"            }",
			"            down.push_back(points[i]);",
			"        }",
			"    }",
			"    points.clear();",
			"    for (size_t i = 0; i < up.size(); i++)  points.push_back(up[i]);",
			"    for (size_t i = 0; i < down.size(); i++) points.push_back(down[i]);",
			" ",
			"    // Points vector has duplicate values also ",
			"    // as which belongs both upper half and lower half",
			"    // https://codeforces.com/contest/1858/submission/218957587",
			" ",
			"}"
		],
		"description": "convexhullgrahamscan"
	},
	"geometry": {
		"prefix": "geometry",
		"body": [
			"struct point",
			"{",
			"   int x, y, idx;",
			"};",
			"",
			"//Finds squared euclidean distance between two points",
			"int dist(point &a, point &b)",
			"{",
			"   return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);",
			"}",
			"",
			"//Checks if angle ABC is a right angle",
			"int isOrthogonal(point &a, point &b, point &c)",
			"{",
			"   return (b.x-a.x) * (b.x-c.x) + (b.y-a.y) * (b.y-c.y) == 0;",
			"}",
			"",
			"//Checks if ABCD form a rectangle (in that order)",
			"int isRectangle(point &a, point &b, point &c, point &d)",
			"{",
			"   return isOrthogonal(a, b, c) && isOrthogonal(b, c, d) && isOrthogonal(c, d, a);",
			"}",
			"",
			"//Checks if ABCD form a rectangle, in any orientation",
			"int isRectangleAnyOrder(point &a, point &b, point &c, point &d)",
			"{",
			"   return isRectangle(a, b, c, d) || isRectangle(b, c, a, d) | isRectangle(c, a, b, d);",
			"}",
			"",
			"//Checks if ABCD form a square (in that order)",
			"int isSquare(point &a, point &b, point &c, point &d)",
			"{",
			"   return isRectangle(a, b, c, d) && dist(a, b) == dist(b, c);",
			"}",
			"",
			"//Checks if ABCD form a square, in any orientation",
			"int isSquareAnyOrder(point &a, point &b, point &c, point &d)",
			"{",
			"   return isSquare(a, b, c, d) || isSquare(b, c, a, d) | isSquare(c, a, b, d);",
			"}"
		],
		"description": "geometry"
	},
	"StressTesting": {
		"prefix": "stresstesting",
		"body": [
			"int rnd(int a, int b){",
			"    return a + rand() % (b - a + 1);",
			"}",
			"int generator(){",
			"    // This function acts as a generator.",
			"    int w = rnd(1, 100);",
			"    return w;",
			"}",
			"string solve(int w){",
			"    // This function acts as the WA solution to test.",
			"    if(w%2==0)return \"YES\";",
			"    return \"NO\";",
			"}",
			"",
			"string bruteForce(int w){",
			"    // This function acts as the brute force solution.",
			"    for(int i=1;i<w;i++){",
			"        int j = w - i;",
			"        if(i%2==0 && j%2==0)return \"YES\";",
			"    }",
			"    return \"NO\";",
			"}",
			"void check(int w, string myAnswer, string correctAnswer){",
			"    // This function acts as the checker.",
			"    if(myAnswer == correctAnswer)return;",
			"    cout<<\"Found the WA test\"<<\"\\n\";",
			"    cout<<\"W = \"<<w<<\"\\n\";",
			"    cout<<\"myAnswer = \"<<myAnswer<<\"\\n\";",
			"    cout<<\"correctAnswer = \"<<correctAnswer<<\"\\n\";",
			"    exit(0);",
			"}",
			"int main() {",
			"    for(int i = 1 ; ; i++){",
			"        int w = generator() ;",
			"        string myAnswer = solve(w) ;",
			"        string correctAnswer = bruteForce(w) ;",
			"        check(w, myAnswer, correctAnswer) ;",
			"        cout<<\"Passed test: \"<<i<<\"\\n\" ;",
			"    }",
			"}"
		],
		"description": "StressTesting"
	},
	"Template 5": {
		"prefix": "interactive..interactor",
		"body": [
			"struct Interactor{",
			"    int hiddenNumber ;",
			"    int limitQueries = 0 ;",
			"    int queries = 0 ;",
			"    Interactor(){ // it is constructor of this struct",
			"        hiddenNumber = getRandomNumber(1 , 1000) ; // initialize this variable called hiddenNumber",
			"        limitQueries = 100 ; // limit by your self for debuging.",
			"    }",
			"    char query(int x , bool printOutput){",
			"        if(queries >= limitQueries){",
			"            cout << \"You have exceeded the number of queries\" << \"\\n\" ;",
			"        }else{",
			"            queries++;",
			"        }",
			"        // assert(queries < limitQueries) // Your code stops here if this is false give out a runtime error.",
			"        char ans = '=';",
			"        if(x > hiddenNumber){",
			"            ans = '>';",
			"        }",
			"        else if(x < hiddenNumber){",
			"            ans = '<';",
			"        }",
			"        else{",
			"            ans = '=';",
			"        }",
			"        if(printOutput){",
			"            cout << ans << \"\\n\";",
			"        }",
			"        return ans;",
			"    }",
			"    bool correctOutput(int x){",
			"        if(x == hiddenNumber){",
			"            cout << \"Passed for \" << x << \"\\n\";",
			"        }else{",
			"            cout << \"Failed\" << \"\\n\" ;",
			"            cout << \"Hidden Number: \" << hiddenNumber << \"\\n\";",
			"            cout << \"Output Given: \" << x << \"\\n\";",
			"        }",
			"        return x == hiddenNumber;",
			"    }",
			"}"
		],
		"description": "Template 5"
	}
}