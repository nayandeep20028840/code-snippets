// {
// 	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
// 	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
// 	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
// 	// same ids are connected.
// 	// Example:
// 	// "Print to console": {
// 	// 	"prefix": "log",
// 	// 	"body": [
// 	// 		"console.log('$1');",
// 	// 		"$2"
// 	// 	],
// 	// 	"description": "Log output to console"
// 	// }
// }

{
	"kashi..": {
		"prefix": "main2",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"// Policy based data structures(PBDS) C++ STL",
			"// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			"// order_of_key(k): returns count of elements strictly smaller than k ",
			"// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // for pairs only define simply by ordered_set s",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"template<class T>using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree<pair<int,int>> s; for pairs",
			// "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>multisat;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ll                long long // typedef array<int, 2> ii; pair h ye",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			//"// #define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define INF               1000000000000000000",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const int mod97 = 1000000007 ;",
			"const int modg = 998244353 ;",
			"const int N = 2e1 + 1 ;",
			"const int LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor",
			"int LCM(int a, int b){return (a / GCD(a, b) * b) ;}",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modpower(int x, int y){long long res = 1; x = x % mod97; while(y > 0){if(y&1) res = (res * (long long)x) % mod97; y = y >> 1; x = ((long long)x * (long long)x) % mod97 ;}return res ;} ",
			"int modinv(int x){return modpower(x , mod97 - 2) ;} ",
			"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i * i <= n; ++i){if(isPrime[i] == true){for(int j = 2 * i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;} // Time Complexity - O(n * sqrt(n) * log(n)) ",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;} // can be calculated in O(n) ",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			// "int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}",
			// "int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}",
			"",
			// "vector<vector<int > > adj ;",
			// "vector<int > visited ;",
			// "vector<int > value ;",
			// "",
			"bool solve(){",
			// "    //adj.assign(n + 1 , vector<int >());",
			// "    //visited.assign(n + 1 , false) ;",
			// "    //value.assign(n + 1 , 0) ;",
			"\t$1",
			"    return true ;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"//#ifndef ONLINE_JUDGE",
			"//    freopen(\"input.txt\",\"r\",stdin);",
			"//    freopen(\"output.txt\",\"w\",stdout);",
			"//    freopen(\"error.txt\", \"w\", stderr);",
			"//#endif ",
			"    int t ;",
			"    cin >> t ;  ",
			"    //int count = 1 ;",
			"",
			"    while (t--){",
			"        //cout << \"Case #\" << count << \": \";",
			"        if(solve()){",
			"            //count++ ;",
			"        }else{",
			"            // no ",
			"        }",
			"    }",
			"    return 0 ;",
			"}",
			"",
			"",
			"",
			// " // Assume worst when things happens to you. Do best when you can.",
			" // Talk is Cheap. Show me the code ",
			// " // Don't overthink and try to prove your idea. ",
			// "// Think twice, code once. // rab ne bana di jodi "
		],
		"description": "kashi.."
	},
	"kashi.": {
		"prefix": "main1",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			// "// Policy based data structures(PBDS) C++ STL",
			// "// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			// "// order_of_key(k): returns count of elements strictly smaller than k ",
			// "// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // for pairs only define simply by ordered_set s",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"template<class T>using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree<pair<int,int>> s; for pairs",
			// "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>multisat;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ll                long long",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			//"// #define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define INF               1000000000000000000",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const int mod97 = 1000000007 ;",
			"const int modg = 998244353 ;",
			"const int N = 2e1 + 1 ;",
			"const int LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);}",
			"int LCM(int a, int b){return (a / GCD(a, b) * b) ;}",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modpower(int x, int y){long long res = 1; x = x % mod97; while(y > 0){if(y&1) res = (res * (long long)x) % mod97; y = y >> 1; x = ((long long)x * (long long)x) % mod97 ;}return res ;} ",
			"int modinv(int x){return modpower(x , mod97 - 2) ;} ",
			"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i * i <= n; ++i){if(isPrime[i] == true){for(int j = 2 * i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;} // Time Complexity - O(n * sqrt(n) * log(n)) ",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;} // can be calculated in O(n) ",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			// "int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}",
			// "int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}",
			"",
			// "vector<vector<int > > adj ;",
			// "vector<int > visited ;",
			// "vector<int > value ;",
			// "",
			"bool solve(){",
			// "    //adj.assign(n + 1 , vector<int >());",
			// "    //visited.assign(n + 1 , false) ;",
			// "    //value.assign(n + 1 , 0) ;",
			"\t$1",
			"    return true ;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"//#ifndef ONLINE_JUDGE",
			"//    freopen(\"input.txt\",\"r\",stdin);",
			"//    freopen(\"output.txt\",\"w\",stdout);",
			"//    freopen(\"error.txt\", \"w\", stderr);",
			"//#endif ",
			"    int t = 1 ;",
			"    //cin >> t ;  ",
			"    //int count = 1 ;",
			"",
			"    while (t--){",
			"        //cout << \"Case #\" << count << \": \";",
			"        if(solve()){",
			"            //count++;",
			"        }else{",
			"            // no ",
			"        }",
			"    }",
			"    return 0 ;",
			"}",
			"",
			"",
			"",
			"",
			" // Talk is Cheap. Show me the code ",
			""
		],
		"description": "kashi."
	},
	"jaishrimahakal": {
		"prefix": "leetcode",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			// "// Policy based data structures(PBDS) C++ STL",
			// "// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			// "// order_of_key(k): returns count of elements strictly smaller than k ",
			// "// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // for pairs only define simply by ordered_set s",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"template<class T>using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree<pair<int,int>> s; for pairs",
			// "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>multisat;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			//"// #define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define INF               1000000000000000000",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const int mod97 = 1000000007 ;",
			"const int modg = 998244353 ;",
			"const int N = 2e1 + 1 ;",
			"const int LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);}",
			"int LCM(int a, int b){return (a / GCD(a, b) * b) ;}",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modpower(int x, int y){long long res = 1; x = x % mod97; while(y > 0){if(y&1) res = (res * (long long)x) % mod97; y = y >> 1; x = ((long long)x * (long long)x) % mod97 ;}return res ;} ",
			"int modinv(int x){return modpower(x , mod97 - 2) ;} ",
			"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i <= n; ++i){if(isPrime[i] == true){for(int j = 2*i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;}",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;}",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			// "int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}",
			// "int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}",
			"",
			"/* //------------------------------------------------------- Template Ends. */",
			"",
			"",
			"",
			""
		],
		"description": "jaishrimahakal"
	},
	"wow": {
		"prefix": "nayan",
		"body": [
			"function<void(int , int) > func = [&](int child , int parent)->void{",
			"\t$1",
			"};"
		],
		"description": "wow"
	},
	"StressTesting": {
		"prefix": "stresstesting",
		"body": [
			"int rnd(int a, int b){",
			"    return a + rand() % (b - a + 1);",
			"}",
			"int generator(){",
			"    // This function acts as a generator.",
			"    int w = rnd(1, 100);",
			"    return w;",
			"}",
			"string solve(int w){",
			"    // This function acts as the WA solution to test.",
			"    if(w%2==0)return \"YES\";",
			"    return \"NO\";",
			"}",
			"",
			"string bruteForce(int w){",
			"    // This function acts as the brute force solution.",
			"    for(int i=1;i<w;i++){",
			"        int j = w - i;",
			"        if(i%2==0 && j%2==0)return \"YES\";",
			"    }",
			"    return \"NO\";",
			"}",
			"void check(int w, string myAnswer, string correctAnswer){",
			"    // This function acts as the checker.",
			"    if(myAnswer == correctAnswer)return;",
			"    cout<<\"Found the WA test\"<<endl;",
			"    cout<<\"W = \"<<w<<endl;",
			"    cout<<\"myAnswer = \"<<myAnswer<<endl;",
			"    cout<<\"correctAnswer = \"<<correctAnswer<<endl;",
			"    exit(0);",
			"}",
			"int main() {",
			"    for(int i=1;;i++){",
			"        int w = generator();",
			"        string myAnswer = solve(w);",
			"        string correctAnswer = bruteForce(w);",
			"        check(w, myAnswer, correctAnswer);",
			"        cout<<\"Passed test: \"<<i<<endl;",
			"    }",
			"}"
		],
		"description": "StressTesting"
	},
	"deadlypillow": {
		"prefix": "deadlypillowncr",
		"body": [
			"int F[N], iF[N]; // Don't forget to change the value of N. factorial,Inverse Factorial Array",
			"// if you want to use without any mod than mod will be INF ",
			"",
			"int fast(int b, int e) {",
			"    int res = 1;",
			"    for (; e; e >>= 1, b = b * b % mod97)",
			"        if (e & 1)",
			"            res = res * b % mod97;",
			"    return res;",
			"}",
			"",
			"void init() {",
			"    F[0] = 1 ;",
			"    for(int i = 1 ; i < N ; ++i) F[i] = (F[i - 1] * i) % mod97;",
			"    iF[N - 1] = fast(F[N - 1] , mod97 - 2) ; // it finds the inverse of F[N - 1] ",
			"    for (int i = N - 2 ; i >= 0 ; --i)",
			"        iF[i] = iF[i + 1] * (i + 1) % mod97 ;",
			"}",
			"",
			"int NCR(int n, int r) {",
			"    if (r > n || r < 0)",
			"        return 0 ;",
			"    return iF[r] * F[n] % mod97 * iF[n - r] % mod97 ;",
			"}"
		],
		"description": "deadlypillow"
	},
	"ababbaba":{
		"prefix": "concepts",
		"body": [
		"//lower bound of p mtlb p se just badda ya uske equal agr lower bound ke it ko -- kra to just chota milega agr ye it s.end hai to mtlb vo element ya usse badda element nhi hai aur agr ye sbegin hai to uss element se chota element nhi hai",
		"//upper bound of p mtlb p se just badda uske equal nhi agr ye s.end() hai to mtlb uss element se badda element nhi hai aur agr iske it ko it-- kre to uss p se just chota ya uske equal element milega but agr ye s.begin hai to usme koi bhi element p ya p se chota nhi hai",
		"If Inserting / pushing elements in a set / priority_queue it takes (nlog n) time complexity.",
		"Never use map< pair<int , int > , int > mp instead use vector<unordered_map<int , int > > v(n)",
		],
		"description": "ababbaba"
	},
	"heapiFy": {
		"prefix": "heapiFy",
		"body": [
			"    class minHeap {",
			"public:",
			"",
			"    // Constructor for the class.",
			"    vector<int > heap ;",
			"    int siz , cap ;",
			"    minHeap(int n) {",
			"        heap.resize(n) ;",
			"        siz = 0 ;",
			"        cap = n ;",
			"    }",
			"",
			"    void heapiFy(int i){",
			"        int smallest = i ;",
			"        int left = 2*i + 1 ;",
			"        int right = 2*i + 2 ;",
			"        if(left < siz && heap[left] < heap[smallest]){",
			"            smallest = left ;",
			"        }",
			"        if(right < siz && heap[right] < heap[smallest]){",
			"            smallest = right ;",
			"        }",
			"        if(smallest != i){",
			"            swap(heap[i] , heap[smallest]) ;",
			"            heapiFy(smallest) ;",
			"        }",
			"    }",
			"    // Implement the function to remove minimum element.",
			"    int extractMinElement() {",
			"        // Write you code here.",
			"        if(siz == 0){",
			"            return -1 ;",
			"        }",
			"        int ans = heap[0] ;",
			"        swap(heap[0] , heap[siz - 1]) ;",
			"        siz-- ;",
			"        heapiFy(0) ;",
			"        return ans ;",
			"    }",
			"",
			"    // Implement the function to delete an element.",
			"    void deleteElement(int ind) {",
			"        // Write you code here.",
			"        if(ind >= siz){",
			"            return ;",
			"        }",
			"        swap(heap[ind] , heap[siz - 1]) ;",
			"        siz-- ;",
			"        heapiFy(ind) ;",
			"",
			"    }",
			"",
			"    // Implement the function to insert 'val' in the heap.",
			"    void insert(int val) {",
			"        // Write you code here.",
			"        if(siz == cap){",
			"            return ;",
			"        }",
			"        heap[siz] = val ;",
			"        int i = siz ;",
			"        while(i > 0 && heap[(i - 1)/2] > heap[i]){",
			"            swap(heap[(i - 1)/2] , heap[i]) ;",
			"            i = (i - 1)/2 ;",
			"        }",
			"        siz++ ;",
			"",
			"    }",
			"};",
			"",
			"void btup heapiFy(vector<int > &a , int n){ // min heap not for max heap",
			"    for(int i = n / 2 - 1 ; i >= 0 ; --i){",
			"        int item = a[i] ;",
			"        int child = 2 * i + 1 ;",
			"        while(child <= n - 1){",
			"            if(child + 1 <= n - 1 && a[child + 1] < a[child]){ // for max heap a[child + 1] > a[child]",
			"                child++ ;",
			"            }",
			"            if(a[child] < item){ // for max heap a[child] > item",
			"                a[i] = a[child] ;",
			"            }",
			"            else{",
			"                break ;",
			"            }",
			"            child = 2 * child + 1 ; ",
			"        }",
			"        a[i] = item ;",
			"    }",
			"}",
			"",
			"void tpdn heapiFy(vector<int > &a , int n){ // min heap not for max heap",
			"    for(int i = 1 ; i <= n - 1 ; ++i){",
			"        int key = a[i] ;",
			"        int child = i ;",
			"        int parent = (child - 1) / 2 ;",
			"        while(c > 0 && a[parent] < key){ // for max heap a[parent] > key and for min heap a[parent] < key",
			"            a[child] = a[parent] ;",
			"            child = parent ;",
			"            parent = (child - 1) / 2 ;",
			"            a[child] = key ;",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "heapiFy"
	},
	"lps-longestprefixsuffix": {
		"prefix": "lps-longestprefixsuffix",
		"body": [
			"LPS (Longest Prefix Suffix) Algorithm:",
			"",
			"Purpose: The LPS algorithm is primarily used to find the length of the longest proper prefix which is also a proper suffix of a given string for each position in the string.",
			"",
			"Key Concept: It calculates an array where each element at index i represents the length of the longest proper prefix of the substring ending at position i that is also a proper suffix of the substring.",
			"",
			"Usage: It is used as a building block in other string matching algorithms, like the KMP algorithm.",
			"",
			"vector<int > longestprefixsuffix(string s){",
			"    int n = s.size();",
			"    vector<int > lps(n , 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            len++ ;  ",
			"            lps[i] = len ;",
			"            i++ ;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1] ;",
			"            }else{",
			"                lps[i] = 0 ;",
			"                i++ ;",
			"            }",
			"        }",
			"    }",
			"    return lps ;",
			"}"
		],
		"description": "lps-longestprefixsuffix"
	},
	"z_function": {
		"prefix": "z_function",
		"body": [
			"vector<int > z_function(string s){",
			"    int n = s.size() ;",
			"    vector<int > z(n , 0) ;",
			"    int i = 1 , l = 0 , r = 0 ;",
			"    while(i < n){",
			"        if(i <= r){",
			"            // copy because in range ",
			"            z[i] = min(z[i - l] , r - i + 1) ;",
			"        }",
			"        // our basic logic goes here ",
			"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]){",
			"            z[i]++ ;",
			"        }",
			"        if(i + z[i] - 1 > r){",
			"            // update the range",
			"            l = i ;",
			"            r = i + z[i] - 1 ;",
			"        }",
			"        i++ ;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "z_function"
	},
	"kmp": {
		"prefix": "kmp",
		"body": [
			"vector<int > longestprefixsuffix(string s){",
			"    int n = s.size();",
			"    vector<int > lps(n , 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            len++ ;  ",
			"            lps[i] = len ;",
			"            i++ ;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1] ;",
			"            }else{",
			"                lps[i] = 0 ;",
			"                i++ ;",
			"            }",
			"        }",
			"    }",
			"    return lps ;",
			"}",
			"",
			"/*",
			"",
			"KMP (Knuth-Morris-Pratt) Algorithm:",
			"",
			"Purpose: KMP is a more comprehensive algorithm used to efficiently search for a pattern within a text while avoiding unnecessary character comparisons.",
			"",
			"Key Concept: It constructs a prefix array (also known as the LPS array) for the pattern and uses this array to skip characters in the text during the search, reducing the number of character comparisons.",
			"",
			"Advantages: KMP is known for its linear time complexity, making it efficient for large texts.",
			"",
			"Usage: It's widely used in text searching, text processing, and string matching applications.",
			"",
			"",
			"*/",
			"",
			"void kmp(string s, string p){",
			"    int plen = p.size() ;",
			"    int slen = s.size() ;",
			"    vector<int > pattern_lps = longestprefixsuffix(p) ;",
			"    int len = 0 ;",
			"    int i = 0 ;",
			"    int cnt = 0 ;",
			"    while(i < slen){",
			"        if(s[i] == p[len]){",
			"            len++ ;",
			"            i++ ;",
			"        }",
			"        else{",
			"            if(len != 0){",
			"                len = pattern_lps[len - 1] ;",
			"            }else{",
			"                i++ ;",
			"            }",
			"        }",
			"        if(len == plen){",
			"            cnt++ ;",
			"            len = pattern_lps[len - 1] ;",
			"        }",
			"    }",
			"    cout << cnt << endl ;",
			"}"
		],
		"description": "kmp"
	},
	"BIT": {
		"prefix": "bit",
		"body": [
			"template<class T>",
			"struct BIT{",
			"    int n;",
			"    vector<T> tree;",
			"    BIT(int __n = 0) : n(__n + 1){",
			"        tree = vector<T>(n, 0);",
			"    }",
			"    BIT(const vector<T> &a, int __n) : n(__n + 1){",
			"        tree.resize(n);",
			"        for(int i = 0 ; i < n - 1 ; i++) {",
			"            pointupdate(i, a[i]);",
			"        }",
			"    }",
			"    void update(int i, T delta){",
			"        for(i++ ; i < n ; i += (i & -i))    tree[i] += delta;",
			"    }",
			"    T psum(int i){",
			"        T sum = 0;",
			"        for(i++ ; i > 0 ; i -= i & -i)    sum += tree[i];",
			"        return sum;",
			"    }",
			"    T rsum(int i, int j){",
			"        return (psum(j) - psum(i-1));",
			"    }",
			"};",
			"",
			"/*",
			"",
			"how to access the struct of BIT",
			"BIT<int> bit(n + 5);",
			"",
			"*/"
		],
		"description": "BIT"
	},
	"fenwick": {
		"prefix": "fenwicktree",
		"body": [
		"struct FenwickTree {",
		"    vector<int> bit , fen ;  ",
		"    int n ;",
		"    map<int , int > ans ;",
		"",
		"    FenwickTree(int n) {",
		"        this->n = n ;",
		"        bit.assign(n , 0) ; ",
		"    }",
		"",
		"    FenwickTree(vector<int > a) : FenwickTree(a.size()) {",
		"        for (size_t i = 0 ; i < a.size() ; i++)",
		"            update(i , a[i]) ;",
		"    }",
		"",
		"    int sum(int r) {",
		"        int ret = 0 ;",
		"        for (; r >= 0 ; r = (r & (r + 1)) - 1){",
		"            ret += bit[r] ;",
		"        }",
		"        return ret ; ",
		"    }",
		"",
		"    int rangesum(int l , int r) {",
		"        return sum(r) - sum(l - 1) ;",
		"    }",
		"",
		"    void update(int idx , int add) {",
		"        ans[idx] += add ;",
		"",
		"        if(ans[idx] > 1 || (ans[idx] == 1 && add < 0)) return ;",
		"        ",
		"        for (; idx < n ; idx = idx | (idx + 1)){",
		"            bit[idx] += add ; ",
		"        }",
		"    }",
		"};"
		],
		"description": "fenwick"
	},
	"mosalgorithm": {
		"prefix": "mosalgorithm",
		"body": [
		  "const int NN = 2e5+1 ; // warning don't exceed 1e7+1e6 ;",
			"int block_size ;",
			"vector<int > v(NN) ;",
			"vector<int > freq(NN) ;",
			"int answer = 0 ;",
			"",
			"struct Query { // name of the structure",
			"    int l , r , idx ;",
			"",
			"    Query(int _l , int _r , int _idx) : l(_l) , r(_r) , idx(_idx) { // These lines initialize the member variables with the values passed as arguments to the constructor.",
			"",
			"    } // defining a constructor for a structure. The constructor initializes three member variables: l, r, and idx, presumably within the context of that structure.",
			"",
			"    bool operator<(Query other) const // sort the queries",
			"    {",
			"        return make_pair(l / block_size, r) <            // jaadu",
			"                make_pair(other.l / block_size, other.r);",
			"    }",
			"};",
			"",
			"void remove(int idx) { // TODO: remove value at idx from data structure",
			"    ",
			"}  ",
			"void add(int idx) {  // TODO: add value at idx from data structure",
			"    ",
			"}    ",
			"int get_answer() { // TODO: extract the current answer of the data structure",
			"    return answer ;",
			"}  ",
			"",
			"vector<int > mo_s_algorithm(vector<Query > queries) {",
			"    vector<int > answers(queries.size()) ;",
			"    sort(queries.begin(), queries.end()) ;",
			"",
			"    // TODO: initialize data structure",
			"",
			"    int cur_l = 0 ;",
			"    int cur_r = -1 ;",
			"    // invariant: data structure will always reflect the range [cur_l, cur_r]",
			"    for (Query q : queries) {",
			"        while (cur_l > q.l) {",
			"            cur_l-- ;",
			"            add(cur_l) ;",
			"        }",
			"        while (cur_r < q.r) {",
			"            cur_r++ ;",
			"            add(cur_r) ;",
			"        }",
			"        while (cur_l < q.l) {",
			"            remove(cur_l) ;",
			"            cur_l++ ;",
			"        }",
			"        while (cur_r > q.r) {",
			"            remove(cur_r) ;",
			"            cur_r-- ;",
			"        }",
			"        answers[q.idx] = get_answer() ;",
			"    }",
			"    return answers ;",
			"}",
			"",
			"/*",
			"",
			"    Time complexity : very important O(Q * logQ) for sorting +(plus) Q * root(n)",
			"    for all query combined maximum range covered is root(n)",
			"",
			"    define block_size as",
			"    {",
			"        int sq = sqrtl(n) ;",
			"        block_size = sqrtl(n) + (n % sq == 0 ? 0 : 1) ;",
			"    }",
			"",
			"    vector<Query > queries ;",
			"    vector<int > got_it = mo_s_algorithm(queries) ;",
			"    for(int i = 0 ; i < q ; ++i){",
			"        cout << got_it[i] << nl ;",
			"    }",
			"",
			"*/"
		],
		"description": "mosalgorithm"
	},
	"segment": {
		"prefix": "segmenttree",
		"body": [
			//"// Segment Tree with Point Updates and Range Queries",
			//"// Supports multiple Segment Trees with just a change in the Node and Update",
			//"// Very few changes required everytime",
			"",
			"template<typename Node, typename Update>",
			"struct SegTree {",
			"    vector<Node > tree ; // it will change according to the node ",
			"    vector<int > arr ; // type may change ",
			"    int n , s ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    SegTree(int array_len, vector<int> &a) { // change if type updated",
			"        arr = a ;",
			"        n = array_len ; ",
			"        s = 1 ;",
			"        while(s < 2 * n){",
			"            s = (s << 1) ;",
			"        }",
			"        tree.resize(s); ",
			"        fill(all(tree), Node()) ;",
			"        build(0 , n - 1 , 1) ;",
			"    }",
			"    void build(int start, int end, int index)  // Never change this",
			"    {",
			"        if(start == end){",
			"            tree[index] = Node(arr[start]) ; // may change ",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(start, mid, 2 * index) ;",
			"        build(mid + 1, end, 2 * index + 1) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void update(int start, int end, int index, int query_index, Update &u)  // Never Change this",
			"    {",
			"        if(start == end){",
			"            u.apply(tree[index]) ;",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        if(mid >= query_index)",
			"            update(start, mid, 2 * index, query_index, u);",
			"        else",
			"            update(mid + 1 , end , 2 * index + 1 , query_index, u) ;",
			"        tree[index].merge(tree[2 * index], tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int start, int end, int index, int left, int right) { // may change ",
			"        if(start > right || end < left) // may change // both if statements can be removed",
			"            return Node() ;",
			"        if(start >= left && end <= right) // may change // both if statements can be removed",
			"            return tree[index] ; ",
			"        int mid = (start + end) / 2 ; ",
			"        Node l , r , ans ; ",
			"        l = query(start , mid , 2 * index , left, right) ; ",
			"        r = query(mid + 1 , end , 2 * index + 1 , left , right) ; ",
			"        ans.merge(l , r) ; ",
			"        return ans ; ",
			"    }",
			"    void make_update(int index, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val); // may change",
			"        update(0 , n - 1 , 1 , index , new_update) ;",
			"    }",
			"    Node make_query(int left , int right) { // may change",
			"        return query(0 , n - 1 , 1 , left , right) ; // may change",
			"    }",
			"    int first(){",
			"        return tree[1].val ;",
			"    }",
			"    void output(){",
			"        for(int i = 1 ; i < s ; ++i){",
			"            cout << tree[i].val <<  \" \" ;",
			"        }",
			"    }",
			"};" ,
			"", 
			"struct Node1 {",
			"    int val ; // may change",
			"    Node1() { // Identity element // its type of null node. ",
			"        val = 0 ; // may change" ,
			"    }",
			"    Node1(int p1) {  // Actual Node",
			"        val = p1 ; // may change",
			"    }",
			"    friend void merge(Node1 &l, Node1 &r) { // Merge two child nodes",
			"        val = l.val ^ r.val ;  // may change",
			"    }",
			"};",
			"",
			"struct Update1 {",
			"    int val ; // may change",
			"    Update1(int p1) { // Actual Update",
			"        val = p1 ; // may change",
			"    }",
			"    friend apply(Node1 &a) { // apply update to given node",
			"        a.val = val ; // may change",
			"    }",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"SegTree<Node1 , Update1> SEGMENT_TREE = SegTree<Node1 , Update1 > (n , v) ;",
			"",
			"*/"
		],
		"description": "segment"
	},
	"lazy": {
		"prefix": "lazysegmenttree",
		"body": [
			"// Lazy Segment Tree with Range Updates and Range Queries",
			"// Supports multiple Segment Trees with just a change in the Node and Update",
			"// Very few changes required everytime",
			"",
			"template<typename Node, typename Update>",
			"struct LazySGT {",
			"    vector<Node > tree ; // no change",
			"    vector<bool > lazy ; // no change",
			"    vector<Update > updates ; // no change",
			"    vector<int > arr ; // type may change",
			"    int n ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    LazySGT(int array_len , vector<int > &a) { // change if type updated",
			"        arr = a ;",
			"        n = array_len ;",
			"        sz = 1 ;",
			"        while(sz < 2 * n){",
			"            sz = (sz << 1) ;",
			"        }",
			"        tree.resize(sz) ; fill(all(tree) , Node()) ;",
			"        lazy.resize(sz) ; fill(all(lazy) , false) ;",
			"        updates.resize(sz) ; fill(all(updates) , Update()) ;",
			"        build(0 , n - 1 , 1) ;",
			"    }",
			"    void build(int start , int end , int index) { // Never change this",
			"        if (start == end)   {",
			"            tree[index] = Node(arr[start]) ; // no changes",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(start , mid, 2 * index) ;",
			"        build(mid + 1 , end , 2 * index + 1) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void pushdown(int index , int start , int end){",
			"        if(lazy[index]){",
			"            int mid = (start + end) / 2 ; ",
			"            apply(2 * index , start , mid , updates[index]) ;",
			"            apply(2 * index + 1 , mid + 1 , end , updates[index]) ;",
			"            updates[index] = Update() ;",
			"            lazy[index] = 0 ;",
			"        }",
			"    }",
			"    void apply(int index , int start , int end , Update& u){",
			"        if(start != end){",
			"            lazy[index] = 1 ; // no changes",
			"            updates[index].combine(u , start , end) ; // it is applied on non array elements that is the parent elements on the array elements ",
			"        }",
			"        u.apply(tree[index] , start , end) ; // it is applied on one element only change according to the question ",
			"    }",
			"    void update(int start, int end, int index, int left, int right, Update &u) {  // Never Change this // O(logn) ",
			"        if(start > right || end < left)",
			"            return ;",
			"        if(start >= left && end <= right){",
			"            pushdown(index , start , end) ;",
			"            apply(index , start , end , u) ;",
			"            return ;",
			"        }",
			"        pushdown(index , start , end) ; // doing for both query and updates ",
			"        int mid = (start + end) / 2 ;",
			"        update(start , mid , 2 * index , left , right , u) ;",
			"        update(mid + 1 , end , 2 * index + 1 , left , right , u) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int start, int end, int index, int left, int right) { // Never change this",
			"        if (start > right || end < left)",
			"            return Node(); // warning it is for query answers only what should be the output answer",
			"        if (start >= left && end <= right){",
			"            pushdown(index , start , end) ;",
			"            return tree[index] ;",
			"        }",
			"        pushdown(index , start , end) ; // doing for both query and updates ",
			"        int mid = (start + end) / 2 ;",
			"        Node l , r , ans ;",
			"        l = query(start , mid , 2 * index , left , right) ;",
			"        r = query(mid + 1 , end , 2 * index + 1 , left , right) ;",
			"        ans.merge(l , r) ;",
			"        return ans ;",
			"    }",
			"    void make_update(int left, int right, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val) ; // may change",
			"        update(0 , n - 1 , 1 , left , right , new_update) ;",
			"    }",
			"    Node make_query(int left, int right) {",
			"        return query(0 , n - 1 , 1 , left , right) ;",
			"    }",
			"    int first(){",
			"        return tree[1].val ;",
			"    }",
			"    void output(){",
			"        for(int i = 0 ; i < sz ; ++i){",
			"            cout << tree[i].val <<  \" \" ;",
			"        }",
			"    }",
			"    void output2(){",
			"        for(int i = 0 ; i < sz ; ++i){",
			"            cout << updates[i].val <<  \" \" ;",
			"        }",
			"    }",
			"};",
			"",
			"struct Node1 {",
			"    int val ; // may change",
			"    Node1() { // Identity element",
			"        val = 0 ;    // may change // warning it is for query answers only what should be the output answer ",
			"        val = power(2 , 30) - 1 ;    // may change",
			"        // val = INF ;    // may change",
			"        // val = -INF ;    // may change",
			"    }",
			"    Node1(int p1) {  // Actual Node",
			"        val = p1 ; // may change",
			"    }",
			"    friend void merge(Node1 &l , Node1 &r) { // Merge two child nodes",
			"        val = (l.val + r.val) ;  // may change",
			"    }",
			"};",
			"",
			"struct Update1 {",
			"    int val ; // may change",
			"    Update1(){ // Identity update",
			"        val = 0 ;",
			"    }",
			"    Update1(int val1) { // Actual Update",
			"        val = val1 ;",
			"    }",
			"    friend void apply(Node1 &a, int start, int end) { // apply update to given node",
			"        a.val = val * (end - start + 1) ; // may change",
			"        // a.val += val * (end - start + 1) ; // may change",
			"        // a.val = val ; // may change",
			"        // a.val += val ; // may change",
			"    }",
			"    friend void combine(Update1& new_update , int start , int end){",
			"        val = new_update.val ;",
			"        // val += new_update.val ;",
			"    }",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"LazySGT<Node1 , Update1> LAZY_SEGMENT_TREE = LazySGT<Node1 , Update1 > (n , v) ;",
			"",
			"*/"
		],
		"description": "lazy"
	},
	"sparse": {
		"prefix": "sparsetable",
		"body": [
			"// O(1) for idempotent O(logN) for general",
			"",
			"template<typename Node>",
			"struct SparseTable {",
			"    vector<vector<Node > > table ;",
			"    vector<int > logValues ;",
			"    int n ;",
			"    int maxLog ;",
			"    vector<int > a ;",
			"    SparseTable(int n1 , vector<int > &arr) {",
			"        n = n1 ;",
			"        a = arr ;",
			"        table.resize(n) ;",
			"        logValues.resize(n + 1) ;",
			"        maxLog = log2(n) ;",
			"        logValues[1] = 0 ;",
			"        // 0 1 1 2 2 2 2 3 3 3  3  3  3  3  3  4  . . . . ",
			"        // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . . . . ",
			"        for(int i = 2 ; i <= n ; ++i) {",
			"            logValues[i] = logValues[i / 2] + 1 ;",
			"        }",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            table[i].resize(maxLog + 1) ;",
			"            fill(all(table[i]) , Node()) ;",
			"        }",
			"        build() ;",
			"    }",
			"    void build() {",
			"        for(int i = 0; i < n; i++) {",
			"            table[i][0] = Node(a[i]) ;",
			"        }",
			"        for(int i = 1 ; i <= maxLog ; ++i) {",
			"            for(int j = 0 ; (j + (1 << i)) <= n ; ++j) {",
			"                table[j][i].merge(table[j][i - 1] , table[j + (1 << (i - 1))][i - 1]) ;",
			"            }",
			"        }",
			"    }",
			"    Node queryNormal(int left , int right) { // O(log(n))",
			"        Node ans = Node() ;",
			"        for(int j = logValues[right - left + 1] ; j >= 0 ; --j) {",
			"            if((1 << j) <= right - left + 1) {",
			"                ans.merge(ans, table[left][j]) ;",
			"                left += (1 << j) ; // will not be (j - 1)",
			"            }",
			"        }",
			"        return ans ; ",
			"    }",
			"    Node queryIdempotent(int left, int right) { // O(1)",
			"        int j = logValues[right - left + 1] ;",
			"        Node ans = Node() ;",
			"        ans.merge(table[left][j] , table[right - (1 << j) + 1][j]) ;",
			"        return ans ;",
			"    }",
			"};",
			"struct Node1 {",
			"    int val ; // store more info if required // may change",
			"    Node1() { // Identity Element",
			"        val = 0 ; // may change",
			"    }",
			"    Node1(int v) {",
			"        val = v ;",
			"    }",
			"    friend void merge(Node1 &l , Node1 &r) { // problem",
			"        val = l.val ^ r.val ;",
			"    }",
			"};",
			"",
			"/*",
			"",
			"        How to build the sparse table ",
			"",
			"        SparseTable<Node1 > SPARSE_TABLE = SparseTable<Node1 > (m , arr) ;",
			"",
			"*/"
		],
		"description": "sparse"
	},
	"treap": {
		"prefix": "treap",
		"body": [
			"struct treap {",
			"    struct node {",
			"        int val, ans, id, sz, prior, lazy_ans, lazy_val, mx, mn;",
			"        node *l, *r, *par;",
			"        node(int _val, int _id) {",
			"            val = _val; mx=_val; mn=_val; ans = 0; id = _id;",
			"            lazy_ans = 0; lazy_val = 0; sz = 1;",
			"            prior = rnd(); l = NULL; r = NULL; par = NULL;",
			"        }",
			"    };",
			"    typedef node* pnode;",
			"    pnode root;",
			"    void clear() {",
			"        root = NULL;",
			"    }",
			"    treap() {",
			"        clear();",
			"    }",
			"    int size(pnode t) {",
			"        return t ? t->sz : 0;",
			"    }",
			"    void update_size(pnode &t) {",
			"        if(t) t->sz = size(t->l) + size(t->r) + 1;",
			"    }",
			" ",
			"    void update_parent(pnode &t) {",
			"        if(!t) return;",
			"        if(t->l) t->l->par = t;",
			"        if(t->r) t->r->par = t;",
			"    }",
			"    ///add operation",
			"    void push(pnode &t) {",
			"        if(!t)  return;",
			"        if (t->lazy_ans == 0 && t->lazy_val == 0) return;",
			"        t->ans += t->lazy_ans;",
			"        t->val += t->lazy_val;",
			"        t->mx += t->lazy_val;",
			"        t->mn += t->lazy_val;",
			"        if(t->l) {",
			"           t->l->lazy_ans += t->lazy_ans;",
			"           t->l->lazy_val += t->lazy_val;",
			"        }",
			"        if(t->r) {",
			"           t->r->lazy_ans += t->lazy_ans;",
			"           t->r->lazy_val += t->lazy_val;",
			"        }",
			"        t->lazy_ans = 0;",
			"        t->lazy_val = 0;",
			"    }",
			"    void reset(pnode &t) {",
			"        if(!t) return;",
			"        t->mx = t->val;",
			"        t->mn = t->val;",
			"    }",
			"    ///combine node l and r to form t by updating corresponding queries",
			"    void combine(pnode &t, pnode l, pnode r) {",
			"        if(!l) {",
			"            t = r; return;",
			"        }",
			"        if(!r) {",
			"            t = l; return;",
			"        }",
			"        t->mx = max(l->mx,r->mx);",
			"        t->mn = min(l->mn,r->mn);",
			"    }",
			"    ///perform all operations",
			"    void operation(pnode &t) {",
			"        if(!t)    return;",
			"        reset(t);",
			"        push(t->l);",
			"        push(t->r);",
			"        combine(t, t->l, t);",
			"        combine(t, t, t->r);",
			"    }",
			"    void split(pnode t, pnode &l, pnode &r, int k) {",
			"        if(t == NULL) {",
			"            l = NULL;",
			"            r = NULL;",
			"            return;",
			"        }",
			"        push(t);",
			"        if(t -> val <= k)",
			"            split(t->r, t->r, r, k), l = t;",
			"        else",
			"            split(t->l, l, t->l, k), r = t;",
			" ",
			"        update_parent(t);",
			"        update_size(t);",
			"        operation(t);",
			"    }",
			"    ///merge node l with r in t",
			"    void merge(pnode &t, pnode l, pnode r) {",
			"        push(l);",
			"        push(r);",
			"        if(!l) {",
			"            t = r;",
			"            return;",
			"        }",
			"        if(!r) {",
			"            t = l;",
			"            return;",
			"        }",
			" ",
			"        if(l->prior > r->prior)",
			"            merge(l->r, l->r, r), t = l;",
			"        else",
			"            merge(r->l, l, r->l), t = r;",
			" ",
			"        update_parent(t);",
			"        update_size(t);",
			"        operation(t);",
			"    }",
			"    void insert(int val, int id) {",
			"        if(root == NULL) {",
			"            pnode to_add = new node(val, id);",
			"            root = to_add;",
			"            return;",
			"        }",
			" ",
			"        pnode l, r, mid;",
			"        mid = new node(val, id);",
			" ",
			"        split(root, l, r, val);",
			"        merge(l, l, mid);",
			"        merge(root, l, r);",
			"    }",
			"    void upd(int k) {",
			"        pnode l, r, tmp, z; ",
			"        split(root, l, r, k - 1);",
			"        if (r == NULL) {",
			"           merge(root, l, r);",
			"           return;",
			"        }",
			"        r -> lazy_ans++;",
			"        r -> lazy_val -= k;",
			"        push(r);",
			"        operation(r);",
			"        while (l != NULL && r != NULL) {",
			"           if (l -> mx <= r -> mn) break;",
			"           int x = r->mn;",
			"           split(r, tmp, r, x);",
			"           split(l, l, z, x);",
			"           merge(l, l, tmp);",
			"           merge(l, l, z);",
			"        }",
			"        merge(root, l, r);",
			"    }",
			"    vector<int> res;",
			"    void inorder(pnode cur) {",
			"        if(cur==NULL) return;",
			"        operation(cur);",
			"        res[cur ->id] = cur -> ans;",
			"        inorder(cur->l);",
			"        inorder(cur->r);",
			"    }",
			"    // https://codeforces.com/contest/702/submission/92910754",
			"};"
		],
		"description": "treap"
	},
	"Template 4": {
		"prefix": "blackbox",
		"body": [
			"int blackbox(string &s) {",
			"    int n = s.size() ;",
			"    int hash = 0 ; ",
			"    int p = 1 ;",
			"    for(int i = 0 ; i < n ; ++i){",
			"        hash = (hash + ((s[i] - 'a' + 1) * p) % mod97) % mod97 ;",
			"        p = (p * (int)31) % mod97 ;",
			"    }",
			"}"
		],
		"description": "Template 4"
	},
	// "vector<unordered_map<int , int > >": {
	// 	"prefix": "gp_hash_table<int, ll> dp[N];",
	// 	"body": [
	// 		"struct custom_hash {",
	// 		"  static uint64_t splitmix64(uint64_t x) {",
	// 		"    x += 0x9e3779b97f4a7c15;",
	// 		"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
	// 		"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
	// 		"    return x ^ (x >> 31);",
	// 		"  }",
	// 		"  size_t operator()(uint64_t x) const {",
	// 		"    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
	// 		"    return splitmix64(x + FIXED_RANDOM);",
	// 		"  }",
	// 		"};"
	// 	],
	// 	"description": "vector<unordered_map<int , int > >"
	// },
	"Template 6": {
		"prefix": "lps",
		"body": [
			"vector<int > longestprefixsuffix(string &s){",
			"    int n = s.size() ;",
			"    vector<int > lps(n , 0) ;",
			"    int len = 0 ;",
			"    int i = 1 ;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            lps[i] = len + 1 ; // storing the longest common",
			"            len ++ ;",
			"            i ++ ;",
			"        }else{",
			"            if(len == 0){",
			"                lps[i] = 0 ;",
			"                i ++ ;",
			"            }else{",
			"                len = lps[len - 1] ; // A(0)A(1)B(0)A(2)A(2)",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Template 6"
	},
	"Template 5": {
		"prefix": "interactive..interactor",
		"body": [
			"struct Interactor{",
			"    int hiddenNumber ;",
			"    int limitQueries = 0 ;",
			"    int queries = 0 ;",
			"    Interactor(){ // it is constructor of this struct",
			"        hiddenNumber = getRandomNumber(1 , 1000) ; // initialize this variable called hiddenNumber",
			"        limitQueries = 100 ; // limit by your self for debuging.",
			"    }",
			"    char query(int x , bool printOutput){",
			"        if(queries >= limitQueries){",
			"            cout << \"You have exceeded the number of queries\" << endl ;",
			"        }else{",
			"            queries ++ ;",
			"        }",
			"        // assert(queries < limitQueries) // Your code stops here if this is false give out a runtime error.",
			"        char ans = '=' ;",
			"        if(x > hiddenNumber){",
			"            ans = '>' ;",
			"        }",
			"        else if(x < hiddenNumber){",
			"            ans = '<' ;",
			"        }",
			"        else{",
			"            ans = '=' ;",
			"        }",
			"        if(printOutput){",
			"            cout << ans << endl ;",
			"        }",
			"        return ans ;",
			"    }",
			"    bool correctOutput(int x){",
			"        if(x == hiddenNumber){",
			"            cout << \"Passed for \" << x << endl ;",
			"        }else{",
			"            cout << \"Failed\" << endl ;",
			"            cout << \"Hidden Number: \" << hiddenNumber << endl ;",
			"            cout << \"Output Given: \" << x << endl ;",
			"        }",
			"        return x == hiddenNumber ;",
			"    }",
			"}"
		],
		"description": "Template 5"
	},
	"Template 1": {
		"prefix": "dsu",
		"body": [
		"struct DSU {",
		"    int S ; ",
		"    struct node {",
		"        int p; int siz; int rnk; ",
		"    };",
		"    vector<node > dsu ; ",
		"",
		"    DSU(int n) { ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0; ",
		"            dsu.push_back(tmp) ; ",
		"        }",
		"    }",
		"",
		"    void reset(int n) {",
		"        dsu.clear() ; ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0; ",
		"            dsu.push_back(tmp) ; ",
		"        }",
		"    }",
		"",
		"    int parent(int u) {",
		"        if(dsu[u].p == u) return u;",
		"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
		"        return dsu[u].p ; ",
		"    }",
		"",
		"    void mergebysize(int u, int v) {",
        "        u = parent(u); v = parent(v);",
        "        if(u == v) return ;",
        "        if(dsu[u].siz < dsu[v].siz) swap(u , v) ; ",
        "        dsu[v].p = u ; ",
        "        dsu[u].siz += dsu[v].siz ; ",
        "    }",
        "",
        "    void mergebyrank(int u, int v) {",
        "        u = parent(u); v = parent(v);",
        "        if(u == v) return ;",
        "        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v ;",
        "        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u ;",
        "        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1 ; ",
        "    }",
		"",
		"    bool same(int u, int v) {",
		"        if(parent(u) == parent(v)) return true ; ",
		"        return false ; ",
		"    }",
		"",
		"    int get_size(int u) {",
		"        return dsu[parent(u)].siz ; ",
		"    }",
		"};"
		],
		"description": "Template 1"
	},
	"template 7": {
		"prefix": "dijkstra",
		"body": [
			"// // O(VlogV + ElogV) " ,
			"class Solution",
			"{",
			"public:",
			"    vector<int> shortestPath(int n, int m, vector<vector<int>> &edges)",
			"    {",
			"        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}",
			"        // where the edge weight is the weight of the edge from node1 to node2.",
			"        vector< pair< int , int > > adj[n + 1] ;",
			"        for (auto &i : edges)",
			"        {",
			"            adj[i[0]].push_back({i[1], i[2]});",
			"            adj[i[1]].push_back({i[0], i[2]});",
			"        }",
			"        // Create a priority queue for storing the nodes along with distances ",
			"        // in the form of a pair { dist, node }.",
			"        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int , int> > > pq;",
			"",
			"        // Create a dist array for storing the updated distances and a parent array for storing the nodes from where the current nodes represented by indices of the parent array came from.",
			"        vector<int > dist(n + 1 , 1e9) , parent(n + 1) , vis(n + 1 , 0) ;",
			"        for (int i = 1 ; i <= n ; ++i)",
			"            parent[i] = i ;",
			"",
			"        dist[1] = 0 ;",
			"",
			"        // Push the source node to the queue.",
			"        pq.push({0, 1});",
			"        keeping visited vector is important because it was giving TLE for cses problem shortest route 1 for two test cases",
			"        while (!pq.empty())",
			"        {",
			"            // Topmost element of the priority queue is with minimum distance value.",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int dis = it.first ;",
			"            if(vis[node]) continue ;" ,
			"            vis[node] = 1 ;" ,
			"",
			"            // Iterate through the adjacent nodes of the current popped node.",
			"            for (auto it : adj[node])",
			"            {",
			"                int adjNode = it.first;",
			"                int edW = it.second;",
			"",
			"                // Check if the previously stored distance value is greater than the current computed value or not, if yes then update the distance value.",
			"                if (dis + edW < dist[adjNode])",
			"                {",
			"                    dist[adjNode] = dis + edW;",
			"                    pq.push({dis + edW, adjNode});",
			"",
			"                    // Update the parent of the adjNode to the recent node where it came from.",
			"                    parent[adjNode] = node;",
			"                }",
			"            }",
			"        }",
			"",
			"        // If distance to a node could not be found, return an array containing -1.",
			"        if (dist[n] == 1e9)",
			"            return {-1};",
			"",
			"        // Store the final path in the ‘path’ array.",
			"        vector<int> path ;",
			"        int node = n ;",
			"",
			"        // Iterate backwards from destination to source through the parent array.",
			"        while (parent[node] != node)",
			"        {",
			"            path.push_back(node) ;",
			"            node = parent[node] ;",
			"        }",
			"        path.push_back(1) ;",
			"",
			"        // Since the path stored is in a reverse order, we reverse the array to get the final answer and then return the array.",
			"        reverse(path.begin() , path.end()) ;",
			"        return path ;",
			"    }",
			"};"
		],
		"description": "template 7"
	},
	"SCC": {
		"prefix": "StronglyConnectedComponent",
		"body": [
			"struct SCC {",
			"    int n;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int> stk;",
			"    std::vector<int> dfn, low, bel;",
			"    int cur, cnt;",
			"    ",
			"    SCC() {}",
			"    SCC(int n) {",
			"        init(n);",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n;",
			"        adj.assign(n, {});",
			"        dfn.assign(n, -1);",
			"        low.resize(n);",
			"        bel.assign(n, -1);",
			"        stk.clear();",
			"        cur = cnt = 0;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"    }",
			"    ",
			"    void dfs(int x) {",
			"        dfn[x] = low[x] = cur++;",
			"        stk.push_back(x);",
			"        ",
			"        for (auto y : adj[x]) {",
			"            if (dfn[y] == -1) {",
			"                dfs(y);",
			"                low[x] = std::min(low[x], low[y]);",
			"            } else if (bel[y] == -1) {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"        ",
			"        if (dfn[x] == low[x]) {",
			"            int y;",
			"            do {",
			"                y = stk.back();",
			"                bel[y] = cnt;",
			"                stk.pop_back();",
			"            } while (y != x);",
			"            cnt++;",
			"        }",
			"    }",
			"    ",
			"    std::vector<int> work() {",
			"        for (int i = 0; i < n; i++) {",
			"            if (dfn[i] == -1) {",
			"                dfs(i);",
			"            }",
			"        }",
			"        return bel;",
			"    }",
			"};"
		],
		"description": "SCC"
	},
	"template 8": {
		"prefix": "bellmanford",
		"body": [
			"// Problem Statement: Given a weighted, directed and connected graph ",
			"// of V vertices and E edges, Find the shortest distance of all the ",
			"// vertices from the source vertex S for negative edges.",
			"class Solution {",
			"public:",
			"    /*  Function to implement Bellman Ford",
			"    *   edges: vector of vectors which represents the graph",
			"    *   S: source vertex to start traversing graph with",
			"    *   V: number of vertices",
			"    */",
			"    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {",
			"        vector<int > dist(V + 1 , 1e8) ; // when the vertices are starting from 1 (V + 1) else (V)",
			"        dist[S] = 0 ;",
			"        for (int i = 0 ; i < V ; ++i) { // when the vertices are starting from 1 (V) else (V - 1)",
			"            for (auto it : edges) {",
			"                int u = it[0] ;",
			"                int v = it[1] ;",
			"                int wt = it[2] ;",
			"                if (dist[u] + wt < dist[v]){ // will not be using dist[u] != 1e8 it showed wrong answer on coding ninjas",
			"                    dist[v] = dist[u] + wt ;",
			"                }",
			"            }",
			"        }",
			"        // Nth relaxation to check negative cycle // only when it is not mentioned that it will form a cycle",
			"        for (auto it : edges) {",
			"            int u = it[0] ;",
			"            int v = it[1] ;",
			"            int wt = it[2] ;",
			"            if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {",
			"                return {-1} ;",
			"            }",
			"        }",
			"",
			"        return dist ;",
			"    }",
			"};"
		],
		"description": "template 8"
	},
	"template 9": {
		"prefix": "floydwarshall",
		"body": [
			"// Problem Statement: The problem is to find the shortest distances between every pair of vertices in a given edge-weighted directed graph. The graph is represented as an adjacency matrix of size n*n. Matrix[i][j] denotes the weight of the edge from i to j. If Matrix[i][j]=-1, it means there is no edge from i to j.",
			"class Solution {",
			"public:",
			"    void shortest_distance(vector<vector<int>>&matrix) {",
			"        int n = matrix.size();",
			"        vector<vector<long long > > matrix(n + 1 , vector<long long > (n + 1 , -1)) ; // required when dirently using in the main function",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0 ; j < n ; ++j){",
			"                if (matrix[i][j] == -1){",
			"                    matrix[i][j] = 1e9 ;",
			"                }",
			"                if (i == j) matrix[i][j] = 0 ;",
			"            }",
			"        }",
			"",
			"        for (int k = 0 ; k < n ; ++k){",
			"            for (int i = 0 ; i < n ; ++i){",
			"                for (int j = 0 ; j < n ; ++j){",
			"                    if(matrix[i][k] != 1e9 and matrix[k][j] != 1e9){ // important giving wrong answer on coding ninjas",
			"                        matrix[i][j] = min(matrix[i][j] , matrix[i][k] + matrix[k][j]) ;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        // required according to the problem statement ",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < n; j++) {",
			"                if (matrix[i][j] == 1e9) {",
			"                    matrix[i][j] = -1;",
			"                }",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "template 9"
	},
	"prims": {
		"prefix": "prim'salgorithm",
		"body": [
			"// Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.(A Minimum Spanning Tree (MST) is a subset of edges of a connected weighted undirected graph that connects all the vertices together with the minimum possible total edge weight.)",
			"// (Sometimes it may be asked to find the MST as well, where in the MST the edge-informations will be stored in the form {u, v}(u = starting node, v = ending node).)",
			"#include <bits/stdc++.h>",
			"using namespace std ;",
			"",
			"class Solution {",
			"public:",
			"    // Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[]) {",
			"        priority_queue<pair<int, int > , vector<pair<int, int > > , greater<pair<int, int > > > pq ;",
			"",
			"        vector<int> vis(V , 0) ;",
			"",
			"        // {wt, node}",
			"        pq.push({0 , 0}) ;",
			"        int sum = 0 ;",
			"        while(!pq.empty()) {",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int wt = it.first ;",
			"",
			"            if (vis[node] == 1) continue ;",
			"            vis[node] = 1 ;",
			"            sum += wt ;",
			"",
			"            for (auto it : adj[node]) {",
			"                int adjNode = it[0] ;",
			"                int edW = it[1] ;",
			"                if(!vis[adjNode]) {",
			"                    pq.push({edW , adjNode}) ;",
			"                }",
			"            }",
			"        }",
			"",
			"        return sum ;",
			"    }",
			"};",
			"",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int > > adj[V] ;",
			"    for (auto it : edges) {",
			"        vector<int> tmp(2) ;",
			"        tmp[0] = it[1] ;",
			"        tmp[1] = it[2] ;",
			"        adj[it[0]].push_back(tmp) ;",
			"",
			"        tmp[0] = it[0] ;",
			"        tmp[1] = it[2] ;",
			"        adj[it[1]].push_back(tmp) ;",
			"    }",
			"",
			"    Solution obj ; // creating an instance(object) of the Solution class. ",
			"    // By creating an object of the class you can access its methods and attributes",
			"    int sum = obj.spanningTree(V , adj) ;",
			"    cout << \"The sum of all the edge weights: \" << sum << endl;",
			"",
			"    return 0;",
			"}"
		],
		"description": "prims"
	},
	"kruskal": {
		"prefix": "kruskal'salgorithm",
		"body": [
			"// Problem Statement: Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"struct DSU {",
			"    int S ; ",
			"    struct node {",
			"        int p; int siz; int rnk;",
			"    };",
			"    vector<node > dsu ; ",
			"",
			"    DSU(int n) { ",
			"        S = n ; ",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            node tmp ; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp) ; ",
			"        }",
			"    }",
			"",
			"    void reset(int n) {",
			"        dsu.clear() ; ",
			"        S = n ; ",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            node tmp ; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp) ; ",
			"        }",
			"    }",
			"",
			"    int parent(int u) {",
			"        if(dsu[u].p == u) return u;",
			"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
			"        return dsu[u].p ; ",
			"    }",
			"",
			"    void mergebysize(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return ;",
			"        if(dsu[u].siz < dsu[v].siz) swap(u , v) ; ",
			"        dsu[v].p = u ; ",
			"        dsu[u].siz += dsu[v].siz ; ",
			"    }",
			"",
			"    void mergebyrank(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return ;",
			"        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v ;",
			"        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u ;",
			"        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1 ; ",
			"    }",
			"",
			"    bool same(int u, int v) {",
			"        if(parent(u) == parent(v)) return true ; ",
			"        return false ; ",
			"    }",
			"",
			"    int get_size(int u) {",
			"        return dsu[parent(u)].siz ; ",
			"    }",
			"};",
			"",
			"struct edge {",
			"    int u ;",
			"    int v ;",
			"    int weight ;",
			"};",
			"",
			"class Solution {",
			"public:",
			"    //Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[]) { // spanningTree is a method of the class Solution",
			"",
			"        vector<edge> edges;",
			"        for (int i = 0; i < V; i++) {",
			"            for (auto it : adj[i]) {",
			"                int adjNode = it[0];",
			"                int wt = it[1];",
			"                int node = i;",
			"",
			"                edge e ; // Create an instance of the edge struct",
			"                e.u = node ;",
			"                e.v = adjNode ;",
			"                e.weight = wt ;",
			"                edges.push_back(e) ; // Add the edge to the edges vector",
			"            }",
			"        }",
			"        DSU dsu(V) ;",
			"        sort(edges.begin(), edges.end()); ",
			"        int mstWt = 0;",
			"        // time complexity o(no. of Edges * 4 * aplha * 2) ",
			"        for (auto &[src , dest , weight] : edges) { // it will work on codeforces but won't work on many platforms",
			"            int wt = weight ;",
			"            int u = src ;",
			"            int v = dest ;",
			"",
			"            if (dsu.parent(u) != dsu.parent(v)) {",
			"                mstWt += wt;",
			"                dsu.mergebysize(u, v);",
			"            }",
			"        }",
			"",
			"        return mstWt;",
			"    }",
			"};",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int > > adj[V] ;",
			"    for (auto &it : edges) {",
			"        vector<int> tmp(2);",
			"        tmp[0] = it[1];",
			"        tmp[1] = it[2];",
			"        adj[it[0]].push_back(tmp);",
			"",
			"        tmp[0] = it[0];",
			"        tmp[1] = it[2];",
			"        adj[it[1]].push_back(tmp);",
			"    }",
			"",
			"    Solution obj ; // creating an instance(object) of the Solution class. ",
			"    // By creating an object of the class you can access its methods and attributes",
			"    int mstWt = obj.spanningTree(V , adj) ;",
			"    cout << \"The sum of all the edge weights: \" << mstWt << endl ;",
			"    return 0 ;",
			"}"
		],
		"description": "kruskal"
	},
	"binary lifting and lca": {
		"prefix": "binary lifting and lca",
		"body": [
			"/*",
			"",
			"Sparse Table: Binary lifting can be seen as a type of sparse table data structure that is customized for trees. It precomputes and stores information about the ancestors of each node, allowing for quick LCA queries.",
			"Binary lifting is primarily used for finding the lowest common ancestor (LCA) of two nodes in a tree",
			"this technique itself is applicable to both rooted and unrooted trees not for graphs.",
			"Preprocessing: In binary lifting, you typically preprocess the tree to create a data structure that helps answer LCA queries efficiently. This data structure often involves storing the ancestors of each node at various power-of-2 levels in the tree.",
			"Time = O(logn) for each query",
			"",
			"*/",
			"struct BinaryLifting {",
			"    int n ;",
			"    int maxLog ;",
			"    int maxRequirement ;",
			"    vector<vector<int > > parent ;",
			"    vector<int > logValues ;",
			"    bool precomputedLogs = false ;",
			"    // vector<int> *edges ----> meaning ----> // Declaring a pointer to a vector of integers",
			"    BinaryLifting(int n1 , vector<vector<int > > &edges , int requirement , int root) { // requirement is 1e9 ",
			"        n = n1 ;",
			"        parent.resize(n) ;",
			"        maxLog = log2(requirement + 1) ;",
			"        maxRequirement = requirement ;",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            parent[i].resize(maxLog + 1) ;",
			"            for (int j = 0; j <= maxLog; ++j) {",
			"                parent[i][j] = -1 ;",
			"            }",
			"        }",
			"        fillParentTable(root , edges) ;",
			"        if (maxRequirement <= 1000000LL){ // 1e6",
			"            precomputeLogs() ;",
			"        }",
			"    }",
			"    void fillParentTable(int root , vector<vector<int > > &edges) {",
			"        vector<bool > visited(n) ;",
			"        dfsBinaryLifting(root, edges, visited) ;",
			"        int intermediate = -1 ;",
			"        for (int i = 1; i <= maxLog; ++i) {",
			"            for (int j = 0; j < n; ++j) {",
			"                intermediate = parent[j][i - 1] ;",
			"                if (intermediate != -1) {",
			"                    parent[j][i] = parent[intermediate][i - 1] ;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfsBinaryLifting(int root , vector<vector<int > > &edges , vector<bool > &visited) {",
			"        visited[root] = true ;",
			"        for (auto &i : edges[root]) {",
			"            if (!visited[i]) {",
			"                parent[i][0] = root ;",
			"                dfsBinaryLifting(i , edges , visited) ;",
			"            }",
			"        }",
			"    }",
			"    void precomputeLogs() {",
			"        precomputedLogs = true ;",
			"        logValues.resize(maxRequirement + 1) ;",
			"        logValues[1] = 0 ;",
			"        for (int i = 2 ; i <= maxRequirement ; ++i) {",
			"            logValues[i] = logValues[i / 2] + 1 ;",
			"        }",
			"    }",
			"    int kthParent(int start, int k) { // k can be upto 1e9, In this we have only one node and we have to calculate its parent by traversing in powers of 2 ",
			"        int a = start ;",
			"        while (k > 0) {",
			"            int x = getLog(k) ;",
			"            a = parent[a][x] ;",
			"            if (a == -1){",
			"                return a ;",
			"            }",
			"            k -= (1 << x) ;",
			"        }",
			"        return a ; ",
			"    }",
			"    inline int getLog(int x) {",
			"        return precomputedLogs ? logValues[x] : log2(x) ;",
			"    }",
			"};",
			"",
			"struct LCA { // Lowest Common Ancestor ",
			"    int n ; // number of nodes",
			"    vector<int > level ; // level of each node",
			"    LCA(int n1 , vector<vector<int > > &edges , int root) { // edges is the adjacency list of the tree",
			"        n = n1 ; // number of nodes",
			"        level.resize(n) ; // level of each node",
			"        dfsLCA(root, edges, -1) ; // -1 is the parent of root",
			"    }",
			"    void dfsLCA(int root , vector<vector<int > > &edges , int parent) { ",
			"        for (auto &i : edges[root]) { // ",
			"            if (i != parent) {",
			"                level[i] = level[root] + 1 ;",
			"                dfsLCA(i, edges, root) ;",
			"            }",
			"        }",
			"    }",
			"    int getLCA(int a , int b , BinaryLifting &bl_object) { // bl_object is the object of BinaryLifting class",
			"        if (level[a] > level[b]) {",
			"            swap(a , b) ;",
			"        }",
			"        b = bl_object.kthParent(b , level[b] - level[a]) ; // kth parent of b at level (level[b] - level[a])",
			"        if (a == b) {",
			"            return a ; ",
			"        }"
			"        for (int i = bl_object.maxLog ; i >= 0 ; --i) {",
			"            int parent1 = bl_object.parent[a][i] ; ",
			"            int parent2 = bl_object.parent[b][i] ; ",
			"            if (parent2 != parent1 && parent1 != -1 && parent2 != -1) {",
			"                a = parent1 ; ",
			"                b = parent2 ; ",
			"            }",
			"        }",
			"        return bl_object.parent[a][0] ; ",
			"    }",
			"};"
		],
		"description": "binary lifting and lca"
	},
	"lca only": {
		"prefix": "lca only",
		"body": [
			"/*",
			"",
			"   vector<vector<int > > bin(n + 1 , vector<int >(21 , 0));",
			"   vector<int> tin(n + 1) , tout(n + 1);",
			"   auto is_ancestor = [&](int u , int v)",
			"   {",
			"      if(tin[u] <= tin[v] && tout[u] >= tout[v])",
			"         return true ;",
			"      return false ;",
			"   };",
			"   auto LCA=[&](int u , int v)",
			"   {",
			"      if(is_ancestor(u , v))",
			"         return u ;",
			"      if(is_ancestor(v , u))",
			"         return v ;",
			"      int node = u ;",
			"      for(int i = 20 ; i >= 0 ; --i) ",
			"      {",
			"         if(!is_ancestor(bin[node][i] , v)) ",
			"          node = bin[node][i] ; ",
			"      }",
			"      return bin[node][0] ; ",
			"   };",
			"",
			"*/"
		],
		"description": "lca only"
	},
	"SCC": {
		"prefix": "Strongly Connected Component",
		"body": [
			"struct SCC { // only valid for directed graph // scc_using_kosaraju_algorithm_not_using_tarjan_algorithm ",
			"    vector<vector<int > > edges , redges ;",
			"    vector<bool > used ;",
			"    vector<int > order , component ;",
			"    int n ;",
			"",
			"    void init(int _n) {",
			"        n = _n ;",
			"        edges = vector<vector<int > > (n) ;",
			"        redges = vector<vector<int > > (n) ;",
			"        order.clear() ;",
			"        component.clear() ;",
			"    }",
			"",
			"    void edge(int u , int v) {",
			"        edges[u].push_back(v) ;",
			"        redges[v].push_back(u) ;",
			"    }",
			"",
			"    void dfs1(int v) {",
			"        used[v] = true ;",
			"        for (int i = 0 ; i < edges[v].size() ; ++i) {",
			"            if (!used[edges[v][i]]) {",
			"                dfs1(edges[v][i]) ;",
			"            }",
			"        }",
			"        order.push_back(v) ; // time of exit from the node matters (starting time and finishing time) ",
			"    }",
			"",
			"    void dfs2(int v) {",
			"        used[v] = true ;",
			"        component.push_back(v) ;",
			"        for (int i = 0 ; i < redges[v].size() ; ++i) {",
			"            if (!used[redges[v][i]]) {",
			"                dfs2(redges[v][i]) ;",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<vector<int > > run() {",
			"        vector<vector<int > > components ;",
			"        used.assign(n , false) ;",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            if (!used[i]) {",
			"                dfs1(i) ;",
			"            }",
			"        }",
			"",
			"        used.assign(n , false);",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            int v = order[n - 1 - i] ;",
			"            if (!used[v]) {",
			"                dfs2(v) ;",
			"                components.push_back(component) ;",
			"                component.clear() ;",
			"            }",
			"        }",
			"",
			"        return components ;",
			"    }",
			"};"
		],
		"description": "SCC"
	},
	"block cut tree": {
		"prefix": "block cut tree",
		"body": [
			"struct BlockCutTree {",
			"    int n ;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int > dfn , low , stk ;",
			"    int cnt , cur ;",
			"    std::vector<std::pair<int, int > > edges ;",
			"    ",
			"    BlockCutTree() {}",
			"    BlockCutTree(int n) {",
			"        init(n) ;",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n ;",
			"        adj.assign(n , {}) ;",
			"        dfn.assign(n , -1) ;",
			"        low.resize(n) ;",
			"        stk.clear() ;",
			"        cnt = cur = 0 ;",
			"        edges.clear() ;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v) ;",
			"        adj[v].push_back(u) ;",
			"    }",
			"    ",
			"    void dfs(int x) {",
			"        stk.push_back(x);",
			"        dfn[x] = low[x] = cur++;",
			"        ",
			"        for (auto &y : adj[x]) {",
			"            if (dfn[y] == -1) {",
			"                dfs(y);",
			"                low[x] = std::min(low[x], low[y]) ;",
			"                if (low[y] == dfn[x]) {",
			"                    int v ;",
			"                    do {",
			"                        v = stk.back() ;",
			"                        stk.pop_back() ;",
			"                        edges.emplace_back(n + cnt, v) ;",
			"                    } while (v != y) ;",
			"                    edges.emplace_back(x, n + cnt) ;",
			"                    cnt++;",
			"                }",
			"            } else {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    std::pair<int, std::vector<std::pair<int, int > > > work() {",
			"        for (int i = 0; i < n; i++) {",
			"            if (dfn[i] == -1) {",
			"                stk.clear() ;",
			"                dfs(i) ;",
			"            }",
			"        }",
			"        return {cnt, edges} ;",
			"    }",
			"};"
		],
		"description": "block cut tree"
	},
	"heavy light decomposition": {
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"    int n;",
			"    std::vector<int> siz, top, dep, parent, in, out, seq;",
			"    std::vector<std::vector<int>> adj;",
			"    int cur;",
			"    ",
			"    HLD() {}",
			"    HLD(int n) {",
			"        init(n);",
			"    }",
			"    void init(int n) {",
			"        this->n = n;",
			"        siz.resize(n);",
			"        top.resize(n);",
			"        dep.resize(n);",
			"        parent.resize(n);",
			"        in.resize(n);",
			"        out.resize(n);",
			"        seq.resize(n);",
			"        cur = 0;",
			"        adj.assign(n, {});",
			"    }",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"    }",
			"    void work(int root = 0) {",
			"        top[root] = root;",
			"        dep[root] = 0;",
			"        parent[root] = -1;",
			"        dfs1(root);",
			"        dfs2(root);",
			"    }",
			"    void dfs1(int u) {",
			"        if (parent[u] != -1) {",
			"            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));",
			"        }",
			"        ",
			"        siz[u] = 1;",
			"        for (auto &v : adj[u]) {",
			"            parent[v] = u;",
			"            dep[v] = dep[u] + 1;",
			"            dfs1(v);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[adj[u][0]]) {",
			"                std::swap(v, adj[u][0]);",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u) {",
			"        in[u] = cur++;",
			"        seq[in[u]] = u;",
			"        for (auto v : adj[u]) {",
			"            top[v] = v == adj[u][0] ? top[u] : v;",
			"            dfs2(v);",
			"        }",
			"        out[u] = cur;",
			"    }",
			"    int lca(int u, int v) {",
			"        while (top[u] != top[v]) {",
			"            if (dep[top[u]] > dep[top[v]]) {",
			"                u = parent[top[u]];",
			"            } else {",
			"                v = parent[top[v]];",
			"            }",
			"        }",
			"        return dep[u] < dep[v] ? u : v;",
			"    }",
			"    ",
			"    int dist(int u, int v) {",
			"        return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
			"    }",
			"    ",
			"    int jump(int u, int k) {",
			"        if (dep[u] < k) {",
			"            return -1;",
			"        }",
			"        ",
			"        int d = dep[u] - k;",
			"        ",
			"        while (dep[top[u]] > d) {",
			"            u = parent[top[u]];",
			"        }",
			"        ",
			"        return seq[in[u] - dep[u] + d];",
			"    }",
			"    ",
			"    bool isAncester(int u, int v) {",
			"        return in[u] <= in[v] && in[v] < out[u];",
			"    }",
			"    ",
			"    int rootedParent(int u, int v) {",
			"        std::swap(u, v);",
			"        if (u == v) {",
			"            return u;",
			"        }",
			"        if (!isAncester(u, v)) {",
			"            return parent[u];",
			"        }",
			"        auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {",
			"            return in[x] < in[y];",
			"        }) - 1;",
			"        return *it;",
			"    }",
			"    ",
			"    int rootedSize(int u, int v) {",
			"        if (u == v) {",
			"            return n;",
			"        }",
			"        if (!isAncester(v, u)) {",
			"            return siz[v];",
			"        }",
			"        return n - siz[rootedParent(u, v)];",
			"    }",
			"    ",
			"    int rootedLca(int a, int b, int c) {",
			"        return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
			"    }",
			"};"
		],
		"description": "heavy light decomposition"
	},
	"dinic": {
		"prefix": "dinic",
		"body": [
			"template <typename F>",
			"struct Dinic {",
			"    struct edge {",
			"        int to;",
			"        F cap;",
			"        int rev;",
			"        edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev) {}",
			"    };",
			"",
			"    vector<vector<edge>> es;",
			"    vector<int> d, pos;",
			"    const F zero_F, INF_F;",
			"    const int n;",
			"",
			"    Dinic(int n, F zero_F = 0, F INF_F = numeric_limits<F>::max() / 2) : es(n), d(n), pos(n), zero_F(zero_F), INF_F(INF_F), n(n) {}",
			"",
			"    void add_edge(int from, int to, F cap, bool directed = true) {",
			"        es[from].emplace_back(to, cap, (int)es[to].size());",
			"        es[to].emplace_back(from, directed ? zero_F : cap, (int)es[from].size() - 1);",
			"    }",
			"",
			"    bool _bfs(int s, int t) {",
			"        fill(begin(d), end(d), -1);",
			"        queue<int> que;",
			"        d[s] = 0;",
			"        que.push(s);",
			"        while (!que.empty()) {",
			"            int i = que.front();",
			"            que.pop();",
			"            for (auto &e : es[i]) {",
			"                if (e.cap > zero_F && d[e.to] == -1) {",
			"                    d[e.to] = d[i] + 1;",
			"                    que.push(e.to);",
			"                }",
			"            }",
			"        }",
			"        return d[t] != -1;",
			"    }",
			"",
			"    F _dfs(int now, int t, F flow) {",
			"        if (now == t) return flow;",
			"        for (int &i = pos[now]; i < (int)es[now].size(); i++) {",
			"            edge &e = es[now][i];",
			"            if (e.cap > zero_F && d[e.to] > d[now]) {",
			"                F f = _dfs(e.to, t, min(flow, e.cap));",
			"                if (f > zero_F) {",
			"                    e.cap -= f;",
			"                    es[e.to][e.rev].cap += f;",
			"                    return f;",
			"                }",
			"            }",
			"        }",
			"        return zero_F;",
			"    }",
			"",
			"    // 操作後の d 配列は最小カットの 1 つを表す (0 以上なら s 側、-1 なら t 側)",
			"    F max_flow(int s, int t) {",
			"        F flow = zero_F;",
			"        while (_bfs(s, t)) {",
			"            fill(begin(pos), end(pos), 0);",
			"            F f = zero_F;",
			"            while ((f = _dfs(s, t, INF_F)) > zero_F) flow += f;",
			"        }",
			"        return flow;",
			"    }",
			"};",
			"",
			"struct edge {",
			"    int to, cap, flow;",
			"    edge* inv;",
			"    edge(int to1, int cap1) : to(to1), cap(cap1), flow(0), inv(nullptr) {}",
			"    int spare() {",
			"        return cap - flow;",
			"    }",
			"    void add(int f) {",
			"        flow += f;",
			"        inv->flow -= f;",
			"    }",
			"};",
			" ",
			"struct dinic{",
			"    int size, s, e;",
			"    vi level, work;",
			"    vector<vector<edge*>> adj;",
			"    void init(int n){",
			"        size = n;",
			"        s = n - 2;",
			"        e = n - 1;",
			"        adj.resize(n);",
			"    }",
			"    void add(int u, int v, int w){",
			"        edge* e1 = new edge(v, w);",
			"        edge* e2 = new edge(u, 0);",
			"        e1 -> inv = e2; e2 -> inv = e1;",
			"        adj[u].push_back(e1);",
			"        adj[v].push_back(e2);        ",
			"    }",
			"    void sadd(int u, int w){",
			"        add(s, u, w);",
			"    }",
			"    void eadd(int u, int w){",
			"        add(u, e, w);",
			"    }",
			"    bool make_level(void){",
			"        level.clear(); level.resize(size, -1);",
			"        work.clear(); work.resize(size);",
			"        level[s] = 0;",
			"        queue<int> q; q.push(s);",
			"        while(!q.empty()){",
			"            int cur = q.front(); q.pop();",
			"            for(edge* e : adj[cur]){",
			"                if(level[e->to] == -1 && e->spare()){",
			"                    level[e->to] = level[cur] + 1;",
			"                    q.push(e->to);",
			"                }",
			"            }",
			"        }",
			"        if(level[e] == -1) return false;",
			"        else return true;",
			"    }",
			"    int dfs(int cur, int f){",
			"        if(cur == e) return f;",
			"        for(int& i = work[cur]; i < adj[cur].size(); i++){",
			"            int nxt = adj[cur][i] -> to;",
			"            if(level[nxt] == level[cur] + 1 && adj[cur][i] -> spare()){",
			"                int ff = dfs(nxt, min(f, adj[cur][i] -> spare()));",
			"                if(ff){",
			"                    adj[cur][i]->add(ff);",
			"                    return ff;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    int operate(void){",
			"        int total = 0;",
			"        while(make_level()){",
			"            while(1){",
			"                int curflow = dfs(s, 1e18);",
			"                if(!curflow) break;",
			"                total += curflow;",
			"            }",
			"        }",
			"        return total;",
			"    }",
			"}G;"
		],
		"description": "dinic"
	},
	"Tarjan": {
		"prefix": "tarjan",
		"body": [
			"struct Tarjan {",
			"    int n,dn,rt;",
			"    vector<vector<int>> g;",
			"    vector<vector<int>> vcc;",
			"    vector<int> dfn,low,cut;",
			"    stack<int> st;",
			"    Tarjan(int n):n(n),dn(0),g(n),dfn(n),low(n),cut(n) {}",
			"    void addEdge(int u,int v) {",
			"        g[u].emplace_back(v);",
			"        g[v].emplace_back(u);",
			"    }",
			"    void tarjan(int u) {",
			"        dfn[u]=low[u]=++dn;",
			"        st.push(u);",
			"        int chd=0;",
			"        for(int v:g[u]) {",
			"            if(!dfn[v]) {",
			"                tarjan(v);",
			"                low[u]=min(low[u], low[v]);",
			"                if(dfn[u]<=low[v]) {",
			"                    if(u!=rt||++chd>1) cut[u]=1;// 割点",
			"                    vcc.push_back({u});",
			"                    for (int x=-1; x!=v; st.pop())",
			"                        vcc.back().push_back(x=st.top());",
			"                }",
			"            }else {// 返祖边",
			"                // 求vcc判不判回头边无所谓",
			"                low[u]=min(low[u], dfn[v]);",
			"            }",
			"        }",
			"        if(u==rt&&chd==0)// 孤点",
			"            vcc.push_back({u});",
			"    }",
			"    void converge() {",
			"        for(rt=0; rt<n; ++rt) ",
			"            if(!dfn[rt]) tarjan(rt);",
			"    }",
			"    // 圆方树/森林",
			"    auto newTree() {",
			"        vector<vector<int>> tr(n+vcc.size());",
			"        for(int i=0; i<vcc.size(); ++i)",
			"            for(int x:vcc[i]) {",
			"                tr[n+i].push_back(x);// 方点向圆点连边",
			"                tr[x].push_back(n+i);",
			"            }",
			"        return tr;",
			"    }",
			"};"
		],
		"description": "Tarjan"
	},
	"Biconnected component": {
		"prefix": "biconnected component",
		"body": [
			"struct biconnected_components{",
			"	int n, attempt = 0;",
			"	biconnected_components(int n): n(n), pos(n), was(n, -1){ }",
			"	vector<int> pos, stack, was;",
			"	// O(n + m) where n and m are the number of reachable nodes and edges respectively.",
			"	// Requires graph",
			"	template<class T>",
			"	void run(const graph<T> &g, const vector<int> &init, auto act_comp, auto act_bridge){",
			"		assert(n == g.n);",
			"		int it = 0;",
			"		auto dfs = [&](auto self, int u, int pe)->int{",
			"			int top = pos[u] = ++ it;",
			"			was[u] = attempt;",
			"			for(auto id: g.adj[u]){",
			"				if(g.ignore && g.ignore(id) || id == pe) continue;",
			"				int v = u ^ g.edge[id].from ^ g.edge[id].to;",
			"				if(was[v] != attempt){",
			"					was[v] = attempt;",
			"					pos[v] = 0;",
			"				}",
			"				if(pos[v]){",
			"					top = min(top, pos[v]);",
			"					if(pos[v] < pos[u]) stack.push_back(id);",
			"				}",
			"				else{",
			"					int sz = (int)stack.size(), up = self(self, v, id);",
			"					top = min(top, up);",
			"					if(up == pos[u]){",
			"						stack.push_back(id);",
			"						act_comp(vector<int>{stack.begin() + sz, stack.end()});",
			"						stack.resize(sz);",
			"					}",
			"					else if(up < pos[u]) stack.push_back(id);",
			"					else act_bridge(id);",
			"				}",
			"			}",
			"			return top;",
			"		};",
			"		for(auto u: init) if(was[u] != attempt) dfs(dfs, u, -1);",
			"		++ attempt;",
			"	}",
			"	template<class T>",
			"	void run_all(const graph<T> &g, auto act_comp, auto act_bridge){",
			"		assert(n == g.n);",
			"		vector<int> init(n);",
			"		iota(init.begin(), init.end(), 0);",
			"		run(g, init, act_comp, act_bridge);",
			"	}",
			"};"
		],
		"description": "Biconnected component"
	},
	"bitwise": {
		"prefix": "bitwise_TRIE",
		"body": [
			"class Trie {",
			"public:",
			"    struct BITS_TRIE {",
			"        private:",
			"        struct node {",
			"            int start = 0 ;",
			"            int end = 0 ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            node* next[2] ;",
			"            node() {",
			"                next[1] = next[0] = NULL ;",
			"            }",
			"        };",
			"",
			"        node root ;",
			"",
			"        public:",
			"        void insert(int val) {",
			"            node* temp = &root;",
			"            temp->cnt++ ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                if(temp->next[bit] == NULL) {",
			"                    temp->next[bit] = new node() ;",
			"                }",
			"",
			"                temp = temp->next[bit] ;",
			"                temp->cnt++ ;",
			"            }",
			"        }",
			"",
			"        int max_xor(int val) {",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = 1 - bit ;",
			"",
			"                if(temp->next[req] == NULL) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else {",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"",
			"        int min_xor(int val){",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i){",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0){",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = bit ;",
			"",
			"                if(temp->next[req] == NULL){",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0){",
			"                    ans += (1 << i) ;",
			"                    temp=temp->next[1 - req] ;",
			"                }",
			"                else{",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"    };",
			"};"
		],
		"description": "bitwise"
	},
	"stringwise_trie": {
		"prefix": "stringwise_trie",
		"body": [
			"class Trie {",
			"public:",
			"    struct STRING_TRIE {",
			"        private:",
			"        struct Node {",
			"            Node* next[26] ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            int cntEndWith = 0 ;",
			"            int cntPrefix = 0 ;  ",
			"",
			"            bool containsKey(char ch) {",
			"                return (next[ch - 'a'] != nullptr) ; ",
			"            }",
			"            Node* get(char ch) {",
			"                return next[ch - 'a'] ; ",
			"            }",
			"            void put(char ch, Node* node) {",
			"                next[ch - 'a'] = node ; ",
			"            }",
			"            void setEnd() { // comes to the end of the word after inserting set its refernce trie block to true",
			"                flag = true ; ",
			"            }",
			"            bool isEnd() { // check prefix ",
			"                return flag ; ",
			"            }",
			"            void increaseEnd() {",
			"                cntEndWith++ ;  ",
			"            }",
			"            void increasePrefix() {",
			"                cntPrefix++ ; ",
			"            }",
			"            void deleteEnd() {",
			"                cntEndWith-- ; ",
			"            }",
			"            void reducePrefix() {",
			"                cntPrefix-- ; ",
			"            }",
			"            int getEnd() {",
			"                return cntEndWith ; ",
			"            }",
			"            int getPrefix() {",
			"                return cntPrefix ; ",
			"            }",
			"        };",
			"",
			"        Node *root ;",
			"",
			"        public:",
			"        /** Inserts a word into the trie. */",
			"        void insert(string word) {",
			"            Node *node = root ;",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    node->put(word[i] , new Node()) ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"                node->increasePrefix();  // Increment prefix count for each character ",
			"            }",
			"            node->setEnd() ; ",
			"            node->increaseEnd();  // Increment end count for the last character",
			"        }",
			"",
			"        /** Returns if the word is in the trie. */",
			"        bool search(string word) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"            }",
			"            if(node->isEnd()) {",
			"                return true ; ",
			"            }",
			"            return false ; ",
			"        }",
			"",
			"        /** Returns if there is any word in the trie that starts with the given prefix. */",
			"        bool startsWith(string prefix) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < prefix.size() ; ++i) {",
			"                if(!node->containsKey(prefix[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(prefix[i]) ; ",
			"            }",
			"            return true ; ",
			"        }",
			"",
			"        /** Returns inumber of words equal to given word */",
			"        int countWordsEqualTo(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getEnd() ; ",
			"        }",
			"",
			"        /** ... */",
			"        int countWordsStartingWith(string &word){",
			"            Node* node = root;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getPrefix() ; ",
			"        }",
			"",
			"        /** Actually it do not remove the blocks but it decreases the count of that word */",
			"        void erase(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                    node->reducePrefix() ;  // Decrease prefix count for each character",
			"                }",
			"                else {",
			"                    return ;",
			"                }",
			"            }",
			"            node->deleteEnd() ;  // Decrease end count for the last character",
			"        }",
			"",
			"        /** ... */",
			"        bool checkIfAllPrefixExists(string word) {",
			"            Node *node = root;",
			"            bool flag = true; ",
			"            for(int i = 0;i<word.size();i++) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]); ",
			"                    flag = flag & node->isEnd(); ",
			"                }",
			"                else {",
			"                    return false; ",
			"                } ",
			"            }",
			"            return flag; ",
			"        }",
			"",
			"        /** ... */",
			"        string completeString(int n, vector<string> &a){",
			"            Node *node = root;",
			"            for(auto word : a) insert(word); ",
			"            string longest = \"\"; ",
			"            for(auto &word: a) {",
			"                if(checkIfAllPrefixExists(word)) {",
			"                    if(word.size() > longest.size()) {",
			"                        longest = word; ",
			"                    }",
			"                    else if(word.size() == longest.size() && word < longest) {",
			"                        longest = word; ",
			"                    }",
			"                }",
			"            }",
			"            if(longest == \"\") return \"None\"; ",
			"            return longest; ",
			"        }",
			"",
			"        /** ... */",
			"        int countDistinctSubstrings(string &s) {",
			"            Node* node = root;",
			"            int cnt = 0; ",
			"            int n = s.size(); ",
			"            for(int i = 0 ; i < n ; ++i)",
			"            {",
			"                Node* node = root; ",
			"                for(int j = i ; j < n ; ++j) {",
			"                    if(!node->containsKey(s[j])) {",
			"                        node->put(s[j], new Node()) ;  ",
			"                        cnt++ ; ",
			"                    }",
			"                    node = node->get(s[j]) ; ",
			"                }",
			"            }",
			"            return cnt + 1 ; //    Write your code here.",
			"        }",
			"",
			"    };",
			"};",
			"",
			"/*",
			"",
			"So, how to declare Trie in this case.",
			"",
			"Trie::STRING_TRIE trie ;",
			"trie.insert(\"apple\"); , trie.search(\"apple\"); , trie.countWordsEqualTo(\"app\"); , trie.erase(\"app\");",
			"",
			"*/"
		],
		"description": "stringwise_trie"
	},
	"convexhullgrahamscan": {
		"prefix": "convexhull",
		"body": [
			"void cc(vector<pair<ll, ll>>& points) {",
			" ",
			"    auto ccw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) > 0;",
			"    };",
			"    auto cw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) < 0;",
			"    };",
			" ",
			"    auto cmp = [](pair<ll, ll>& p, pair<ll, ll>& pp) {",
			"        if (p.first == pp.first) return p.second < pp.second;",
			"        return p.first < pp.first;",
			"    };",
			" ",
			"    sort(all(points), cmp); ll n = points.size();",
			"    pair<ll, ll>a = points[0], c = points[n - 1];",
			"    vector<pair<ll, ll>>up, down;",
			"    up.push_back(a); down.push_back(a);",
			"    for (ll i = 1; i < points.size(); i++) {",
			"        if (i == n - 1 || !ccw(a, points[i], c)) {",
			"            // upper half and colinear",
			"            while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], points[i])) {",
			"                up.pop_back();",
			"            }",
			"            up.push_back(points[i]);",
			"        }",
			"        if (i == n - 1 || !cw(a, points[i], c)) {",
			"            //lower Half and colinear",
			"            while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], points[i])) {",
			"                down.pop_back();",
			"            }",
			"            down.push_back(points[i]);",
			"        }",
			"    }",
			"    points.clear();",
			"    for (size_t i = 0; i < up.size(); i++)  points.push_back(up[i]);",
			"    for (size_t i = 0; i < down.size(); i++) points.push_back(down[i]);",
			" ",
			"    // Points vector has duplicate values also ",
			"    // as which belongs both upper half and lower half",
			"    // https://codeforces.com/contest/1858/submission/218957587",
			" ",
			"}"
		],
		"description": "convexhullgrahamscan"
	}
}
