{
	"wow": {
		"prefix": "nayan",
		"body": [
			"function<void(int , int) > func = [&](int child , int parent) -> void {",
			"\t$1",
			"};"
		],
		"description": "wow"
	},
	"jaishrimahakal": {
		"prefix": "leetcode",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"// Policy based data structures(PBDS) C++ STL",
			"// order_of_key(k): returns count of elements strictly smaller than k ",
			"// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			"// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define INF               1000000000000000000",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const long long mod97 = 1000000007 ;",
			"const long long modg = 998244353 ;",
			"const long long N = 2e1 + 1 ;",
			"const long long LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"long long GCD(long long a, long long b){if(b == 0){return a;} return GCD(b, a % b);}",
			"long long LCM(long long a, long long b){return (a / GCD(a, b) * b) ;}",
			"long long mod_ADDITION(long long a, long long b, long long m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"long long mod_MULTIPLICATION(long long a, long long b, long long m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
			"long long mod_SUBTRACTION(long long a, long long b, long long m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"bool comparatorfunction(pair<long long,long long> &a, pair<long long,long long> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * x) ; x = (x * x) ; y = y >> 1 ;} return res ;}",
			"long long modpower(long long x, long long y){long long res = 1; x = x % mod97; while(y > 0){if(y&1) res = (res * x) % mod97; y = y >> 1; x = (x * x) % mod97 ;}return res ;} ",
			"bool isPowerOfTwo(long long n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i <= N; ++i){if(isPrime[i] == true){for(int j = 2*i; j <= N; j += i){isPrime[j] = false;}}} return isPrime;}",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;}",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= N; ++i){SPF[i] = i;}for(int i = 2; i <= N; ++i){if(SPF[i] == i){for(int j = i; j <= N; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"long long sqrtprecision(long long l,long long r,long long target){while(r-l>EPS){long long mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"void ncrwithoutmod(long long n, long long r){long long p = 1, k = 1; if (n-r < r) r = n-r; if (r != 0) {while (r) {p *= n; k *= r; long long m = __gcd(p, k);p /= m; k /= m; n--; r--; }} else cout << p << endl; }",
			"long long getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			"",
			"/* //------------------------------------------------------- Template Ends. */",
			""
		],
		"description": "jaishrimahakal"
	},
	"cheat": {
		"prefix": "cheating",
		"body": [
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC target(\"avx,avx2,fma\")",
			"#pragma GCC optimization (\"unroll-loops\")",
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"// Policy based data structures(PBDS) C++ STL",
			"// order_of_key(k): returns count of elements strictly smaller than k ",
			"// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			"// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <class K, class V> using ordered_map = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"#define ll                long long",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define INF               1000000000000000000",
			"#define nl                \"\\n\"",
			"",
			"const int mod97 = 1000000007 ;",
			"const int modg = 998244353 ;",
			"const int N = 2e1 + 10 ;",
			"",
			"bool solve(){",
			"\t$1",
			"    return true;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"//#ifndef ONLINE_JUDGE",
			"//    freopen(\"input.txt\",\"r\",stdin);",
			"//    freopen(\"output.txt\",\"w\",stdout);",
			"//    freopen(\"error.txt\", \"w\", stderr);",
			"//#endif ",
			"    int t;",
			"    cin >> t;  ",
			"    //int count = 1;",
			"",
			"    while (t--){",
			"        //cout << \"Case #\" << count << \": \";",
			"        if(solve()){",
			"            //count++;",
			"        }else{",
			"            // cout << \"NO\" << endl;",
			"        }",
			"    }",
			"    return 0;",
			"}",
			" ",
			" ",
			" ",
			" ",
			"// Think twice, code once. "
		],
		"description": "cheat"
	},
	"Template 1": {
		"prefix": "dsu",
		"body": [
		"struct DSU {",
		"    int S ; ",
		"    struct node {",
		"        int p; int sum;",
		"    };",
		"    vector<node> dsu ; ",
		"",
		"    DSU(int n) { ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.sum = 1; ",
		"            dsu.pb(tmp) ; ",
		"        }",
		"    }",
		"",
		"    void reset(int n) {",
		"        dsu.clear() ; ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.sum = 1;",
		"            dsu.pb(tmp) ; ",
		"        }",
		"    }",
		"",
		"    int parent(int u) {",
		"        if(dsu[u].p == u) return u;",
		"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
		"        return dsu[u].p ; ",
		"    }",
		"",
		"    void merge(int u, int v) {",
		"        u = parent(u); v = parent(v);",
		"        if(u == v) return ;",
		"        dsu[v].p = u ; ",
		"        dsu[u].sum += dsu[v].sum ; ",
		"    }",
		"",
		"    bool same(int u, int v) {",
		"        if(parent(u) == parent(v)) return true ; ",
		"        return false ; ",
		"    }",
		"",
		"    int get(int u) {",
		"        return dsu[parent(u)].sum ; ",
		"    }",
		"};"
		],
		"description": "Template 1"
	},
	"ababbaba":{
		"prefix": "concepts",
		"body": [
		"//lower bound of p mtlb p se just badda ya uske equal agr lower bound ke it ko -- kra to just chota milega agr ye it s.end hai to mtlb vo element ya usse badda element nhi hai aur agr ye sbegin hai to uss element se chota element nhi hai",
		"//upper bound of p mtlb p se just badda uske equal nhi agr ye s.end() hai to mtlb uss element se badda element nhi hai aur agr iske it ko it-- kre to uss p se just chota ya uske equal element milega but agr ye s.begin hai to usme koi bhi element p ya p se chota nhi hai",
		"If Inserting / pushing elements in a set / priority_queue it takes (nlog n) time complexity.",
		"Never use map< pair<int , int > , int > mp instead use vector<unordered_map<int , int > > v(n)",
		],
		"description": "ababbaba"
	},
	"fenwick": {
		"prefix": "fenwicktree",
		"body": [
		"struct FenwickTree {",
		"    vector<int> bit , fen ;  ",
		"    int n ;",
		"    map<int , int > ans ;",
		"",
		"    FenwickTree(int n) {",
		"        this->n = n ;",
		"        bit.assign(n , 0) ; ",
		"    }",
		"",
		"    FenwickTree(vector<int > a) : FenwickTree(a.size()) {",
		"        for (size_t i = 0 ; i < a.size() ; i++)",
		"            update(i , a[i]) ;",
		"    }",
		"",
		"    int sum(int r) {",
		"        int ret = 0 ;",
		"        for (; r >= 0 ; r = (r & (r + 1)) - 1){",
		"            ret += bit[r] ;",
		"        }",
		"        return ret ; ",
		"    }",
		"",
		"    int rangesum(int l , int r) {",
		"        return sum(r) - sum(l - 1) ;",
		"    }",
		"",
		"    void update(int idx , int add) {",
		"        ans[idx] += add ;",
		"",
		"        if(ans[idx] > 1 || (ans[idx] == 1 && add < 0)) return ;",
		"        ",
		"        for (; idx < n ; idx = idx | (idx + 1)){",
		"            bit[idx] += add ; ",
		"        }",
		"    }",
		"};"
		],
		"description": "fenwick"
	},
	"segment": {
		"prefix": "segmenttree",
		"body": [
			//"// Segment Tree with Point Updates and Range Queries",
			//"// Supports multiple Segment Trees with just a change in the Node and Update",
			//"// Very few changes required everytime",
			"",
			"template<typename Node, typename Update>",
			"struct SegTree {",
			"	vector<Node > tree ;",
			"	vector<int > arr ; // type may change",
			"	int n , s ;",
			"	int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"	SegTree(int a_len, vector<int> &a) { // change if type updated",
			"		arr = a ;",
			"		n = a_len ; ",
			"        s = 1 ;",
			"        while(s < 2 * n){",
			"            s = (s << 1) ;",
			"        }",
			"		tree.resize(s); fill(all(tree), Node()) ;",
			"		build(0 , n - 1 , 1) ;",
			"	}",
			"	void build(int start, int end, int index)  // Never change this",
			"	{",
			"		if(start == end){",
			"			tree[index] = Node(arr[start]); // may change",
			"			return;",
			"		}",
			"		int mid = (start + end) / 2;",
			"		build(start, mid, 2 * index);",
			"		build(mid + 1, end, 2 * index + 1);",
			"		tree[index].merge(tree[2 * index], tree[2 * index + 1]);",
			"	}",
			"	void update(int start, int end, int index, int query_index, Update &u)  // Never Change this",
			"	{",
			"		if(start == end){",
			"			u.apply(tree[index]);",
			"			return;",
			"		}",
			"		int mid = (start + end) / 2;",
			"		if(mid >= query_index)",
			"			update(start, mid, 2 * index, query_index, u);",
			"		else",
			"			update(mid + 1 , end , 2 * index + 1 , query_index, u) ;",
			"		tree[index].merge(tree[2 * index], tree[2 * index + 1]) ;",
			"	}",
			"	Node query(int start, int end, int index, int left, int right) { // Never change this",
			"		if(start > right || end < left)",
			"			return Node() ;",
			"		if(start >= left && end <= right)",
			"			return tree[index] ;",
			"		int mid = (start + end) / 2 ;",
			"		Node l , r , ans ;",
			"		l = query(start , mid , 2 * index , left, right) ;",
			"		r = query(mid + 1 , end , 2 * index + 1 , left , right) ;",
			"		ans.merge(l , r) ;",
			"		return ans ;",
			"	}",
			"	void make_update(int index, int val) {  // pass in as many parameters as required",
			"		Update new_update = Update(val); // may change",
			"		update(0 , n - 1 , 1 , index , new_update) ;",
			"	}",
			"	Node make_query(int left , int right) {",
			"		return query(0 , n - 1 , 1 , left , right) ;",
			"	}",
			"};",
			"",
			"struct Node1 {",
			"	int val; // may change",
			"	Node1() { // Identity element",
			"		val = 0;	// may change",
			"	}",
			"	Node1(int p1) {  // Actual Node",
			"		val = p1; // may change",
			"	}",
			"	void merge(Node1 &l, Node1 &r) { // Merge two child nodes",
			"		val = l.val ^ r.val;  // may change",
			"	}",
			"};",
			"",
			"struct Update1 {",
			"	int val; // may change",
			"	Update1(int p1) { // Actual Update",
			"		val = p1; // may change",
			"	}",
			"	void apply(Node1 &a) { // apply update to given node",
			"		a.val = val; // may change",
			"	}",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"SegTree<Node1 , Update1> SEGMENT_TREE = SegTree<Node1 , Update1 > (n , v) ;",
			"",
			"*/"
		],
		"description": "segment"
	},
	"Template 4": {
		"prefix": "blackbox",
		"body": [
			"int blackbox(string &s) {",
			"    int n = s.size() ;",
			"    int hash = 0 ; ",
			"    int p = 1 ;",
			"    for(int i = 0 ; i < n ; ++i){",
			"        hash = (hash + ((s[i] - 'a' + 1) * p) % mod97) % mod97 ;",
			"        p = (p * (int)31) % mod97 ;",
			"    }",
			"}"
		],
		"description": "Template 4"
	},
	// "vector<unordered_map<int , int > >": {
	// 	"prefix": "gp_hash_table<int, ll> dp[N];",
	// 	"body": [
	// 		"struct custom_hash {",
	// 		"  static uint64_t splitmix64(uint64_t x) {",
	// 		"    x += 0x9e3779b97f4a7c15;",
	// 		"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
	// 		"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
	// 		"    return x ^ (x >> 31);",
	// 		"  }",
	// 		"  size_t operator()(uint64_t x) const {",
	// 		"    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
	// 		"    return splitmix64(x + FIXED_RANDOM);",
	// 		"  }",
	// 		"};"
	// 	],
	// 	"description": "vector<unordered_map<int , int > >"
	// },
	"Template 5": {
		"prefix": "interactive..interactor",
		"body": [
			"struct Interactor{",
			"    int hiddenNumber ;",
			"    int limitQueries = 0 ;",
			"    int queries = 0 ;",
			"    Interactor(){ // it is constructor of this struct",
			"        hiddenNumber = getRandomNumber(1 , 1000) ; // initialize this variable called hiddenNumber",
			"        limitQueries = 100 ; // limit by your self for debuging.",
			"    }",
			"    char query(int x , bool printOutput){",
			"        if(queries >= limitQueries){",
			"            cout << \"You have exceeded the number of queries\" << endl ;",
			"        }else{",
			"            queries ++ ;",
			"        }",
			"        // assert(queries < limitQueries) // Your code stops here if this is false give out a runtime error.",
			"        char ans = '=' ;",
			"        if(x > hiddenNumber){",
			"            ans = '>' ;",
			"        }",
			"        else if(x < hiddenNumber){",
			"            ans = '<' ;",
			"        }",
			"        else{",
			"            ans = '=' ;",
			"        }",
			"        if(printOutput){",
			"            cout << ans << endl ;",
			"        }",
			"        return ans ;",
			"    }",
			"    bool correctOutput(int x){",
			"        if(x == hiddenNumber){",
			"            cout << \"Passed for \" << x << endl ;",
			"        }else{",
			"            cout << \"Failed\" << endl ;",
			"            cout << \"Hidden Number: \" << hiddenNumber << endl ;",
			"            cout << \"Output Given: \" << x << endl ;",
			"        }",
			"        return x == hiddenNumber ;",
			"    }",
			"}"
		],
		"description": "Template 5"
	},
	"Template 6": {
		"prefix": "lps",
		"body": [
			"vector<int > longestprefixsuffix(string &s){",
			"    int n = s.size() ;",
			"    vector<int > lps(n , 0) ;",
			"    int len = 0 ;",
			"    int i = 1 ;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            lps[i] = len + 1 ; // storing the longest common",
			"            len ++ ;",
			"            i ++ ;",
			"        }else{",
			"            if(len == 0){",
			"                lps[i] = 0 ;",
			"                i ++ ;",
			"            }else{",
			"                len = lps[len - 1] ; // A(0)A(1)B(0)A(2)A(2)",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Template 6"
	},
	"template 7": {
		"prefix": "dijkstra",
		"body": [
			"// // O(VlogV + ElogV) " ,
			"class Solution",
			"{",
			"public:",
			"    vector<int> shortestPath(int n, int m, vector<vector<int>> &edges)",
			"    {",
			"        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}",
			"        // where the edge weight is the weight of the edge from node1 to node2.",
			"        vector< pair< int , int > > adj[n + 1] ;",
			"        for (auto &i : edges)",
			"        {",
			"            adj[i[0]].push_back({i[1], i[2]});",
			"            adj[i[1]].push_back({i[0], i[2]});",
			"        }",
			"        // Create a priority queue for storing the nodes along with distances ",
			"        // in the form of a pair { dist, node }.",
			"        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int , int> > > pq;",
			"",
			"        // Create a dist array for storing the updated distances and a parent array for storing the nodes from where the current nodes represented by indices of the parent array came from.",
			"        vector<int > dist(n + 1 , 1e9) , parent(n + 1) , vis(n + 1 , 0) ;",
			"        for (int i = 1 ; i <= n ; ++i)",
			"            parent[i] = i ;",
			"",
			"        dist[1] = 0 ;",
			"",
			"        // Push the source node to the queue.",
			"        pq.push({0, 1});",
			"        keeping visited vector is important because it was giving TLE for cses problem shortest route 1 for two test cases",
			"        while (!pq.empty())",
			"        {",
			"            // Topmost element of the priority queue is with minimum distance value.",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int dis = it.first ;",
			"            if(vis[node]) continue ;" ,
			"            vis[node] = 1 ;" ,
			"",
			"            // Iterate through the adjacent nodes of the current popped node.",
			"            for (auto it : adj[node])",
			"            {",
			"                int adjNode = it.first;",
			"                int edW = it.second;",
			"",
			"                // Check if the previously stored distance value is greater than the current computed value or not, if yes then update the distance value.",
			"                if (dis + edW < dist[adjNode])",
			"                {",
			"                    dist[adjNode] = dis + edW;",
			"                    pq.push({dis + edW, adjNode});",
			"",
			"                    // Update the parent of the adjNode to the recent node where it came from.",
			"                    parent[adjNode] = node;",
			"                }",
			"            }",
			"        }",
			"",
			"        // If distance to a node could not be found, return an array containing -1.",
			"        if (dist[n] == 1e9)",
			"            return {-1};",
			"",
			"        // Store the final path in the ‘path’ array.",
			"        vector<int> path ;",
			"        int node = n ;",
			"",
			"        // Iterate backwards from destination to source through the parent array.",
			"        while (parent[node] != node)",
			"        {",
			"            path.push_back(node) ;",
			"            node = parent[node] ;",
			"        }",
			"        path.push_back(1) ;",
			"",
			"        // Since the path stored is in a reverse order, we reverse the array to get the final answer and then return the array.",
			"        reverse(path.begin() , path.end()) ;",
			"        return path ;",
			"    }",
			"};"
		],
		"description": "template 7"
	},
	
	"deadlypillow": {
		"prefix": "deadlypillowncr",
		"body": [
			"int F[N], iF[N]; // Don't forget to change the value of N. factorial,Inverse Factorial Array",
			"",
			"int fast(int b, int e) {",
			"    int res = 1;",
			"    for (; e; e >>= 1, b = b * b % mod97)",
			"        if (e & 1)",
			"            res = res * b % mod97;",
			"    return res;",
			"}",
			"",
			"void init() {",
			"    F[0] = 1 ;",
			"    for(int i = 1 ; i < N ; ++i) F[i] = (F[i - 1] * i) % mod97;",
			"    iF[N - 1] = fast(F[N - 1] , mod97 - 2) ; // it finds the inverse of F[N - 1] ",
			"    for (int i = N - 2 ; i >= 0 ; --i)",
			"        iF[i] = iF[i + 1] * (i + 1) % mod97 ;",
			"}",
			"",
			"int NCR(int n, int r) {",
			"    if (r > n || r < 0)",
			"        return 0 ;",
			"    return iF[r] * F[n] % mod97 * iF[n - r] % mod97 ;",
			"}"
		],
		"description": "deadlypillow"
	},
	"template 8": {
		"prefix": "bellmanford",
		"body": [
			"Problem Statement: Given a weighted, directed and connected graph of V vertices and E edges, Find the shortest distance of all the vertices from the source vertex S for negative edges.",
			"class Solution {",
			"public:",
			"	/*  Function to implement Bellman Ford",
			"	*   edges: vector of vectors which represents the graph",
			"	*   S: source vertex to start traversing graph with",
			"	*   V: number of vertices",
			"	*/",
			"	vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {",
			"		vector<int> dist(V, 1e8);",
			"		dist[S] = 0;",
			"		for (int i = 0 ; i < V - 1 ; ++i) {",
			"			for (auto it : edges) {",
			"				int u = it[0];",
			"				int v = it[1];",
			"				int wt = it[2];",
			"				if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {",
			"					dist[v] = dist[u] + wt;",
			"				}",
			"			}",
			"		}",
			"		// Nth relaxation to check negative cycle",
			"		for (auto it : edges) {",
			"			int u = it[0];",
			"			int v = it[1];",
			"			int wt = it[2];",
			"			if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {",
			"				return {-1};",
			"			}",
			"		}",
			"",
			"		return dist;",
			"	}",
			"};"
		],
		"description": "template 8"
	},
	"template 9": {
		"prefix": "floydwarshall",
		"body": [
			"// Problem Statement: The problem is to find the shortest distances between every pair of vertices in a given edge-weighted directed graph. The graph is represented as an adjacency matrix of size n*n. Matrix[i][j] denotes the weight of the edge from i to j. If Matrix[i][j]=-1, it means there is no edge from i to j.",
			"class Solution {",
			"public:",
			"	void shortest_distance(vector<vector<int>>&matrix) {",
			"		int n = matrix.size();",
			"		for (int i = 0; i < n; i++) {",
			"			for (int j = 0; j < n; j++) {",
			"				if (matrix[i][j] == -1) {",
			"					matrix[i][j] = 1e9;",
			"				}",
			"				if (i == j) matrix[i][j] = 0;",
			"			}",
			"		}",
			"",
			"		for (int k = 0; k < n; k++) {",
			"			for (int i = 0; i < n; i++) {",
			"				for (int j = 0; j < n; j++) {",
			"					matrix[i][j] = min(matrix[i][j] , matrix[i][k] + matrix[k][j]);",
			"				}",
			"			}",
			"		}",
			"",
			"",
			"",
			"",
			"		for (int i = 0; i < n; i++) {",
			"			for (int j = 0; j < n; j++) {",
			"				if (matrix[i][j] == 1e9) {",
			"					matrix[i][j] = -1;",
			"				}",
			"			}",
			"		}",
			"	}",
			"};"
		],
		"description": "template 9"
	},
	"prims": {
		"prefix": "primsalgorithm",
		"body": [
			"// Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.(A Minimum Spanning Tree (MST) is a subset of edges of a connected weighted undirected graph that connects all the vertices together with the minimum possible total edge weight.)",
			"// (Sometimes it may be asked to find the MST as well, where in the MST the edge-informations will be stored in the form {u, v}(u = starting node, v = ending node).)",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"class Solution",
			"{",
			"public:",
			"	// Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"	int spanningTree(int V, vector<vector<int>> adj[])",
			"	{",
			"		priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int>>> pq;",
			"",
			"		vector<int> vis(V, 0);",
			"		// {wt, node}",
			"		pq.push({0, 0});",
			"		int sum = 0;",
			"		while (!pq.empty()) {",
			"			auto it = pq.top();",
			"			pq.pop();",
			"			int node = it.second;",
			"			int wt = it.first;",
			"",
			"			if (vis[node] == 1) continue ;",
			"			// add it to the mst",
			"			vis[node] = 1 ;",
			"			sum += wt ;",
			"			for (auto it : adj[node]) {",
			"				int adjNode = it[0] ;",
			"				int edW = it[1] ;",
			"				if (!vis[adjNode]) {",
			"					pq.push({edW , adjNode}) ;",
			"				}",
			"			}",
			"		}",
			"		return sum ;",
			"	}",
			"};",
			"",
			"",
			"int main() {",
			"",
			"	int V = 5;",
			"	vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"	vector<vector<int > > adj[V] ;",
			"	for (auto it : edges) {",
			"		vector<int> tmp(2) ;",
			"		tmp[0] = it[1] ;",
			"		tmp[1] = it[2] ;",
			"		adj[it[0]].push_back(tmp) ;",
			"",
			"		tmp[0] = it[0] ;",
			"		tmp[1] = it[2] ;",
			"		adj[it[1]].push_back(tmp) ;",
			"	}",
			"",
			"	Solution obj;",
			"	int sum = obj.spanningTree(V, adj);",
			"	cout << \"The sum of all the edge weights: \" << sum << endl;",
			"",
			"	return 0;",
			"}"
		],
		"description": "prims"
	},
	"kruskal": {
		"prefix": "kruskal'salgorithm",
		"body": [
			"// Problem Statement: Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"",
			"class DisjointSet {",
			"    vector<int> rank, parent, size;",
			"public:",
			"    DisjointSet(int n) {",
			"        rank.resize(n + 1, 0);",
			"        parent.resize(n + 1);",
			"        size.resize(n + 1);",
			"        for (int i = 0; i <= n; i++) {",
			"            parent[i] = i;",
			"            size[i] = 1;",
			"        }",
			"    }",
			"",
			"    int findUPar(int node) {",
			"        if (node == parent[node])",
			"            return node;",
			"        return parent[node] = findUPar(parent[node]);",
			"    }",
			"",
			"    void unionByRank(int u, int v) {",
			"        int ulp_u = findUPar(u);",
			"        int ulp_v = findUPar(v);",
			"        if (ulp_u == ulp_v) return;",
			"        if (rank[ulp_u] < rank[ulp_v]) {",
			"            parent[ulp_u] = ulp_v;",
			"        }",
			"        else if (rank[ulp_v] < rank[ulp_u]) {",
			"            parent[ulp_v] = ulp_u;",
			"        }",
			"        else {",
			"            parent[ulp_v] = ulp_u;",
			"            rank[ulp_u]++;",
			"        }",
			"    }",
			"",
			"    void unionBySize(int u, int v) {",
			"        int ulp_u = findUPar(u);",
			"        int ulp_v = findUPar(v);",
			"        if (ulp_u == ulp_v) return;",
			"        if (size[ulp_u] < size[ulp_v]) {",
			"            parent[ulp_u] = ulp_v;",
			"            size[ulp_v] += size[ulp_u];",
			"        }",
			"        else {",
			"            parent[ulp_v] = ulp_u;",
			"            size[ulp_u] += size[ulp_v];",
			"        }",
			"    }",
			"};",
			"class Solution",
			"{",
			"public:",
			"    //Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[])",
			"    {",
			"        // 1 - 2 wt = 5",
			"        /// 1 - > (2, 5)",
			"        // 2 -> (1, 5)",
			"",
			"        // 5, 1, 2",
			"        // 5, 2, 1",
			"        vector<pair<int, pair<int, int>>> edges;",
			"        for (int i = 0; i < V; i++) {",
			"            for (auto it : adj[i]) {",
			"                int adjNode = it[0];",
			"                int wt = it[1];",
			"                int node = i;",
			"",
			"                edges.push_back({wt, {node, adjNode}});",
			"            }",
			"        }",
			"        DisjointSet ds(V);",
			"        sort(edges.begin(), edges.end());",
			"        int mstWt = 0;",
			"        for (auto it : edges) {",
			"            int wt = it.first;",
			"            int u = it.second.first;",
			"            int v = it.second.second;",
			"",
			"            if (ds.findUPar(u) != ds.findUPar(v)) {",
			"                mstWt += wt;",
			"                ds.unionBySize(u, v);",
			"            }",
			"        }",
			"",
			"        return mstWt;",
			"    }",
			"};",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int>> edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int>> adj[V];",
			"    for (auto it : edges) {",
			"        vector<int> tmp(2);",
			"        tmp[0] = it[1];",
			"        tmp[1] = it[2];",
			"        adj[it[0]].push_back(tmp);",
			"",
			"        tmp[0] = it[0];",
			"        tmp[1] = it[2];",
			"        adj[it[1]].push_back(tmp);",
			"    }",
			"",
			"    Solution obj;",
			"    int mstWt = obj.spanningTree(V, adj);",
			"    cout << \"The sum of all the edge weights: \" << mstWt << endl;",
			"    return 0;",
			"}"
		],
		"description": "kruskal"
	},
	"lazy": {
		"prefix": "lazysegmenttree",
		"body": [
			"// Lazy Segment Tree with Range Updates and Range Queries",
			"// Supports multiple Segment Trees with just a change in the Node and Update",
			"// Very few changes required everytime",
			"",
			"template<typename Node, typename Update>",
			"struct LazySGT {",
			"    vector<Node > tree ;",
			"    vector<bool > lazy ;",
			"    vector<Update > updates ;",
			"    vector<int > arr ; // type may change",
			"    int n ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    LazySGT(int a_len , vector<int > &a) { // change if type updated",
			"        arr = a ;",
			"        n = a_len ;",
			"        sz = 1 ;",
			"        while(__builtin_popcount(n) != 1){",
			"            n ++ ; // as long as n is not the perfect power of two.",
			"        }",
			"        sz = n ;",
			"        tree.resize(sz) ; fill(all(tree) , Node()) ;",
			"        lazy.resize(sz) ; fill(all(lazy) , false) ;",
			"        updates.resize(sz) ; fill(all(updates) , Update()) ;",
			"        build(0 , n - 1 , 1) ;",
			"    }",
			"    void build(int start , int end , int index) { // Never change this",
			"        if (start == end)   {",
			"            tree[index] = Node(arr[start]) ;",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(start , mid, 2 * index) ;",
			"        build(mid + 1 , end , 2 * index + 1) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void pushdown(int index , int start , int end){",
			"        if(lazy[index]){",
			"            int mid = (start + end) / 2 ; ",
			"            apply(2 * index , start , mid , updates[index]) ;",
			"            apply(2 * index + 1 , mid + 1 , end , updates[index]) ;",
			"            updates[index] = Update() ;",
			"            lazy[index] = 0 ;",
			"        }",
			"    }",
			"    void apply(int index , int start , int end , Update& u){",
			"        if(start != end){",
			"            lazy[index] = 1 ;",
			"            updates[index].combine(u , start , end) ;",
			"        }",
			"        u.apply(tree[index] , start , end) ;",
			"    }",
			"    void update(int start, int end, int index, int left, int right, Update &u) {  // Never Change this",
			"        if(start > right || end < left)",
			"            return ;",
			"        if(start >= left && end <= right){",
			"            apply(index , start , end , u) ;",
			"            return ;",
			"        }",
			"        pushdown(index , start , end) ;",
			"        int mid = (start + end) / 2 ;",
			"        update(start , mid , 2 * index , left , right , u) ;",
			"        update(mid + 1 , end , 2 * index + 1 , left , right , u) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int start, int end, int index, int left, int right) { // Never change this",
			"        if (start > right || end < left)",
			"            return Node();",
			"        if (start >= left && end <= right){",
			"            pushdown(index, start, end);",
			"            return tree[index];",
			"        }",
			"        pushdown(index, start, end) ;",
			"        int mid = (start + end) / 2 ;",
			"        Node l , r , ans ;",
			"        l = query(start , mid , 2 * index , left , right) ;",
			"        r = query(mid + 1 , end , 2 * index + 1 , left , right) ;",
			"        ans.merge(l , r) ;",
			"        return ans ;",
			"    }",
			"    void make_update(int left, int right, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val) ; // may change",
			"        update(0 , n - 1 , 1 , left , right , new_update) ;",
			"    }",
			"    Node make_query(int left, int right) {",
			"        return query(0 , n - 1 , 1 , left , right) ;",
			"    }",
			"};",
			"",
			"struct Node1 {",
			"    int val ; // may change",
			"    Node1() { // Identity element",
			"        val = 0 ;    // may change",
			"    }",
			"    Node1(int p1) {  // Actual Node",
			"        val = p1 ; // may change",
			"    }",
			"    void merge(Node1 &l , Node1 &r) { // Merge two child nodes",
			"        val = l.val + r.val ;  // may change",
			"    }",
			"};",
			"",
			"struct Update1 {",
			"    int val ; // may change",
			"    Update1(){ // Identity update",
			"        val = 0 ;",
			"    }",
			"    Update1(int val1) { // Actual Update",
			"        val = val1 ;",
			"    }",
			"    void apply(Node1 &a, int start, int end) { // apply update to given node",
			"        a.val = val * (end - start + 1) ; // may change",
			"    }",
			"    void combine(Update1& new_update , int start , int end){",
			"        val = new_update.val ;",
			"    }",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"SegTree<Node1 , Update1> LAZY_SEGMENT_TREE = SegTree<Node1 , Update1 > (4 , arr) ;",
			"",
			"*/"
		],
		"description": "lazy"
	},
	"convexhullgrahamscan": {
		"prefix": "convexhull",
		"body": [
			"void cc(vector<pair<ll, ll>>& points) {",
			" ",
			"    auto ccw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) > 0;",
			"    };",
			"    auto cw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) < 0;",
			"    };",
			" ",
			"    auto cmp = [](pair<ll, ll>& p, pair<ll, ll>& pp) {",
			"        if (p.first == pp.first) return p.second < pp.second;",
			"        return p.first < pp.first;",
			"    };",
			" ",
			"    sort(all(points), cmp); ll n = points.size();",
			"    pair<ll, ll>a = points[0], c = points[n - 1];",
			"    vector<pair<ll, ll>>up, down;",
			"    up.push_back(a); down.push_back(a);",
			"    for (ll i = 1; i < points.size(); i++) {",
			"        if (i == n - 1 || !ccw(a, points[i], c)) {",
			"            // upper half and colinear",
			"            while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], points[i])) {",
			"                up.pop_back();",
			"            }",
			"            up.push_back(points[i]);",
			"        }",
			"        if (i == n - 1 || !cw(a, points[i], c)) {",
			"            //lower Half and colinear",
			"            while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], points[i])) {",
			"                down.pop_back();",
			"            }",
			"            down.push_back(points[i]);",
			"        }",
			"    }",
			"    points.clear();",
			"    for (size_t i = 0; i < up.size(); i++)  points.push_back(up[i]);",
			"    for (size_t i = 0; i < down.size(); i++) points.push_back(down[i]);",
			" ",
			"    // Points vector has duplicate values also ",
			"    // as which belongs both upper half and lower half",
			" ",
			"}"
		],
		"description": "convexhullgrahamscan"
	},
	"sparse": {
		"prefix": "sparsetable",
		"body": [
			"// O(1) for idempotent O(logN) for general",
			"",
			"template<typename Node>",
			"struct SparseTable {",
			"   vector<vector<Node > > table ;",
			"   vector<int > logValues ;",
			"   int n ;",
			"   int maxLog ;",
			"   vector<int > a ;",
			"   SparseTable(int n1 , vector<int > &arr) {",
			"       n = n1 ;",
			"       a = arr ;",
			"       table.resize(n) ;",
			"       logValues.resize(n + 1) ;",
			"       maxLog = log2(n) ;",
			"       logValues[1] = 0 ;",
			"       0 1 1 2 2 2 2 3 3 3  3  3  3  3  3  4  . . . . ",
			"       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . . . . ",
			"       for(int i = 2 ; i <= n ; ++i) {",
			"           logValues[i] = logValues[i / 2] + 1 ;",
			"       }",
			"       for(int i = 0 ; i < n ; ++i) {",
			"           table[i].resize(maxLog + 1) ;",
			"           fill(all(table[i]) , Node()) ;",
			"       }",
			"       build() ;",
			"	}",
			"	void build() {",
			"		for(int i = 0; i < n; i++) {",
			"			table[i][0] = Node(a[i]) ;",
			"		}",
			"		for(int i = 1 ; i <= maxLog ; ++i) {",
			"			for(int j = 0 ; (j + (1 << i)) <= n ; ++j) {",
			"				table[j][i].merge(table[j][i - 1] , table[j + (1 << (i - 1))][i - 1]) ;",
			"			}",
			"		}",
			"	}",
			"	Node queryNormal(int left , int right) { // O(log(n))",
			"		Node ans = Node() ;",
			"		for(int j = logValues[right - left + 1] ; j >= 0 ; --j) {",
			"			if((1 << j) <= right - left + 1) {",
			"				ans.merge(ans, table[left][j]) ;",
			"				left += (1 << j) ; // will not be (j - 1)",
			"			}",
			"		}",
			"		return ans ; ",
			"	}",
			"	Node queryIdempotent(int left, int right) { O(1)",
			"		int j = logValues[right - left + 1] ;",
			"		Node ans = Node() ;",
			"		ans.merge(table[left][j] , table[right - (1 << j) + 1][j]) ;",
			"		return ans ;",
			"	}",
			"};",
			"struct Node1 {",
			"	int val ; // store more info if required // may change",
			"	Node1() { // Identity Element",
			"		val = 0 ; // may change",
			"	}",
			"	Node1(int v) {",
			"		val = v ;",
			"	}",
			"	void merge(Node1 &l , Node1 &r) {",
			"		val = l.val ^ r.val ;",
			"	}",
			"};",
			"",
			"/*",
			"",
			"        How to build the sparse table ",
			"",
			"        SparseTable<Node1 > SPARSE_TABLE = SparseTable<Node1 > (m , arr) ;",
			"",
			"*/"
		],
		"description": "sparse"
	},
	"bitwise": {
		"prefix": "bitwise_TRIE",
		"body": [
			"class Trie {",
			"public:",
			"    struct BITS_TRIE {",
			"        private:",
			"        struct node {",
			"            int start = 0 ;",
			"            int end = 0 ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            node* next[2] ;",
			"            node() {",
			"                next[1] = next[0] = NULL ;",
			"            }",
			"        };",
			"",
			"        node root ;",
			"",
			"        public:",
			"        void insert(int val) {",
			"            node* temp = &root;",
			"            temp->cnt++ ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                if(temp->next[bit] == NULL) {",
			"                    temp->next[bit] = new node() ;",
			"                }",
			"",
			"                temp = temp->next[bit] ;",
			"                temp->cnt++ ;",
			"            }",
			"        }",
			"",
			"        int max_xor(int val) {",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = 1 - bit ;",
			"",
			"                if(temp->next[req] == NULL) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else {",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"",
			"        int min_xor(int val){",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i){",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0){",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = bit ;",
			"",
			"                if(temp->next[req] == NULL){",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0){",
			"                    ans += (1 << i) ;",
			"                    temp=temp->next[1 - req] ;",
			"                }",
			"                else{",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"    };",
			"};"
		],
		"description": "bitwise"
	},
	"string": {
		"prefix": "stringwise_trie",
		"body": [
			"class Trie {",
			"public:",
			"    struct STRING_TRIE {",
			"        private:",
			"        struct Node {",
			"            Node* next[26] ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            int cntEndWith = 0 ;",
			"            int cntPrefix = 0 ;  ",
			"",
			"            bool containsKey(char ch) {",
			"                return (next[ch - 'a'] != nullptr) ; ",
			"            }",
			"            Node* get(char ch) {",
			"                return next[ch - 'a'] ; ",
			"            }",
			"            void put(char ch, Node* node) {",
			"                next[ch - 'a'] = node ; ",
			"            }",
			"            void setEnd() { // comes to the end of the word after inserting set its refernce trie block to true",
			"                flag = true ; ",
			"            }",
			"            bool isEnd() { // check prefix ",
			"                return flag ; ",
			"            }",
			"            void increaseEnd() {",
			"                cntEndWith++ ;  ",
			"            }",
			"            void increasePrefix() {",
			"                cntPrefix++ ; ",
			"            }",
			"            void deleteEnd() {",
			"                cntEndWith-- ; ",
			"            }",
			"            void reducePrefix() {",
			"                cntPrefix-- ; ",
			"            }",
			"            int getEnd() {",
			"                return cntEndWith ; ",
			"            }",
			"            int getPrefix() {",
			"                return cntPrefix ; ",
			"            }",
			"        };",
			"",
			"        Node *root ;",
			"",
			"        public:",
			"        /** Inserts a word into the trie. */",
			"        void insert(string word) {",
			"            Node *node = root ;",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    node->put(word[i] , new Node()) ; ",
			"                }",
			"                node = node->get(word[i]) ;  ",
			"            }",
			"            node->setEnd() ; ",
			"        }",
			"",
			"        /** Returns if the word is in the trie. */",
			"        bool search(string word) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"            }",
			"            if(node->isEnd()) {",
			"                return true ; ",
			"            }",
			"            return false ; ",
			"        }",
			"",
			"        /** Returns if there is any word in the trie that starts with the given prefix. */",
			"        bool startsWith(string prefix) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < prefix.size() ; ++i) {",
			"                if(!node->containsKey(prefix[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(prefix[i]) ; ",
			"            }",
			"            return true ; ",
			"        }",
			"",
			"        /** Returns inumber of words equal to given word */",
			"        int countWordsEqualTo(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getEnd() ; ",
			"        }",
			"",
			"        /** ... */",
			"        int countWordsStartingWith(string &word){",
			"            Node* node = root;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getPrefix() ; ",
			"        }",
			"",
			"        /** Actually it do not remove the blocks but it decreases the count of that word */",
			"        void erase(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                    node->reducePrefix() ;  ",
			"                }",
			"                else {",
			"                    return ;",
			"                }",
			"            }",
			"            node->deleteEnd() ;  ",
			"        }",
			"",
			"        /** ... */",
			"        bool checkIfAllPrefixExists(string word) {",
			"            Node *node = root;",
			"            bool flag = true; ",
			"            for(int i = 0;i<word.size();i++) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]); ",
			"                    flag = flag & node->isEnd(); ",
			"                }",
			"                else {",
			"                    return false; ",
			"                } ",
			"            }",
			"            return flag; ",
			"        }",
			"",
			"        /** ... */",
			"        string completeString(int n, vector<string> &a){",
			"            Node *node = root;",
			"            for(auto word : a) node->insert(word); ",
			"            string longest = \"\"; ",
			"            for(auto word: a) {",
			"                if(node->checkIfAllPrefixExists(word)) {",
			"                    if(word.size() > longest.size()) {",
			"                        longest = word; ",
			"                    }",
			"                    else if(word.size() == longest.size() && word < longest) {",
			"                        longest = word; ",
			"                    }",
			"                }",
			"            }",
			"            if(longest == \"\") return \"None\"; ",
			"            return longest; ",
			"        }",
			"",
			"        /** ... */",
			"        int countDistinctSubstrings(string &s) {",
			"            Node* node = root;",
			"            int cnt = 0; ",
			"            int n = s.size(); ",
			"            for(int i = 0 ; i < n ; ++i)",
			"            {",
			"                Node* node = root; ",
			"                for(int j = i ; j < n ; ++j) {",
			"                    if(!node->containsKey(s[j])) {",
			"                        node->put(s[j], new Node()) ;  ",
			"                        cnt++ ; ",
			"                    }",
			"                    node = node->get(s[j]) ; ",
			"                }",
			"            }",
			"            return cnt + 1 ; //    Write your code here.",
			"        }",
			"",
			"    };",
			"};"
		],
		"description": "string"
	},
	"Heavy light decomposition": {
		"prefix": "heavylightdecomposition",
		"body": [
			"// Warning: this uses nearly 170 MB for N = 500,000. If low on memory use memory_rmq_lca.cc or block_rmq_lca.cc instead",
			"template<typename T, bool maximum_mode = false>",
			"struct RMQ {",
			"    static int highest_bit(unsigned x) {",
			"        return x == 0 ? -1 : 31 - __builtin_clz(x);",
			"    }",
			" ",
			"    int n = 0;",
			"    vector<T> values;",
			"    vector<vector<int>> range_low;",
			" ",
			"    RMQ(const vector<T> &_values = {}) {",
			"        if (!_values.empty())",
			"            build(_values);",
			"    }",
			" ",
			"    // Note: when `values[a] == values[b]`, returns b.",
			"    int better_index(int a, int b) const {",
			"        return (maximum_mode ? values[b] < values[a] : values[a] < values[b]) ? a : b;",
			"    }",
			" ",
			"    void build(const vector<T> &_values) {",
			"        values = _values;",
			"        n = int(values.size());",
			"        int levels = highest_bit(n) + 1;",
			"        range_low.resize(levels);",
			" ",
			"        for (int k = 0; k < levels; k++)",
			"            range_low[k].resize(n - (1 << k) + 1);",
			" ",
			"        for (int i = 0; i < n; i++)",
			"            range_low[0][i] = i;",
			" ",
			"        for (int k = 1; k < levels; k++)",
			"            for (int i = 0; i <= n - (1 << k); i++)",
			"                range_low[k][i] = better_index(range_low[k - 1][i], range_low[k - 1][i + (1 << (k - 1))]);",
			"    }",
			" ",
			"    // Note: breaks ties by choosing the largest index.",
			"    int query_index(int a, int b) const {",
			"        assert(0 <= a && a < b && b <= n);",
			"        int level = highest_bit(b - a);",
			"        return better_index(range_low[level][a], range_low[level][b - (1 << level)]);",
			"    }",
			" ",
			"    T query_value(int a, int b) const {",
			"        return values[query_index(a, b)];",
			"    }",
			"};",
			" ",
			"struct LCA {",
			"    int n = 0;",
			"    vector<vector<int>> adj;",
			"    vector<int> parent, depth, subtree_size;",
			"    vector<int> euler, first_occurrence;",
			"    vector<int> tour_start, tour_end;",
			"    vector<int> tour_list, rev_tour_list;",
			"    vector<int> heavy_root;",
			"    vector<int> heavy_root_depth, heavy_root_parent;  // These two vectors serve purely to optimize get_kth_ancestor",
			"    RMQ<int> rmq;",
			"    bool built;",
			" ",
			"    LCA(int _n = 0) {",
			"        init(_n);",
			"    }",
			" ",
			"    // Warning: this does not call build().",
			"    LCA(const vector<vector<int>> &_adj) {",
			"        init(_adj);",
			"    }",
			" ",
			"    void init(int _n) {",
			"        n = _n;",
			"        adj.assign(n, {});",
			"        parent.resize(n);",
			"        depth.resize(n);",
			"        subtree_size.resize(n);",
			"        first_occurrence.resize(n);",
			"        tour_start.resize(n);",
			"        tour_end.resize(n);",
			"        tour_list.resize(n);",
			"        heavy_root.resize(n);",
			"        built = false;",
			"    }",
			" ",
			"    // Warning: this does not call build().",
			"    void init(const vector<vector<int>> &_adj) {",
			"        init(int(_adj.size()));",
			"        adj = _adj;",
			"    }",
			" ",
			"    void add_edge(int a, int b) {",
			"        adj[a].push_back(b);",
			"        adj[b].push_back(a);",
			"    }",
			" ",
			"    int degree(int v) const {",
			"        return int(adj[v].size()) + (built && parent[v] >= 0);",
			"    }",
			" ",
			"    void dfs(int node, int par) {",
			"        parent[node] = par;",
			"        depth[node] = par < 0 ? 0 : depth[par] + 1;",
			"        subtree_size[node] = 1;",
			" ",
			"        // Erase the edge to parent.",
			"        adj[node].erase(remove(adj[node].begin(), adj[node].end(), par), adj[node].end());",
			" ",
			"        for (int child : adj[node]) {",
			"            dfs(child, node);",
			"            subtree_size[node] += subtree_size[child];",
			"        }",
			" ",
			"        // Heavy-light subtree reordering.",
			"        sort(adj[node].begin(), adj[node].end(), [&](int a, int b) {",
			"            return subtree_size[a] > subtree_size[b];",
			"        });",
			"    }",
			" ",
			"    int tour;",
			" ",
			"    void tour_dfs(int node, bool heavy) {",
			"        heavy_root[node] = heavy ? heavy_root[parent[node]] : node;",
			"        first_occurrence[node] = int(euler.size());",
			"        euler.push_back(node);",
			"        tour_list[tour] = node;",
			"        tour_start[node] = tour++;",
			"        bool heavy_child = true;",
			" ",
			"        for (int child : adj[node]) {",
			"            tour_dfs(child, heavy_child);",
			"            euler.push_back(node);",
			"            heavy_child = false;",
			"        }",
			" ",
			"        tour_end[node] = tour;",
			"    }",
			" ",
			"    void build(int root = -1, bool build_rmq = true) {",
			"        parent.assign(n, -1);",
			" ",
			"        if (0 <= root && root < n)",
			"            dfs(root, -1);",
			" ",
			"        for (int i = 0; i < n; i++)",
			"            if (i != root && parent[i] < 0)",
			"                dfs(i, -1);",
			" ",
			"        tour = 0;",
			"        euler.clear();",
			"        euler.reserve(2 * n);",
			" ",
			"        for (int i = 0; i < n; i++)",
			"            if (parent[i] < 0) {",
			"                tour_dfs(i, false);",
			"                // Add a -1 in between connected components to help us detect when nodes aren't connected.",
			"                euler.push_back(-1);",
			"            }",
			" ",
			"        assert(int(euler.size()) == 2 * n);",
			"        vector<int> euler_depth;",
			"        euler_depth.reserve(euler.size());",
			" ",
			"        for (int node : euler)",
			"            euler_depth.push_back(node < 0 ? node : depth[node]);",
			" ",
			"        if (build_rmq)",
			"            rmq.build(euler_depth);",
			" ",
			"        euler_depth.clear();",
			"        heavy_root_depth.resize(n);",
			"        heavy_root_parent.resize(n);",
			" ",
			"        for (int i = 0; i < n; i++) {",
			"            heavy_root_depth[i] = depth[heavy_root[i]];",
			"            heavy_root_parent[i] = parent[heavy_root[i]];",
			"        }",
			" ",
			"        rev_tour_list = tour_list;",
			"        reverse(rev_tour_list.begin(), rev_tour_list.end());",
			"        built = true;",
			"    }",
			" ",
			"    pair<int, array<int, 2>> get_diameter() const {",
			"        assert(built);",
			" ",
			"        // We find the maximum of depth[u] - 2 * depth[x] + depth[v] where u, x, v occur in order in the Euler tour.",
			"        pair<int, int> u_max = {-1, -1};",
			"        pair<int, int> ux_max = {-1, -1};",
			"        pair<int, array<int, 2>> uxv_max = {-1, {-1, -1}};",
			" ",
			"        for (int node : euler) {",
			"            if (node < 0) break;",
			"            u_max = max(u_max, {depth[node], node});",
			"            ux_max = max(ux_max, {u_max.first - 2 * depth[node], u_max.second});",
			"            uxv_max = max(uxv_max, {ux_max.first + depth[node], {ux_max.second, node}});",
			"        }",
			" ",
			"        return uxv_max;",
			"    }",
			" ",
			"    // Returns the center(s) of the tree (the midpoint(s) of the diameter).",
			"    array<int, 2> get_center() const {",
			"        pair<int, array<int, 2>> diam = get_diameter();",
			"        int length = diam.first, a = diam.second[0], b = diam.second[1];",
			"        return {get_kth_node_on_path(a, b, length / 2), get_kth_node_on_path(a, b, (length + 1) / 2)};",
			"    }",
			" ",
			"    // Note: returns -1 if `a` and `b` aren't connected.",
			"    int get_lca(int a, int b) const {",
			"        a = first_occurrence[a];",
			"        b = first_occurrence[b];",
			" ",
			"        if (a > b)",
			"            swap(a, b);",
			" ",
			"        return euler[rmq.query_index(a, b + 1)];",
			"    }",
			" ",
			"    bool is_ancestor(int a, int b) const {",
			"        return tour_start[a] <= tour_start[b] && tour_start[b] < tour_end[a];",
			"    }",
			" ",
			"    bool on_path(int x, int a, int b) const {",
			"        return (is_ancestor(x, a) || is_ancestor(x, b)) && is_ancestor(get_lca(a, b), x);",
			"    }",
			" ",
			"    int get_dist(int a, int b) const {",
			"        return depth[a] + depth[b] - 2 * depth[get_lca(a, b)];",
			"    }",
			" ",
			"    // Returns the child of `a` that is an ancestor of `b`. Assumes `a` is a strict ancestor of `b`.",
			"    int child_ancestor(int a, int b) const {",
			"        assert(a != b && is_ancestor(a, b));",
			" ",
			"        // Note: this depends on RMQ breaking ties by latest index.",
			"        int child = euler[rmq.query_index(first_occurrence[a], first_occurrence[b] + 1) + 1];",
			"        // assert(parent[child] == a && is_ancestor(child, b));",
			"        return child;",
			"    }",
			" ",
			"    int get_kth_ancestor(int a, int k) const {",
			"        if (k > depth[a])",
			"            return -1;",
			" ",
			"        int goal = depth[a] - k;",
			" ",
			"        while (heavy_root_depth[a] > goal)",
			"            a = heavy_root_parent[a];",
			" ",
			"        return tour_list[tour_start[a] + goal - depth[a]];",
			"    }",
			" ",
			"    int get_kth_node_on_path(int a, int b, int k) const {",
			"        int anc = get_lca(a, b);",
			"        int first_half = depth[a] - depth[anc];",
			"        int second_half = depth[b] - depth[anc];",
			" ",
			"        if (k < 0 || k > first_half + second_half)",
			"            return -1;",
			" ",
			"        if (k < first_half)",
			"            return get_kth_ancestor(a, k);",
			"        else",
			"            return get_kth_ancestor(b, first_half + second_half - k);",
			"    }",
			" ",
			"    // Note: this is the LCA of any two nodes out of three when the third node is the root.",
			"    // It is also the node with the minimum sum of distances to all three nodes (the centroid of the three nodes).",
			"    int get_common_node(int a, int b, int c) const {",
			"        // Return the deepest node among lca(a, b), lca(b, c), and lca(c, a).",
			"        int x = get_lca(a, b);",
			"        int y = get_lca(b, c);",
			"        int z = get_lca(c, a);",
			"        return x ^ y ^ z;",
			"    }",
			" ",
			"    // Given a subset of k tree nodes, computes the minimal subtree that contains all the nodes (at most 2k - 1 nodes).",
			"    // Returns a list of {node, parent} for every node in the subtree sorted by tour index. Runs in O(k log k).",
			"    // Note that all parents also appear as a node in the return value, and nodes[0].first is the compressed root.",
			"    vector<pair<int, int>> compress_tree(vector<int> nodes) const {",
			"        if (nodes.empty())",
			"            return {};",
			" ",
			"        auto &&compare_tour = [&](int a, int b) { return tour_start[a] < tour_start[b]; };",
			"        sort(nodes.begin(), nodes.end(), compare_tour);",
			"        int k = int(nodes.size());",
			" ",
			"        for (int i = 0; i < k - 1; i++)",
			"            nodes.push_back(get_lca(nodes[i], nodes[i + 1]));",
			" ",
			"        sort(nodes.begin() + k, nodes.end(), compare_tour);",
			"        inplace_merge(nodes.begin(), nodes.begin() + k, nodes.end(), compare_tour);",
			"        nodes.erase(unique(nodes.begin(), nodes.end()), nodes.end());",
			"        vector<pair<int, int>> result = {{nodes[0], -1}};",
			" ",
			"        for (int i = 1; i < int(nodes.size()); i++)",
			"            result.emplace_back(nodes[i], get_lca(nodes[i], nodes[i - 1]));",
			" ",
			"        return result;",
			"    }",
			"};",
			" ",
			" ",
			"template<typename T_vector>",
			"void output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {",
			"    if (start < 0) start = 0;",
			"    if (end < 0) end = int(v.size());",
			" ",
			"    for (int i = start; i < end; i++)",
			"        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');",
			"}"
		],
		"description": "Heavy light decomposition"
	},
	"binarylifting": {
		"prefix": "binaryliftingLCA",
		"body": [
			"   vector<vector<int > > bin(n + 1 , vector<int >(21 , 0));",
			"   vector<int> tin(n + 1) , tout(n + 1);",
			"   auto is_ancestor=[&](int u,int v)",
			"   {",
			"      if(tin[u] <= tin[v] && tout[u] >= tout[v])",
			"         return true;",
			"      return false;",
			"   };",
			"   auto LCA=[&](int u,int v)",
			"   {",
			"      if(is_ancestor(u , v))",
			"         return u;",
			"      if(is_ancestor(v , u))",
			"         return v;",
			"      int node = u;",
			"      for(int i = 20 ; i >= 0 ; --i) ",
			"      {",
			"         if(!is_ancestor(bin[node][i] , v)) ",
			"          node = bin[node][i]; ",
			"      }",
			"      return bin[node][0]; ",
			"   };"
		],
		"description": "binarylifting"
	}
}
