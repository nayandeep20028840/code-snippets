// {
// 	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
// 	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
// 	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
// 	// same ids are connected.
// 	// Example:
// 	// "Print to console": {
// 	// 	"prefix": "log",
// 	// 	"body": [
// 	// 		"console.log('$1');",
// 	// 		"$2"
// 	// 	],
// 	// 	"description": "Log output to console"
// 	// }
// }

{
	"kashi..": {
		"prefix": "main2",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"// Policy based data structures(PBDS) C++ STL",
			"// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			"// order_of_key(k): returns count of elements strictly smaller than k ",
			"// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // for pairs only define simply by ordered_set s",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"template<class T>using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree<pair<int , int > > s; for pairs",
			// "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>multisat;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ll                long long // typedef array<int , 2> p ; pair h ye",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			//"// #define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define inf               1000000000000000000 // 18 zero's",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const int MOD = 1000000007 ; // 998244353 ",
			"const int LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor",
			"int LCM(int a, int b){return (a / GCD(a, b) * b) ;}",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modpower(int x, int y){long long res = 1; x = x % MOD; while(y > 0){if(y&1) res = (res * (long long)x) % MOD; y = y >> 1; x = ((long long)x * (long long)x) % MOD ;}return res ;} ",
			"int modinv(int x){return modpower(x , MOD - 2) ;} ",
			"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i * i <= n; ++i){if(isPrime[i] == true){for(int j = 2 * i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;} // Time Complexity - O(n * sqrt(n) * log(n)) ",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;} // can be calculated in O(n) ",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			// "int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}",
			// "int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}",
			"",
			// "vector<vector<int > > adj ;",
			// "vector<int > visited ;",
			// "vector<int > value ;",
			// "",
			"bool solve(){",
			// "    //adj.assign(n + 1 , vector<int >());",
			// "    //visited.assign(n + 1 , false) ;",
			// "    //value.assign(n + 1 , 0) ;",
			"\t$1",
			"    return true ;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"//#ifndef ONLINE_JUDGE",
			"//    freopen(\"input.txt\",\"r\",stdin);",
			"//    freopen(\"output.txt\",\"w\",stdout);",
			"//    freopen(\"error.txt\", \"w\", stderr);",
			"//#endif ",
			"    int t ;",
			"    cin >> t ;  ",
			"    //int count = 1 ;",
			"",
			"    while (t--){",
			"        //cout << \"Case #\" << count << \": \";",
			"        if(solve()){",
			"            //count++ ;",
			"        }else{",
			"            // no ",
			"        }",
			"    }",
			"    return 0 ;",
			"}",
			"",
			"",
			"",
			// " // Assume worst when things happens to you. Do best when you can.",
			" // Talk is Cheap. Show me the code ",
			// " // Don't overthink and try to prove your idea. ",
			// "// Think twice, code once. // rab ne bana di jodi "
		],
		"description": "kashi.."
	},
	"kashi.": {
		"prefix": "main1",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			// "// Policy based data structures(PBDS) C++ STL",
			// "// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			// "// order_of_key(k): returns count of elements strictly smaller than k ",
			// "// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // for pairs only define simply by ordered_set s",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"template<class T>using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree<pair<int , int > > s; for pairs",
			// "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>multisat;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ll                long long",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			//"// #define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define inf               1000000000000000000 // 18 zero's",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const int MOD = 1000000007 ; // 998244353 ",
			"const int LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor ",
			"int LCM(int a, int b){return (a / GCD(a, b) * b) ;}",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modpower(int x, int y){long long res = 1; x = x % MOD; while(y > 0){if(y&1) res = (res * (long long)x) % MOD; y = y >> 1; x = ((long long)x * (long long)x) % MOD ;}return res ;} ",
			"int modinv(int x){return modpower(x , MOD - 2) ;} ",
			"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i * i <= n; ++i){if(isPrime[i] == true){for(int j = 2 * i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;} // Time Complexity - O(n * sqrt(n) * log(n)) ",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;} // can be calculated in O(n) ",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			// "int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}",
			// "int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}",
			"",
			// "vector<vector<int > > adj ;",
			// "vector<int > visited ;",
			// "vector<int > value ;",
			// "",
			"bool solve(){",
			// "    //adj.assign(n + 1 , vector<int >());",
			// "    //visited.assign(n + 1 , false) ;",
			// "    //value.assign(n + 1 , 0) ;",
			"\t$1",
			"    return true ;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"//#ifndef ONLINE_JUDGE",
			"//    freopen(\"input.txt\",\"r\",stdin);",
			"//    freopen(\"output.txt\",\"w\",stdout);",
			"//    freopen(\"error.txt\", \"w\", stderr);",
			"//#endif ",
			"    int t = 1 ;",
			"",
			"    while (t--){",
			"        //cout << \"Case #\" << count << \": \";",
			"        if(solve()){",
			"            ",
			"        }else{",
			"            ",
			"        }",
			"    }",
			"    return 0 ;",
			"}",
			"",
			"",
			"",
			"",
			" // Talk is Cheap. Show me the code ",
			""
		],
		"description": "kashi."
	},
	"jaishrimahakal": {
		"prefix": "leetcode",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			// "// Policy based data structures(PBDS) C++ STL",
			// "// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			// "// order_of_key(k): returns count of elements strictly smaller than k ",
			// "// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; // for pairs only define simply by ordered_set s",
			"typedef tree<pair<int, int>, null_type, less_equal<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
			"template<class T>using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree<pair<int , int > > s; for pairs",
			// "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>multisat;",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x)",
			"#endif",
			"",
			"void _print(long long t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(long double t) {cerr << t;}",
			"",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			//"// #define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << endl;",
			"#define no                cout << \"NO\" << endl;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<endl;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<endl; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<endl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<endl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define inf               1000000000000000000 // 18 zero's",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9",
			"#define nl                \"\\n\"",
			"",
			"const int MOD = 1000000007 ; // 998244353 ",
			"const int LOG = 21 ;",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) ; // a random number generator (RNG) using the Mersenne Twister algorithm, specifically the mt19937 engine. The purpose of an RNG is to generate a sequence of random numbers.",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor",
			"int LCM(int a, int b){return (a / GCD(a, b) * b) ;}",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modpower(int x, int y){long long res = 1; x = x % MOD; while(y > 0){if(y&1) res = (res * (long long)x) % MOD; y = y >> 1; x = ((long long)x * (long long)x) % MOD ;}return res ;} ",
			"int modinv(int x){return modpower(x , MOD - 2) ;} ",
			"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.S != b.S){return a.S < b.S ;}return a.F > b.F ;}",
			"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i <= n; ++i){if(isPrime[i] == true){for(int j = 2*i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;}",
			"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;}",
			"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}",
			"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder",
			"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			// "int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}",
			// "int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}",
			"",
			"/* //------------------------------------------------------- Template Ends. */",
			"",
			"",
			"",
			""
		],
		"description": "jaishrimahakal"
	},
	"wow": {
		"prefix": "nayan",
		"body": [
			"function<void(int,int)> func=[&](int child,int parent)->void{",
			"\t$1",
			"};"
		],
		"description": "wow"
	},
	"StressTesting": {
		"prefix": "stresstesting",
		"body": [
			"int rnd(int a, int b){",
			"    return a + rand() % (b - a + 1);",
			"}",
			"int generator(){",
			"    // This function acts as a generator.",
			"    int w = rnd(1, 100);",
			"    return w;",
			"}",
			"string solve(int w){",
			"    // This function acts as the WA solution to test.",
			"    if(w%2==0)return \"YES\";",
			"    return \"NO\";",
			"}",
			"",
			"string bruteForce(int w){",
			"    // This function acts as the brute force solution.",
			"    for(int i=1;i<w;i++){",
			"        int j = w - i;",
			"        if(i%2==0 && j%2==0)return \"YES\";",
			"    }",
			"    return \"NO\";",
			"}",
			"void check(int w, string myAnswer, string correctAnswer){",
			"    // This function acts as the checker.",
			"    if(myAnswer == correctAnswer)return;",
			"    cout<<\"Found the WA test\"<<endl;",
			"    cout<<\"W = \"<<w<<endl;",
			"    cout<<\"myAnswer = \"<<myAnswer<<endl;",
			"    cout<<\"correctAnswer = \"<<correctAnswer<<endl;",
			"    exit(0);",
			"}",
			"int main() {",
			"    for(int i=1;;i++){",
			"        int w = generator();",
			"        string myAnswer = solve(w);",
			"        string correctAnswer = bruteForce(w);",
			"        check(w, myAnswer, correctAnswer);",
			"        cout<<\"Passed test: \"<<i<<endl;",
			"    }",
			"}"
		],
		"description": "StressTesting"
	},
	"deadlypillow": {
		"prefix": "deadlypillowncr",
		"body": [
			"int F[N], iF[N]; // Don't forget to change the value of N. factorial,Inverse Factorial Array",
			"// if you want to use without any mod than mod will be INF ",
			"",
			"int fast(int b, int e) {",
			"    int res = 1;",
			"    for (; e; e >>= 1, b = b * b % MOD)",
			"        if (e & 1)",
			"            res = res * b % MOD;",
			"    return res;",
			"}",
			"",
			"void init() {",
			"    F[0] = 1 ;",
			"    for(int i = 1 ; i < N ; ++i) F[i] = (F[i - 1] * i) % MOD;",
			"    iF[N - 1] = fast(F[N - 1] , MOD - 2) ; // it finds the inverse of F[N - 1] ",
			"    for (int i = N - 2 ; i >= 0 ; --i)",
			"        iF[i] = iF[i + 1] * (i + 1) % MOD ;",
			"}",
			"",
			"int NCR(int n, int r) {",
			"    if (r > n || r < 0)",
			"        return 0 ;",
			"    return iF[r] * F[n] % MOD * iF[n - r] % MOD ;",
			"}"
		],
		"description": "deadlypillow"
	},
	"ababbaba":{
		"prefix": "concepts",
		"body": [
		"//lower bound of p mtlb p se just badda ya uske equal agr lower bound ke it ko -- kra to just chota milega agr ye it s.end hai to mtlb vo element ya usse badda element nhi hai aur agr ye sbegin hai to uss element se chota element nhi hai",
		"//upper bound of p mtlb p se just badda uske equal nhi agr ye s.end() hai to mtlb uss element se badda element nhi hai aur agr iske it ko it-- kre to uss p se just chota ya uske equal element milega but agr ye s.begin hai to usme koi bhi element p ya p se chota nhi hai",
		"If Inserting / pushing elements in a set / priority_queue it takes (nlog n) time complexity.",
		"Never use map< pair<int , int > , int > mp instead use vector<unordered_map<int , int > > v(n)",
		],
		"description": "ababbaba"
	},
	"heapiFy": {
		"prefix": "heapiFy",
		"body": [
			"    class minHeap {",
			"public:",
			"",
			"    // Constructor for the class.",
			"    vector<int > heap ;",
			"    int siz , cap ;",
			"    minHeap(int n) {",
			"        heap.resize(n) ;",
			"        siz = 0 ;",
			"        cap = n ;",
			"    }",
			"",
			"    void heapiFy(int i){",
			"        int smallest = i ;",
			"        int left = 2*i + 1 ;",
			"        int right = 2*i + 2 ;",
			"        if(left < siz && heap[left] < heap[smallest]){",
			"            smallest = left ;",
			"        }",
			"        if(right < siz && heap[right] < heap[smallest]){",
			"            smallest = right ;",
			"        }",
			"        if(smallest != i){",
			"            swap(heap[i] , heap[smallest]) ;",
			"            heapiFy(smallest) ;",
			"        }",
			"    }",
			"    // Implement the function to remove minimum element.",
			"    int extractMinElement() {",
			"        // Write you code here.",
			"        if(siz == 0){",
			"            return -1 ;",
			"        }",
			"        int ans = heap[0] ;",
			"        swap(heap[0] , heap[siz - 1]) ;",
			"        siz-- ;",
			"        heapiFy(0) ;",
			"        return ans ;",
			"    }",
			"",
			"    // Implement the function to delete an element.",
			"    void deleteElement(int ind) {",
			"        // Write you code here.",
			"        if(ind >= siz){",
			"            return ;",
			"        }",
			"        swap(heap[ind] , heap[siz - 1]) ;",
			"        siz-- ;",
			"        heapiFy(ind) ;",
			"",
			"    }",
			"",
			"    // Implement the function to insert 'val' in the heap.",
			"    void insert(int val) {",
			"        // Write you code here.",
			"        if(siz == cap){",
			"            return ;",
			"        }",
			"        heap[siz] = val ;",
			"        int i = siz ;",
			"        while(i > 0 && heap[(i - 1)/2] > heap[i]){",
			"            swap(heap[(i - 1)/2] , heap[i]) ;",
			"            i = (i - 1)/2 ;",
			"        }",
			"        siz++ ;",
			"",
			"    }",
			"};",
			"",
			"void btup heapiFy(vector<int > &a , int n){ // min heap not for max heap",
			"    for(int i = n / 2 - 1 ; i >= 0 ; --i){",
			"        int item = a[i] ;",
			"        int child = 2 * i + 1 ;",
			"        while(child <= n - 1){",
			"            if(child + 1 <= n - 1 && a[child + 1] < a[child]){ // for max heap a[child + 1] > a[child]",
			"                child++ ;",
			"            }",
			"            if(a[child] < item){ // for max heap a[child] > item",
			"                a[i] = a[child] ;",
			"            }",
			"            else{",
			"                break ;",
			"            }",
			"            child = 2 * child + 1 ; ",
			"        }",
			"        a[i] = item ;",
			"    }",
			"}",
			"",
			"void tpdn heapiFy(vector<int > &a , int n){ // min heap not for max heap",
			"    for(int i = 1 ; i <= n - 1 ; ++i){",
			"        int key = a[i] ;",
			"        int child = i ;",
			"        int parent = (child - 1) / 2 ;",
			"        while(c > 0 && a[parent] < key){ // for max heap a[parent] > key and for min heap a[parent] < key",
			"            a[child] = a[parent] ;",
			"            child = parent ;",
			"            parent = (child - 1) / 2 ;",
			"            a[child] = key ;",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "heapiFy"
	},
	"lps-longestprefixsuffix": {
		"prefix": "lps-longestprefixsuffix",
		"body": [
			"// LPS (Longest Prefix Suffix) Algorithm:",
			"",
			"// Purpose: The LPS algorithm is primarily used to find the length of the longest proper prefix which is also a proper suffix of a given string for each position in the string.",
			"",
			"// Key Concept: It calculates an array where each element at index i represents the length of the longest proper prefix of the substring ending at position i that is also a proper suffix of the substring.",
			"",
			"// Usage: It is used as a building block in other string matching algorithms, like the KMP algorithm.",
			"",
			"vector<int > longestprefixsuffix(string s){",
			"    int n = s.size();",
			"    vector<int > lps(n , 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            len++ ;  ",
			"            lps[i] = len ;",
			"            i++ ;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1] ;",
			"            }else{",
			"                lps[i] = 0 ;",
			"                i++ ;",
			"            }",
			"        }",
			"    }",
			"    return lps ;",
			"}"
		],
		"description": "lps-longestprefixsuffix"
	},
	"z_function": {
		"prefix": "z_function",
		"body": [
			"// Z Algorithm:",
			"",
			"// Purpose: The Z Algorithm is designed to efficiently find all occurrences of a pattern within a text.",
			"",
			"// Key Concept: It calculates an array where each element at index i represents the length of the longest substring starting from the ith position that matches the prefix of the text.",
			"",
			"// Usage: The Z Algorithm is used as a standalone linear time string matching algorithm. It is particularly useful when you need to find all occurrences of a pattern in a text.",
			"",
			"// Implementation: The Z Algorithm involves maintaining an interval [l, r] such that the substring [l, r] matches the prefix of the text, and it efficiently computes the Z values for each position in the text.",
			"",
			"vector<int > z_function(string s){",
			"    int n = s.size() ;",
			"    int i = 1 ;",
			"    int l = 0 ;",
			"    int r = 0 ;",
			"    vector<int > z(n , 0) ;",
			"    while(i < n){",
			"        if(i <= r){",
			"            // copy because in range ",
			"            z[i] = min(z[i - l] , r - i + 1) ;",
			"        }",
			"        // our basic logic goes here ",
			"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]){",
			"            z[i]++ ;",
			"        }",
			"        if(i + z[i] - 1 > r){",
			"            // update the range",
			"            l = i ;",
			"            r = i + z[i] - 1 ;",
			"        }",
			"        i++ ;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "z_function"
	},
	"kmp": {
		"prefix": "kmp",
		"body": [
			"vector<int > longestprefixsuffix(string s){",
			"    int n = s.size();",
			"    vector<int > lps(n , 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            len++ ;  ",
			"            lps[i] = len ;",
			"            i++ ;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1] ;",
			"            }else{",
			"                lps[i] = 0 ;",
			"                i++ ;",
			"            }",
			"        }",
			"    }",
			"    return lps ;",
			"}",
			"",
			"/*",
			"",
			"KMP (Knuth-Morris-Pratt) Algorithm:",
			"",
			"Purpose: KMP is a more comprehensive algorithm used to efficiently search for a pattern within a text while avoiding unnecessary character comparisons.",
			"",
			"Key Concept: It constructs a prefix array (also known as the LPS array) for the pattern and uses this array to skip characters in the text during the search, reducing the number of character comparisons.",
			"",
			"Advantages: KMP is known for its linear time complexity, making it efficient for large texts.",
			"",
			"Usage: It's widely used in text searching, text processing, and string matching applications.",
			"",
			"",
			"*/",
			"",
			"int kmp(string s, string p){",
			"    int plen = p.size() ; // pattern length // we have to find this pattern in the string ",
			"    int slen = s.size() ; // string length ",
			"    vector<int > pattern_lps = longestprefixsuffix(p) ;",
			"    int len = 0 ;",
			"    int i = 0 ;",
			"    int cnt = 0 ;",
			"    while(i < slen){",
			"        if(s[i] == p[len]){",
			"            len++ ;",
			"            i++ ;",
			"        }",
			"        else{",
			"            if(len != 0){",
			"                len = pattern_lps[len - 1] ;",
			"            }else{",
			"                i++ ;",
			"            }",
			"        }",
			"        if(len == plen){",
			"            cnt++ ;",
			"            len = pattern_lps[len - 1] ;",
			"        }",
			"    }",
			"    return cnt ; // cnt is the number of times the pattern occurs in the string s ",
			"}"
		],
		"description": "kmp"
	},
	"rabin karp": {
		"prefix": "rabin karp",
		"body": [
			"vector<int> rabin_karp(string const& s, string const& t) {",
			"    const int p = 31;",
			"    const int m = 1e9 + 9;",
			"    int S = s.size(); // pattern size // we need to find this pattern in the text ",
			"    int T = t.size();",
			"",
			"    // Precompute powers of p",
			"    vector<long long> p_pow(max(S, T));",
			"    p_pow[0] = 1;",
			"    for (int i = 1; i < (int)p_pow.size(); i++) {",
			"        p_pow[i] = (p_pow[i-1] * p) % m;",
			"    }",
			"",
			"    // Compute hash values for the entire text",
			"    vector<long long> h(T + 1, 0);",
			"    for (int i = 0; i < T; i++) {",
			"        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m;",
			"    }",
			"",
			"    // Compute hash value for the pattern",
			"    long long h_s = 0;",
			"    for (int i = 0; i < S; i++) {",
			"        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m;",
			"    }",
			"",
			"    // Store occurrences",
			"    vector<int> occurrences;",
			"    for (int i = 0; i + S - 1 < T; i++) {",
			"        long long cur_h = (h[i + S] + m - h[i]) % m;",
			"        if (cur_h == h_s * p_pow[i] % m) {",
			"            occurrences.push_back(i);",
			"        }",
			"    }",
			"",
			"    return occurrences;",
			"}"
		],
		"description": "rabin karp"
	},
	"manacher": {
		"prefix": "manacher",
		"body": [
			"// USES - Longest Palindromic Substring , Pattern Matching:to find occurrences of a specific palindromic pattern within a given text.",
			"struct manacher {",
			"    vector<int > p ;",
			"    int n ;",
			"    void run_manacher(string s) {",
			"        // cout << s << endl ; ",
			"        int n = s.length() ;",
			"        p.resize(n) ;",
			"        int l = 1 ; // l and r are not inclusive ",
			"        int r = 1 ;",
			"        for(int i = 1 ; i < n ; ++i){",
			"            p[i] = max(0ll , min(p[l + r - i] , r - i)) ;",
			"            while(i - p[i] >= 0 && i + p[i] < n && s[i - p[i]] == s[i + p[i]]){",
			"                p[i]++ ;",
			"            }",
			"            if(i + p[i] > r){ // or",
			"                l = i - p[i] ;",
			"                r = i + p[i] ;",
			"            }",
			"        }",
			"        // for(auto &v : p){",
			"        //     cout << v << \" \" ;",
			"        // }",
			"        // cout << endl ;",
			"    }",
			"    void build(string s){ // so that every substring is odd length ",
			"        string t ;",
			"        for (auto it : s){",
			"            t += string(\"#\") + it ; // making every substring odd length ",
			"        }",
			"        run_manacher(t + \"#\") ;",
			"    }",
			"    // abbabba ",
			"    // cen = 1 , odd = 1 length = 1 ",
			"    // cen = 1 , odd = 0 length = 4 ",
			"    int getlongest(int cen, bool odd) {",
			"        int pos = 2 * cen + odd + 1 + (!odd) ;",
			"        return p[pos] - 1 ;",
			"    }",
			"    bool checkPal(int l, int r) {",
			"        if ((r - l + 1) <= getlongest((r + l) / 2, l % 2 == r % 2)) {",
			"            return 1 ;",
			"        }",
			"        return 0 ;  ",
			"    }",
			"} m;",
			"",
			"/*",
			"",
			"aba -->#a#b#a#",
			"abba -->#a#b#b#a#",
			"",
			"how to build manacher",
			"m.build(s) ;",
			"",
			"*/"
		],
		"description": "manacher"
	},
	"Template 4": {
		"prefix": "blackbox",
		"body": [
			"int blackbox(string &s) {",
			"    int n = s.size() ;",
			"    int hash = 0 ; ",
			"    int p = 1 ;",
			"    for(int i = 0 ; i < n ; ++i){",
			"        hash = (hash + ((s[i] - 'a' + 1) * p) % MOD) % MOD ;",
			"        p = (p * (int)31) % MOD ;",
			"    }",
			"}"
		],
		"description": "Template 4"
	},"string_hashing": {
		"prefix": "string_hashing",
		"body": [
			"ll kk[10] = {",
			"    89, ",
			"    101, ",
			"    189,",
			"    94,",
			"    621,",
			"    (ll)rng() % 1000 + 1051,",
			"    (ll)rng() % 2000 + 2761,",
			"    (ll)rng() % 4000 + 4441,",
			"    (ll)rng() % 8000 + 8111,",
			"    (ll)rng() % 16000 + 18883",
			"};",
			"",
			"ll primes[10] = {",
			"    533000401,",
			"    735632791,",
			"    776531419,",
			"    797003413,",
			"    1062599999,",
			"    1047899999,",
			"    1031999999, ",
			"    1027799999,",
			"    1018199999,",
			"    1000000007",
			"};",
			"",
			"struct string_hash {",
			"    int len;",
			"    ll mod, poly, inv;",
			"    vector<ll> prefix;",
			"    vector<ll> invs;",
			"    ",
			"    void init(int n, string s, ll k = 89, ll m = 1000000007) {",
			"        mod = m;",
			"        poly = k;",
			"        prefix = vector<ll>(n);",
			"        invs = vector<ll>(n);",
			"",
			"        invs[0] = 1;",
			"        inv = minv(k);",
			"        for (int i = 1; i < n; i++) {",
			"            invs[i] = (invs[i - 1] * inv) % mod;",
			"        }",
			"",
			"        ll x = 1;",
			"        prefix[0] = (s[0] - '0' + 1);",
			"        for (int i = 1; i < n; i++) {",
			"            x = (x * k) % mod;",
			"            prefix[i] = (prefix[i - 1] + x * (s[i] - '0' + 1)) % mod;",
			"        }",
			"",
			"        len = n;",
			"    }",
			"",
			"    void extend(string next) {",
			"        int x = next.length();",
			"        for (int i = 0; i < x; i++) {",
			"            invs.push_back((invs[i + len - 1] * inv) % mod);",
			"        }",
			"",
			"        ll p = mpow(poly, len - 1);",
			"        for (int i = 0; i < x; i++) {",
			"            p = (p * poly) % mod;",
			"            prefix.push_back((prefix[i + len - 1] + p * (next[i] - '0' + 1)) % mod);",
			"        }",
			"",
			"        len += x;",
			"    }",
			"    ",
			"    void kill(int sz) { // remove last [sz] characters",
			"        for (int i = 0; i < sz; i++) {",
			"            invs.pop_back();",
			"            prefix.pop_back();",
			"        }",
			"        ",
			"        len -= sz;",
			"    }",
			"",
			"    ll get_hash(int left, int right) {",
			"        if (left == 0) return prefix[right];",
			"        return ((prefix[right] - prefix[left - 1] + mod) * invs[left]) % mod;",
			"    }",
			"",
			"    ll mpow(ll base, ll exp) {",
			"        ll res = 1;",
			"        while (exp) {",
			"            if (exp % 2 == 1) {",
			"                res = (res * base) % mod;",
			"            }",
			"            exp >>= 1;",
			"            base = (base * base) % mod;",
			"        }",
			"        return res;",
			"    }",
			"    ll minv(ll base) {",
			"        return mpow(base, mod - 2);",
			"    }",
			"};",
			"",
			"    template<int K>",
			"    struct multihash {",
			"    string_hash sh[K];",
			"",
			"    void init(int n, string s) {",
			"        for (int i = 0; i < K; i++) {",
			"            sh[i].init(n, s, kk[9 - i], primes[9 - i]);",
			"        }",
			"    }",
			"    ",
			"    void extend(string s) {",
			"        for (int i = 0; i < K; i++) {",
			"            sh[i].extend(s);",
			"        }",
			"    }",
			"    ",
			"    void kill(int x) {",
			"        for (int i = 0; i < K; i++) {",
			"            sh[i].kill(x);",
			"        }",
			"    }",
			"",
			"    vector<ll> get_hash(int l, int r) {",
			"        vector<ll> ret(K);",
			"        for (int i = 0; i < K; i++) {",
			"            ret[i] = sh[i].get_hash(l, r);",
			"        }",
			"        return ret;",
			"    }",
			"",
			"    bool compare(vector<ll> a, vector<ll> b) {",
			"        for (int i = 0; i < K; i++) {",
			"            if (a[i] != b[i]) return 0;",
			"        }",
			"        return 1;",
			"    }",
			"};"
		],
		"description": "string_hashing"
	},
	// "vector<unordered_map<int , int > >": {
	// 	"prefix": "gp_hash_table<int, ll> dp[N];",
	// 	"body": [
	// 		"struct custom_hash {",
	// 		"  static uint64_t splitmix64(uint64_t x) {",
	// 		"    x += 0x9e3779b97f4a7c15;",
	// 		"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
	// 		"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
	// 		"    return x ^ (x >> 31);",
	// 		"  }",
	// 		"  size_t operator()(uint64_t x) const {",
	// 		"    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
	// 		"    return splitmix64(x + FIXED_RANDOM);",
	// 		"  }",
	// 		"};"
	// 	],
	// 	"description": "vector<unordered_map<int , int > >"
	// },
	"Template 5": {
		"prefix": "interactive..interactor",
		"body": [
			"struct Interactor{",
			"    int hiddenNumber ;",
			"    int limitQueries = 0 ;",
			"    int queries = 0 ;",
			"    Interactor(){ // it is constructor of this struct",
			"        hiddenNumber = getRandomNumber(1 , 1000) ; // initialize this variable called hiddenNumber",
			"        limitQueries = 100 ; // limit by your self for debuging.",
			"    }",
			"    char query(int x , bool printOutput){",
			"        if(queries >= limitQueries){",
			"            cout << \"You have exceeded the number of queries\" << endl ;",
			"        }else{",
			"            queries ++ ;",
			"        }",
			"        // assert(queries < limitQueries) // Your code stops here if this is false give out a runtime error.",
			"        char ans = '=' ;",
			"        if(x > hiddenNumber){",
			"            ans = '>' ;",
			"        }",
			"        else if(x < hiddenNumber){",
			"            ans = '<' ;",
			"        }",
			"        else{",
			"            ans = '=' ;",
			"        }",
			"        if(printOutput){",
			"            cout << ans << endl ;",
			"        }",
			"        return ans ;",
			"    }",
			"    bool correctOutput(int x){",
			"        if(x == hiddenNumber){",
			"            cout << \"Passed for \" << x << endl ;",
			"        }else{",
			"            cout << \"Failed\" << endl ;",
			"            cout << \"Hidden Number: \" << hiddenNumber << endl ;",
			"            cout << \"Output Given: \" << x << endl ;",
			"        }",
			"        return x == hiddenNumber ;",
			"    }",
			"}"
		],
		"description": "Template 5"
	},
	"BIT": {
		"prefix": "bit",
		"body": [
			"template<class T>",
			"struct BIT{",
			"    int n ;",
			"    vector<T> tree ;",
			"    BIT(int __n = 0) : n(__n + 1){",
			"        tree = vector<T>(n, 0);",
			"    }",
			"    BIT(const vector<T> &a, int __n) : n(__n + 1){",
			"        tree.resize(n);",
			"        for(int i = 0 ; i < n - 1 ; i++) {",
			"            update(i, a[i]);",
			"        }",
			"    }",
			"    void update(int i, T delta){ // point update // Using ETT(Euler Tour Tree), this is equivalent to a range update.",
			"        for(i++ ; i < n ; i += (i & -i))    tree[i] += delta;",
			"    }",
			"    T psum(int i){ // prefix sum // point query",
			"        T sum = 0;",
			"        for(i++ ; i > 0 ; i -= (i & -i))    sum += tree[i];",
			"        return sum;",
			"    }",
			"    T rsum(int i, int j){ // range query",
			"        return (psum(j) - psum(i-1));",
			"    }",
			"};",
			"",
			"/*",
			"",
			"how to access the struct of BIT",
			"BIT<int> bit(n + 5);",
			"",
			"*/"
		],
		"description": "BIT"
	},
	"mosalgorithm": {
		"prefix": "mosalgorithm",
		"body": [
		  "const int NN = 2e5+1 ; // warning don't exceed 1e7+1e6 ;",
			"int block_size ;",
			"vector<int > v(NN) ;",
			"vector<int > freq(NN) ;",
			"int answer = 0 ;",
			"",
			"struct Query { // name of the structure",
			"    int l , r , idx ;",
			"",
			"    Query(int _l , int _r , int _idx) : l(_l) , r(_r) , idx(_idx) { // These lines initialize the member variables with the values passed as arguments to the constructor.",
			"",
			"    } // defining a constructor for a structure. The constructor initializes three member variables: l, r, and idx, presumably within the context of that structure.",
			"",
			"    bool operator<(Query other) const // sort the queries",
			"    {",
			"        return make_pair(l / block_size, r) <            // jaadu",
			"                make_pair(other.l / block_size, other.r);",
			"    }",
			"};",
			"",
			"void remove(int idx) { // TODO: remove value at idx from data structure",
			"    ",
			"}  ",
			"void add(int idx) {  // TODO: add value at idx from data structure",
			"    ",
			"}    ",
			"int get_answer() { // TODO: extract the current answer of the data structure",
			"    return answer ;",
			"}  ",
			"",
			"vector<int > mo_s_algorithm(vector<Query > queries) {",
			"    vector<int > answers(queries.size()) ;",
			"    sort(queries.begin(), queries.end()) ;",
			"",
			"    // TODO: initialize data structure",
			"",
			"    int cur_l = 0 ;",
			"    int cur_r = -1 ;",
			"    // invariant: data structure will always reflect the range [cur_l, cur_r]",
			"    for (Query q : queries) {",
			"        while (cur_l > q.l) {",
			"            cur_l-- ;",
			"            add(cur_l) ;",
			"        }",
			"        while (cur_r < q.r) {",
			"            cur_r++ ;",
			"            add(cur_r) ;",
			"        }",
			"        while (cur_l < q.l) {",
			"            remove(cur_l) ;",
			"            cur_l++ ;",
			"        }",
			"        while (cur_r > q.r) {",
			"            remove(cur_r) ;",
			"            cur_r-- ;",
			"        }",
			"        answers[q.idx] = get_answer() ;",
			"    }",
			"    return answers ;",
			"}",
			"",
			"/*",
			"",
			"    Time complexity : very important O(Q * logQ) for sorting +(plus) Q * root(n)",
			"    for all query combined maximum range covered is root(n)",
			"",
			"    define block_size as",
			"    {",
			"        int sq = sqrtl(n) ;",
			"        block_size = sqrtl(n) + (n % sq == 0 ? 0 : 1) ;",
			"    }",
			"",
			"    vector<Query > queries ;",
			"    vector<int > got_it = mo_s_algorithm(queries) ;",
			"    for(int i = 0 ; i < q ; ++i){",
			"        cout << got_it[i] << nl ;",
			"    }",
			"",
			"*/"
		],
		"description": "mosalgorithm"
	},
	"segmenttree": {
		"prefix": "segmenttree",
		"body": [
			"struct SegmentTree {",
			"    struct Node {",
			"        int val ; // may change",
			"        Node() { // Identity element",
			"            val = 0 ;    // may change // warning it is for query answers only what should be the output answer ",
			"            // val = power(2 , 30) - 1 ;    // may change",
			"            // val = INF ;    // may change",
			"            // val = -INF ;    // may change",
			"        }",
			"        Node(int p1) {  // Actual Node",
			"            val = p1 ; // may change",
			"        }",
			"        void merge(Node &l , Node &r) { // Merge two child nodes",
			"            val = (l.val + r.val) ;  // may change",
			"        }",
			"    };",
			"    struct Update { // note if mentioned about update then only it is used ",
			"        int val ; // may change",
			"        Update(int p1) { // Actual Update",
			"            val = p1 ; // may change",
			"        }",
			"        void apply(Node &a) { // apply update to given node",
			"            a.val = val ; // may change",
			"        }",
			"    };",
			"",
			"    vector<Node > tree ; // it will change according to the node ",
			"    vector<int > arr ; // type may change ",
			"    int n , s ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    SegmentTree(int array_len, vector<int> &a) { // change if type updated",
			"        arr = a ;",
			"        n = array_len ; ",
			"        s = 1 ;",
			"        while(s < 2 * n) {",
			"            s = (s << 1);",
			"        }",
			"        tree.resize(s); ",
			"        fill(all(tree), Node()) ;",
			"        build(0 , n - 1 , 1) ;",
			"    }",
			"    void build(int start, int end, int index)  // Never change this",
			"    {",
			"        if(start == end){",
			"            tree[index] = Node(arr[start]) ; // may change ",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(start, mid, 2 * index) ;",
			"        build(mid + 1, end, 2 * index + 1) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void update(int start, int end, int index, int query_index, Update &u)  // Never Change this",
			"    {",
			"        if(start == end){",
			"            u.apply(tree[index]) ;",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        if(mid >= query_index)",
			"            update(start, mid, 2 * index, query_index, u);",
			"        else",
			"            update(mid + 1 , end , 2 * index + 1 , query_index, u) ;",
			"        tree[index].merge(tree[2 * index], tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int start, int end, int index, int left, int right) { // may change ",
			"        if(start > right || end < left) // may change // both if statements can be removed",
			"            return Node() ;",
			"        if(start >= left && end <= right) // may change // both if statements can be removed",
			"            return tree[index] ; ",
			"        int mid = (start + end) / 2 ; ",
			"        Node l , r , ans ; ",
			"        l = query(start , mid , 2 * index , left, right) ; ",
			"        r = query(mid + 1 , end , 2 * index + 1 , left , right) ; ",
			"        ans.merge(l , r) ; ",
			"        return ans ; ",
			"    }",
			"    void make_update(int index, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val); // may change",
			"        update(0 , n - 1 , 1 , index , new_update) ;",
			"    }",
			"    Node make_query(int left , int right) { // may change",
			"        return query(0 , n - 1 , 1 , left , right) ; // may change",
			"    }",
			"    int first(){",
			"        return tree[1].val ;",
			"    }",
			"    void output(){",
			"        for(int i = 1 ; i < s ; ++i){",
			"            cout << tree[i].val <<  \" \" ;",
			"        }",
			"        cout << endl ;",
			"    }",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"SegmentTree st(n, arr);",
			"",
			"*/"
		],
		"description": "segmenttree"
	},
	"lazysegmenttree": {
		"prefix": "lazysegmenttree",
		"body": [
			"static const int Mod = 1e9 + 7;",
			"    struct Node{",
			"        long long sum;",
			"        long long sq;",
			"        Node(){",
			"            sum = 0;",
			"            sq = 0;",
			"        }",
			"        Node(long long _data){",
			"            sum = _data;",
			"            sq = _data * _data;",
			"",
			"        }",
			"        void apply(int start, int end, long long val){",
			"            sq += (end - start + 1) * (val * val) + 2 * val * sum;",
			"            sum += (end - start + 1) * val;",
			"            sq %= Mod;",
			"            sum %= Mod;",
			"        }",
			"        void update(Node& left, Node& right){",
			"            sum = (left.sum + right.sum) % Mod;",
			"            sq = (left.sq + right.sq) % Mod;",
			"        }",
			"    };",
			"",
			"    struct LazySegmentTree{",
			"        vector<Node>seg;",
			"        vector<long long>arr;",
			"        vector<long long>lazy;",
			"        int N;",
			"        LazySegmentTree(int _N, vector<long long> &_arr){",
			"            arr = _arr;",
			"            N = _N;  ",
			"            seg.resize(4 * N);",
			"            build(1, 0, N - 1);",
			"            lazy.assign(4 * N, 0);",
			"        }",
			"",
			"        void build(int index, int start, int end){",
			"            if(start == end){",
			"                seg[index] = Node(arr[start]);",
			"                return ;",
			"            }",
			"            int mid = (start + end) / 2;",
			"            build(2 * index, start, mid);",
			"            build(2 * index + 1, mid + 1, end);",
			"            seg[index].update(seg[2 * index], seg[2 * index + 1]);",
			"        }",
			"",
			"        void inner_update(int index, int start, int end, int update_start, int update_end, int val){",
			"            propagate(index, start, end);",
			"            if(end < update_start || update_end < start){",
			"                return ;",
			"            }",
			"            if(update_start <= start && end <= update_end){",
			"                lazy[index] += val;",
			"                propagate(index, start, end);",
			"                return;",
			"            }",
			"            int mid = (start + end) / 2;",
			"            inner_update(index * 2, start, mid, update_start, update_end, val);",
			"            inner_update(index * 2 + 1, mid + 1, end, update_start, update_end, val);",
			"            seg[index].update(seg[2 * index], seg[index * 2 + 1]);",
			"        }",
			"",
			"        Node inner_query(int index, int start, int end, int q_start, int q_end){",
			"            propagate(index, start, end);",
			"",
			"            if(end < q_start || q_end < start){",
			"                return Node();",
			"            } ",
			"            if(q_start <= start && end <= q_end){",
			"                return seg[index];",
			"            }",
			"            int mid = (start + end) / 2;",
			"            Node left = inner_query(index * 2, start, mid, q_start, q_end);",
			"            Node right = inner_query(index * 2 + 1, mid + 1, end, q_start, q_end);",
			"            Node ans = Node();",
			"            ans.update(left, right);",
			"            return ans;",
			"        }",
			"",
			"        void propagate(int index, int start, int end){",
			"            if(lazy[index] == 0) return;",
			"            seg[index].apply(start, end, lazy[index]);",
			"",
			"            if(start != end){",
			"                lazy[2 * index] += lazy[index];",
			"                lazy[2 * index + 1] += lazy[index];",
			"            }",
			"            else{",
			"                arr[start] += lazy[index];",
			"            }",
			"            lazy[index] = 0;",
			"        }",
			"",
			"        void update(int update_start, int update_end, int val){",
			"            inner_update(1, 0, N - 1, update_start, update_end, val);",
			"        }",
			"",
			"        Node query(int q_start, int q_end){",
			"            return inner_query(1, 0, N - 1, q_start, q_end);",
			"        }",
			"",
			"    };"
		],
		"description": "lazysegmenttree"
	},
	"lazysegmenttree": {
		"prefix": "priyansh_lazysegmenttree",
		"body": [
			"// Lazy Segment Tree with Range Updates and Range Queries",
			"// Supports multiple Segment Trees with just a change in the Node and Update",
			"// Very few changes required everytime",
			"",
			"",
			"struct LazySGT {",
			"    struct Node {",
			"        int val ; // may change",
			"        // int sum ; // may change",
			"        // int sq ; // may change",
			"        Node() { // Identity element",
			"            val = 0 ;    // may change // warning it is for query answers only what should be the output answer ",
			"            // val = power(2 , 30) - 1 ;    // may change",
			"            // val = INF ;    // may change",
			"            // val = -INF ;    // may change",
			"        }",
			"        Node(int p1) {  // Actual Node",
			"            val = p1 ; // may change",
			"        }",
			"        void merge(Node &l , Node &r) { // Merge two child nodes",
			"            val = (l.val + r.val) ;  // may change",
			"        }",
			"    };",
			"",
			"    struct Update {",
			"        int val ; // may change",
			"        // int sum ; // may change",
			"        // int sq ; // may change",
			"        Update(){ // Identity update",
			"            val = 0 ;",
			"        }",
			"        Update(int val1) { // Actual Update",
			"            val = val1 ;",
			"        }",
			"        void apply(Node &a, int start, int end) { // apply update to given node",
			"            a.val = val * (end - start + 1) ; // may change",
			"            // a.val += val * (end - start + 1) ; // may change",
			"            // a.val = val ; // may change",
			"            // a.val += val ; // may change",
			"        }",
			"        void combine(Update& new_update , int start , int end){",
			"            val = new_update.val ;",
			"            // val += new_update.val ;",
			"        }",
			"    };",
			"",
			"    vector<Node > tree ; // no change",
			"    vector<bool > lazy ; // no change",
			"    vector<Update > updates ; // no change",
			"    vector<int > arr ; // type may change",
			"    int n ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    LazySGT(int array_len , vector<int > &a) { // change if type updated",
			"        arr = a ;",
			"        n = array_len ;",
			"        sz = 1 ;",
			"        while(sz < 2 * n){",
			"            sz = (sz << 1) ;",
			"        }",
			"        tree.resize(sz) ; fill(all(tree) , Node()) ;",
			"        lazy.resize(sz) ; fill(all(lazy) , false) ;",
			"        updates.resize(sz) ; fill(all(updates) , Update()) ;",
			"        build(0 , n - 1 , 1) ;",
			"    }",
			"    void build(int start , int end , int index) { // Never change this",
			"        if (start == end)   {",
			"            tree[index] = Node(arr[start]) ; // no changes",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(start , mid, 2 * index) ;",
			"        build(mid + 1 , end , 2 * index + 1) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void pushdown(int index , int start , int end){",
			"        if(lazy[index]){",
			"            int mid = (start + end) / 2 ; ",
			"            apply(2 * index , start , mid , updates[index]) ;",
			"            apply(2 * index + 1 , mid + 1 , end , updates[index]) ;",
			"            updates[index] = Update() ;",
			"            lazy[index] = 0 ;",
			"        }",
			"    }",
			"    void apply(int index , int start , int end , Update& u){",
			"        if(start != end){",
			"            lazy[index] = 1 ; // no changes",
			"            updates[index].combine(u , start , end) ; // it is applied on non array elements that is the parent elements on the array elements ",
			"        }",
			"        u.apply(tree[index] , start , end) ; // it is applied on one element only change according to the question ",
			"    }",
			"    void update(int start, int end, int index, int left, int right, Update &u) {  // Never Change this // O(logn) ",
			"        if(start > right || end < left)",
			"            return ;",
			"        if(start >= left && end <= right){",
			"            pushdown(index , start , end) ;",
			"            apply(index , start , end , u) ;",
			"            return ;",
			"        }",
			"        pushdown(index , start , end) ; // doing for both query and updates ",
			"        int mid = (start + end) / 2 ;",
			"        update(start , mid , 2 * index , left , right , u) ;",
			"        update(mid + 1 , end , 2 * index + 1 , left , right , u) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int start, int end, int index, int left, int right) { // Never change this",
			"        if (start > right || end < left)",
			"            return Node(); // warning it is for query answers only what should be the output answer",
			"        if (start >= left && end <= right){",
			"            pushdown(index , start , end) ;",
			"            return tree[index] ;",
			"        }",
			"        pushdown(index , start , end) ; // doing for both query and updates ",
			"        int mid = (start + end) / 2 ;",
			"        Node l , r , ans ;",
			"        l = query(start , mid , 2 * index , left , right) ;",
			"        r = query(mid + 1 , end , 2 * index + 1 , left , right) ;",
			"        ans.merge(l , r) ;",
			"        return ans ;",
			"    }",
			"    void make_update(int left, int right, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val) ; // may change",
			"        update(0 , n - 1 , 1 , left , right , new_update) ;",
			"    }",
			"    Node make_query(int left, int right) {",
			"        return query(0 , n - 1 , 1 , left , right) ;",
			"    }",
			"    int first(){",
			"        return tree[1].val ;",
			"    }",
			"    void output1(){",
			"        for(int i = 0 ; i < sz ; ++i){",
			"            cout << tree[i].val <<  \" \" ;",
			"        }",
			"        cout << endl ;",
			"    }",
			"    void output2(){",
			"        for(int i = 0 ; i < sz ; ++i){",
			"            cout << updates[i].val <<  \" \" ;",
			"        }",
			"        cout << endl ;",
			"    }",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"LazySGT lst(n , arr)",
			"",
			"*/"
		],
		"description": "lazysegmenttree"
	},
	"sparse": {
		"prefix": "sparsetable",
		"body": [
			"// O(1) for idempotent O(logN) for general",
			"",
			"template<typename Node>",
			"struct SparseTable {",
			"    vector<vector<Node > > table ;",
			"    vector<int > logValues ;",
			"    int n ;",
			"    int maxLog ;",
			"    vector<int > a ;",
			"    SparseTable(int n1 , vector<int > &arr) {",
			"        n = n1 ;",
			"        a = arr ;",
			"        table.resize(n) ;",
			"        logValues.resize(n + 1) ;",
			"        maxLog = log2(n) ;",
			"        logValues[1] = 0 ;",
			"        // 0 1 1 2 2 2 2 3 3 3  3  3  3  3  3  4  . . . . // log values ",
			"        // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . . . . ",
			"        for(int i = 2 ; i <= n ; ++i) {",
			"            logValues[i] = logValues[i / 2] + 1 ;",
			"        }",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            table[i].resize(maxLog + 1) ;",
			"            fill(all(table[i]) , Node()) ;",
			"        }",
			"        build() ;",
			"    }",
			"    void build() {",
			"        for(int i = 0; i < n; i++) {",
			"            table[i][0] = Node(a[i]) ;",
			"        }",
			"        for(int i = 1 ; i <= maxLog ; ++i) {",
			"            for(int j = 0 ; (j + (1 << i)) <= n ; ++j) {",
			"                table[j][i].merge(table[j][i - 1] , table[j + (1 << (i - 1))][i - 1]) ;",
			"            }",
			"        }",
			"    }",
			"    Node queryNormal(int left , int right) { // O(log(n))",
			"        Node ans = Node() ;",
			"        for(int j = logValues[right - left + 1] ; j >= 0 ; --j) {",
			"            if((1 << j) <= right - left + 1) {",
			"                ans.merge(ans, table[left][j]) ;",
			"                left += (1 << j) ; // will not be (j - 1)",
			"            }",
			"        }",
			"        return ans ; ",
			"    }",
			"    Node queryIdempotent(int left, int right) { // O(1)",
			"        int j = logValues[right - left + 1] ;",
			"        Node ans = Node() ;",
			"        ans.merge(table[left][j] , table[right - (1 << j) + 1][j]) ;",
			"        return ans ;",
			"    }",
			"};",
			"struct Node1 {",
			"    int val ; // store more info if required // may change",
			"    Node1() { // Identity Element",
			"        val = 0 ; // may change",
			"    }",
			"    Node1(int v) {",
			"        val = v ;",
			"    }",
			"    friend void merge(Node1 &l , Node1 &r) { // problem",
			"        val = l.val ^ r.val ;",
			"    }",
			"};",
			"",
			"/*",
			"",
			"        How to build the sparse table ",
			"",
			"        SparseTable<Node1 > SPARSE_TABLE = SparseTable<Node1 > (m , arr) ;",
			"",
			"*/"
		],
		"description": "sparse"
	},
	"centroid_decomposition": {
		"prefix": "centroid_decomposition",
		"body": [
			"struct centroid_decomposition {",
			"    vector<vector<int>> edges;",
			"    vector<bool> vis;",
			"    vector<int> par;",
			"    vector<int> sz;",
			"    int n;",
			"",
			"    void init(int s) {",
			"        n = s;",
			"        edges = vector<vector<int>>(n, vector<int>());",
			"        vis = vector<bool>(n, 0);",
			"        par = vector<int>(n);",
			"        sz = vector<int>(n);",
			"    }",
			"",
			"    void edge(int a, int b) {",
			"        edges[a].push_back(b);",
			"        edges[b].push_back(a);",
			"    }",
			"",
			"    int find_size(int v, int p = -1) {",
			"        if (vis[v]) return 0;",
			"        sz[v] = 1;",
			"",
			"        for (int x : edges[v]) {",
			"            if (x != p) {",
			"                sz[v] += find_size(x, v);",
			"            }",
			"        }",
			"",
			"        return sz[v];",
			"    }",
			"",
			"    int find_centroid(int v, int p, int n) {",
			"        for (int x : edges[v]) {",
			"            if (x != p) {",
			"                if (!vis[x] && sz[x] > n / 2) {",
			"                    return find_centroid(x, v, n);",
			"                }",
			"            }",
			"        }",
			"",
			"        return v;",
			"    }",
			"",
			"    void init_centroid(int v = 0, int p = -1) {",
			"        find_size(v);",
			"",
			"        int c = find_centroid(v, -1, sz[v]);",
			"        vis[c] = true;",
			"        par[c] = p;",
			"",
			"        for (int x : edges[c]) {",
			"            if (!vis[x]) {",
			"                init_centroid(x, c);",
			"            }",
			"        }",
			"    }",
			"};",
			""
		],
		"description": "centroid_decomposition"
	},
	"treap": {
		"prefix": "treap",
		"body": [
			"struct treap {",
			"    struct node {",
			"        int val, ans, id, sz, prior, lazy_ans, lazy_val, mx, mn;",
			"        node *l, *r, *par;",
			"        node(int _val, int _id) {",
			"            val = _val; mx=_val; mn=_val; ans = 0; id = _id;",
			"            lazy_ans = 0; lazy_val = 0; sz = 1;",
			"            prior = rnd(); l = NULL; r = NULL; par = NULL;",
			"        }",
			"    };",
			"    typedef node* pnode;",
			"    pnode root;",
			"    void clear() {",
			"        root = NULL;",
			"    }",
			"    treap() {",
			"        clear();",
			"    }",
			"    int size(pnode t) {",
			"        return t ? t->sz : 0;",
			"    }",
			"    void update_size(pnode &t) {",
			"        if(t) t->sz = size(t->l) + size(t->r) + 1;",
			"    }",
			" ",
			"    void update_parent(pnode &t) {",
			"        if(!t) return;",
			"        if(t->l) t->l->par = t;",
			"        if(t->r) t->r->par = t;",
			"    }",
			"    ///add operation",
			"    void push(pnode &t) {",
			"        if(!t)  return;",
			"        if (t->lazy_ans == 0 && t->lazy_val == 0) return;",
			"        t->ans += t->lazy_ans;",
			"        t->val += t->lazy_val;",
			"        t->mx += t->lazy_val;",
			"        t->mn += t->lazy_val;",
			"        if(t->l) {",
			"           t->l->lazy_ans += t->lazy_ans;",
			"           t->l->lazy_val += t->lazy_val;",
			"        }",
			"        if(t->r) {",
			"           t->r->lazy_ans += t->lazy_ans;",
			"           t->r->lazy_val += t->lazy_val;",
			"        }",
			"        t->lazy_ans = 0;",
			"        t->lazy_val = 0;",
			"    }",
			"    void reset(pnode &t) {",
			"        if(!t) return;",
			"        t->mx = t->val;",
			"        t->mn = t->val;",
			"    }",
			"    ///combine node l and r to form t by updating corresponding queries",
			"    void combine(pnode &t, pnode l, pnode r) {",
			"        if(!l) {",
			"            t = r; return;",
			"        }",
			"        if(!r) {",
			"            t = l; return;",
			"        }",
			"        t->mx = max(l->mx,r->mx);",
			"        t->mn = min(l->mn,r->mn);",
			"    }",
			"    ///perform all operations",
			"    void operation(pnode &t) {",
			"        if(!t)    return;",
			"        reset(t);",
			"        push(t->l);",
			"        push(t->r);",
			"        combine(t, t->l, t);",
			"        combine(t, t, t->r);",
			"    }",
			"    void split(pnode t, pnode &l, pnode &r, int k) {",
			"        if(t == NULL) {",
			"            l = NULL;",
			"            r = NULL;",
			"            return;",
			"        }",
			"        push(t);",
			"        if(t -> val <= k)",
			"            split(t->r, t->r, r, k), l = t;",
			"        else",
			"            split(t->l, l, t->l, k), r = t;",
			" ",
			"        update_parent(t);",
			"        update_size(t);",
			"        operation(t);",
			"    }",
			"    ///merge node l with r in t",
			"    void merge(pnode &t, pnode l, pnode r) {",
			"        push(l);",
			"        push(r);",
			"        if(!l) {",
			"            t = r;",
			"            return;",
			"        }",
			"        if(!r) {",
			"            t = l;",
			"            return;",
			"        }",
			" ",
			"        if(l->prior > r->prior)",
			"            merge(l->r, l->r, r), t = l;",
			"        else",
			"            merge(r->l, l, r->l), t = r;",
			" ",
			"        update_parent(t);",
			"        update_size(t);",
			"        operation(t);",
			"    }",
			"    void insert(int val, int id) {",
			"        if(root == NULL) {",
			"            pnode to_add = new node(val, id);",
			"            root = to_add;",
			"            return;",
			"        }",
			" ",
			"        pnode l, r, mid;",
			"        mid = new node(val, id);",
			" ",
			"        split(root, l, r, val);",
			"        merge(l, l, mid);",
			"        merge(root, l, r);",
			"    }",
			"    void upd(int k) {",
			"        pnode l, r, tmp, z; ",
			"        split(root, l, r, k - 1);",
			"        if (r == NULL) {",
			"           merge(root, l, r);",
			"           return;",
			"        }",
			"        r -> lazy_ans++;",
			"        r -> lazy_val -= k;",
			"        push(r);",
			"        operation(r);",
			"        while (l != NULL && r != NULL) {",
			"           if (l -> mx <= r -> mn) break;",
			"           int x = r->mn;",
			"           split(r, tmp, r, x);",
			"           split(l, l, z, x);",
			"           merge(l, l, tmp);",
			"           merge(l, l, z);",
			"        }",
			"        merge(root, l, r);",
			"    }",
			"    vector<int> res;",
			"    void inorder(pnode cur) {",
			"        if(cur==NULL) return;",
			"        operation(cur);",
			"        res[cur ->id] = cur -> ans;",
			"        inorder(cur->l);",
			"        inorder(cur->r);",
			"    }",
			"    // https://codeforces.com/contest/702/submission/92910754",
			"};"
		],
		"description": "treap"
	},
	"Template 1": {
		"prefix": "dsu",
		"body": [
		"struct DSU {",
		"    int S ; ",
		"    struct node {",
		"        int p; int siz; int rnk; // by rank, it's based on the height of the trees, while by size, it's based on the number of elements in the sets. ",
		"        // Merging the smaller tree into the larger one helps maintain a more balanced structure.",
		"    };",
		"    vector<node > dsu ; ",
		"    vector<pair<int , node > > history ; // Store history for rollback ",
		"",
		"    DSU(int n) { ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0; ",
		"            dsu.push_back(tmp) ; ",
		"        }",
		"    }",
		"",
		"    void reset(int n) {",
		"        dsu.clear() ; ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0; ",
		"            dsu.push_back(tmp) ; ",
		"        }",
		"    }",
		"",
		"    int parent(int u) {",
		"        if(dsu[u].p == u) return u;",
		"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
		"        return dsu[u].p ; ",
		"    }",
		"",
		"    void mergebysize(int u, int v) {",
        "        u = parent(u); v = parent(v);",
        "        if(u == v) return ;",
        "        if(dsu[u].siz < dsu[v].siz) swap(u , v) ; ",
        "        history.push_back({u, dsu[u]}) ;",
        "        history.push_back({v, dsu[v]}) ;",
        "        dsu[v].p = u ; ",
        "        dsu[u].siz += dsu[v].siz ; ",
        "    }",
        "",
        "    void mergebyrank(int u, int v) {",
        "        u = parent(u); v = parent(v);",
        "        if(u == v) return ;",
        "        history.push_back({u, dsu[u]}) ;",
        "        history.push_back({v, dsu[v]}) ;",
        "        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v ;",
        "        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u ;",
        "        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1 ; ",
        "    }",
        "",
        "    void rollback() { // Each union operation typically involves merging two sets (represented by their representatives) into one. Therefore, when rolling back a union operation, you need to undo the changes for both sets involved in that operation.",
        "        if(history.empty()) return ; // Nothing to rollback",
        "        auto [u , state_u] = history.back() ; // Retrieve the information about the last union operation",
        "        history.pop_back() ;",
        "        dsu[u] = state_u ;",
        "",
        "        if(!history.empty()) {",
        "            auto [v , state_v] = history.back() ; // Retrieve the information about the second-to-last union operation",
        "            history.pop_back() ;",
        "            dsu[v] = state_v ;",
        "        }",
        "    }",
		"",
		"    bool same(int u, int v) {",
		"        if(parent(u) == parent(v)) return true ; ",
		"        return false ; ",
		"    }",
		"",
		"    int get_size(int u) {",
		"        return dsu[parent(u)].siz ; ",
		"    }",
		"};"
		],
		"description": "Template 1"
	},
	"template 7": {
		"prefix": "dijkstra",
		"body": [
			"// // O(VlogV + ElogV) " ,
			"class Solution",
			"{",
			"public:",
			"    vector<int> shortestPath(int n, int m, vector<vector<int>> &edges)",
			"    {",
			"        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}",
			"        // where the edge weight is the weight of the edge from node1 to node2.",
			"        vector< pair< int , int > > adj[n + 1] ;",
			"        for (auto &i : edges)",
			"        {",
			"            adj[i[0]].push_back({i[1], i[2]});",
			"            adj[i[1]].push_back({i[0], i[2]});",
			"        }",
			"        // Create a priority queue for storing the nodes along with distances ",
			"        // in the form of a pair { dist, node }.",
			"        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int , int> > > pq;",
			"",
			"        // Create a dist array for storing the updated distances and a parent array for storing the nodes from where the current nodes represented by indices of the parent array came from.",
			"        vector<int > dist(n + 1 , 1e9) , parent(n + 1) , vis(n + 1 , 0) ;",
			"        for (int i = 1 ; i <= n ; ++i)",
			"            parent[i] = i ;",
			"",
			"        dist[1] = 0 ;",
			"",
			"        // Push the source node to the queue.",
			"        pq.push({0, 1});",
			"        // 	keeping visited vector is important because it was giving TLE for cses problem shortest route 1 for two test cases",
			"        while (!pq.empty())",
			"        {",
			"            // Topmost element of the priority queue is with minimum distance value.",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int dis = it.first ;",
			"            if(vis[node]) continue ;" ,
			"            vis[node] = 1 ;" ,
			"",
			"            // Iterate through the adjacent nodes of the current popped node.",
			"            for (auto it : adj[node])",
			"            {",
			"                int adjNode = it.first;",
			"                int edW = it.second;",
			"",
			"                // Check if the previously stored distance value is greater than the current computed value or not, if yes then update the distance value.",
			"                if (dis + edW < dist[adjNode])",
			"                {",
			"                    dist[adjNode] = dis + edW;",
			"                    pq.push({dis + edW, adjNode});",
			"",
			"                    // Update the parent of the adjNode to the recent node where it came from.",
			"                    parent[adjNode] = node;",
			"                }",
			"            }",
			"        }",
			"",
			"        // If distance to a node could not be found, return an array containing -1.",
			"        if (dist[n] == 1e9)",
			"            return {-1};",
			"",
			"        // Store the final path in the ‘path’ array.",
			"        vector<int> path ;",
			"        int node = n ;",
			"",
			"        // Iterate backwards from destination to source through the parent array.",
			"        while (parent[node] != node)",
			"        {",
			"            path.push_back(node) ;",
			"            node = parent[node] ;",
			"        }",
			"        path.push_back(1) ;",
			"",
			"        // Since the path stored is in a reverse order, we reverse the array to get the final answer and then return the array.",
			"        reverse(path.begin() , path.end()) ;",
			"        return path ;",
			"    }",
			"};"
		],
		"description": "template 7"
	},
	"template 8": {
		"prefix": "bellmanford",
		"body": [
			"// Problem Statement: Given a weighted, directed and connected graph ",
			"// of V vertices and E edges, Find the shortest distance of all the ",
			"// vertices from the source vertex S for negative edges.",
			"class Solution {",
			"public:",
			"    /*  Function to implement Bellman Ford",
			"    *   edges: vector of vectors which represents the graph",
			"    *   S: source vertex to start traversing graph with",
			"    *   V: number of vertices",
			"    */",
			"    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {",
			"        vector<int > dist(V + 1 , 1e8) ; // when the vertices are starting from 1 (V + 1) else (V)",
			"        dist[S] = 0 ;",
			"        for (int i = 0 ; i < V ; ++i) { // when the vertices are starting from 1 (V) else (V - 1)",
			"            for (auto it : edges) {",
			"                int u = it[0] ;",
			"                int v = it[1] ;",
			"                int wt = it[2] ;",
			"                if (dist[u] + wt < dist[v]){ // will not be using dist[u] != 1e8 it showed wrong answer on coding ninjas",
			"                    dist[v] = dist[u] + wt ;",
			"                }",
			"            }",
			"        }",
			"        // Nth relaxation to check negative cycle // only when it is not mentioned that it will form a cycle",
			"        for (auto it : edges) {",
			"            int u = it[0] ;",
			"            int v = it[1] ;",
			"            int wt = it[2] ;",
			"            if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {",
			"                return {-1} ;",
			"            }",
			"        }",
			"",
			"        return dist ;",
			"    }",
			"};"
		],
		"description": "template 8"
	},
	"template 9": {
		"prefix": "floydwarshall",
		"body": [
			"// Problem Statement: The problem is to find the shortest distances between ",
			"// every pair of vertices in a given edge-weighted directed graph. ",
			"// The graph is represented as an adjacency matrix of size n*n. ",
			"// Matrix[i][j] denotes the weight of the edge from i to j. ",
			"// If Matrix[i][j]=-1, it means there is no edge from i to j.",
			"class Solution {",
			"public:",
			"    void shortest_distance(vector<vector<int>>&matrix) {",
			"        int n = matrix.size();",
			"        // required when dirently using in the main function",
			"        // vector<vector<long long > > matrix(n + 1 , vector<long long > (n + 1 , -1)) ; // required when dirently using in the main function",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0 ; j < n ; ++j){",
			"                if (matrix[i][j] == -1){",
			"                    matrix[i][j] = 1e9 ;",
			"                }",
			"                if (i == j) matrix[i][j] = 0 ;",
			"            }",
			"        }",
			"",
			"        for (int k = 0 ; k < n ; ++k){ // asked in dp with bit masking problems ",
			"            for (int i = 0 ; i < n ; ++i){",
			"                for (int j = 0 ; j < n ; ++j){",
			"                    if(matrix[i][k] != 1e9 and matrix[k][j] != 1e9){ // important giving wrong answer on coding ninjas",
			"                        matrix[i][j] = min(matrix[i][j] , matrix[i][k] + matrix[k][j]) ;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        // required according to the problem statement ",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < n; j++) {",
			"                if (matrix[i][j] == 1e9) {",
			"                    matrix[i][j] = -1;",
			"                }",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "template 9"
	},
	"prims": {
		"prefix": "prim'salgorithm",
		"body": [
			"// Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.(A Minimum Spanning Tree (MST) is a subset of edges of a connected weighted undirected graph that connects all the vertices together with the minimum possible total edge weight.)",
			"// (Sometimes it may be asked to find the MST as well, where in the MST the edge-informations will be stored in the form {u, v}(u = starting node, v = ending node).)",
			"#include <bits/stdc++.h>",
			"using namespace std ;",
			"",
			"class Solution {",
			"public:",
			"    // Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[]) {",
			"        priority_queue<pair<int, int > , vector<pair<int, int > > , greater<pair<int, int > > > pq ;",
			"",
			"        vector<int> vis(V , 0) ;",
			"",
			"        // {wt, node}",
			"        pq.push({0 , 0}) ;",
			"        int sum = 0 ;",
			"        while(!pq.empty()) {",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int wt = it.first ;",
			"",
			"            if (vis[node] == 1) continue ;",
			"            vis[node] = 1 ;",
			"            sum += wt ;",
			"",
			"            for (auto it : adj[node]) {",
			"                int adjNode = it[0] ;",
			"                int edW = it[1] ;",
			"                if(!vis[adjNode]) {",
			"                    pq.push({edW , adjNode}) ;",
			"                }",
			"            }",
			"        }",
			"",
			"        return sum ;",
			"    }",
			"};",
			"",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int > > adj[V] ;",
			"    for (auto it : edges) {",
			"        vector<int> tmp(2) ;",
			"        tmp[0] = it[1] ;",
			"        tmp[1] = it[2] ;",
			"        adj[it[0]].push_back(tmp) ;",
			"",
			"        tmp[0] = it[0] ;",
			"        tmp[1] = it[2] ;",
			"        adj[it[1]].push_back(tmp) ;",
			"    }",
			"",
			"    Solution obj ; // creating an instance(object) of the Solution class. ",
			"    // By creating an object of the class you can access its methods and attributes",
			"    int sum = obj.spanningTree(V , adj) ;",
			"    cout << \"The sum of all the edge weights: \" << sum << endl;",
			"",
			"    return 0;",
			"}"
		],
		"description": "prims"
	},
	"kruskal": {
		"prefix": "kruskal'salgorithm",
		"body": [
			"// Problem Statement: Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"struct DSU {",
			"    int S ; ",
			"    struct node {",
			"        int p; int siz; int rnk;",
			"    };",
			"    vector<node > dsu ; ",
			"",
			"    DSU(int n) { ",
			"        S = n ; ",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            node tmp ; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp) ; ",
			"        }",
			"    }",
			"",
			"    void reset(int n) {",
			"        dsu.clear() ; ",
			"        S = n ; ",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            node tmp ; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp) ; ",
			"        }",
			"    }",
			"",
			"    int parent(int u) {",
			"        if(dsu[u].p == u) return u;",
			"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
			"        return dsu[u].p ; ",
			"    }",
			"",
			"    void mergebysize(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return ;",
			"        if(dsu[u].siz < dsu[v].siz) swap(u , v) ; ",
			"        dsu[v].p = u ; ",
			"        dsu[u].siz += dsu[v].siz ; ",
			"    }",
			"",
			"    void mergebyrank(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return ;",
			"        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v ;",
			"        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u ;",
			"        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1 ; ",
			"    }",
			"",
			"    bool same(int u, int v) {",
			"        if(parent(u) == parent(v)) return true ; ",
			"        return false ; ",
			"    }",
			"",
			"    int get_size(int u) {",
			"        return dsu[parent(u)].siz ; ",
			"    }",
			"};",
			"",
			"struct edge {",
			"    int u ;",
			"    int v ;",
			"    int weight ;",
			"};",
			"",
			"class Solution {",
			"public:",
			"    //Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[]) { // spanningTree is a method of the class Solution",
			"",
			"        vector<edge> edges;",
			"        for (int i = 0; i < V; i++) {",
			"            for (auto it : adj[i]) {",
			"                int adjNode = it[0];",
			"                int wt = it[1];",
			"                int node = i;",
			"",
			"                edge e ; // Create an instance of the edge struct",
			"                e.u = node ;",
			"                e.v = adjNode ;",
			"                e.weight = wt ;",
			"                edges.push_back(e) ; // Add the edge to the edges vector",
			"            }",
			"        }",
			"        DSU dsu(V) ;",
			"        sort(edges.begin(), edges.end()); ",
			"        int mstWt = 0;",
			"        // time complexity o(no. of Edges * 4 * aplha * 2) ",
			"        for (auto &[src , dest , weight] : edges) { // it will work on codeforces but won't work on many platforms",
			"            int wt = weight ;",
			"            int u = src ;",
			"            int v = dest ;",
			"",
			"            if (dsu.parent(u) != dsu.parent(v)) {",
			"                mstWt += wt;",
			"                dsu.mergebysize(u, v);",
			"            }",
			"        }",
			"",
			"        return mstWt;",
			"    }",
			"};",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int > > adj[V] ;",
			"    for (auto &it : edges) {",
			"        vector<int> tmp(2);",
			"        tmp[0] = it[1];",
			"        tmp[1] = it[2];",
			"        adj[it[0]].push_back(tmp);",
			"",
			"        tmp[0] = it[0];",
			"        tmp[1] = it[2];",
			"        adj[it[1]].push_back(tmp);",
			"    }",
			"",
			"    Solution obj ; // creating an instance(object) of the Solution class. ",
			"    // By creating an object of the class you can access its methods and attributes",
			"    int mstWt = obj.spanningTree(V , adj) ;",
			"    cout << \"The sum of all the edge weights: \" << mstWt << endl ;",
			"    return 0 ;",
			"}"
		],
		"description": "kruskal"
	},
	"bridges in graph": {
		"prefix": "bridges in graph",
		"body": [
			"int n ; // number of nodes",
			"vector<vector<int > > adj ; // adjacency list of graph",
			"vector<bool > visited ;",
			"vector<int > tin , low ;",
			"int timer ;",
			"",
			"void dfs(int v, int p , vector<vector<int>> &bridges) {",
			"    visited[v] = true;",
			"    tin[v] = low[v] = timer++;",
			"",
			"    for (int to : adj[v]) {",
			"        if (to == p) continue;",
			"",
			"        if (visited[to]) {",
			"            low[v] = min(low[v], tin[to]);",
			"        } ",
			"        else {",
			"            dfs(to , v , bridges);",
			"            low[v] = min(low[v], low[to]);",
			"",
			"            if (low[to] > tin[v]){",
			"                bridges.push_back({v, to});",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"void find_bridges() {",
			"    timer = 0;",
			"    visited.assign(n, false);",
			"    tin.assign(n, -1);",
			"    low.assign(n, -1);",
			"    vector<vector<int > > bridges ;",
			"    for (int i = 0; i < n; ++i) {",
			"        if (!visited[i])",
			"            dfs(i , -1 , bridges);",
			"    }",
			"}"
		],
		"description": "bridges in graph"
	},
	"Articulation points": {
		"prefix": "Articulation points",
		"body": [
			"int n; // number of nodes",
			"vector<vector<int > > adj; // adjacency list of graph",
			"vector<bool > visited;",
			"vector<int > tin , low;",
			"int timer;",
			"",
			"void dfs(int v, int p , vector<int > &ans) {",
			"    visited[v] = true;",
			"    tin[v] = low[v] = timer++;",
			"",
			"    int children = 0;",
			"",
			"    for (int to : adj[v]) {",
			"        if (to == p) continue;",
			"",
			"        if (visited[to]) {",
			"            low[v] = min(low[v], tin[to]);",
			"        } ",
			"        else {",
			"            dfs(to , v , ans);",
			"            low[v] = min(low[v], low[to]);",
			"",
			"            if (low[to] >= tin[v] && p != -1){",
			"                if(ans.find(v) == ans.end())",
			"                	ans.pb(v);",
			"            }",
			"",
			"            ++children;",
			"        }",
			"    }",
			"",
			"    if (p == -1 && children > 1){",
			"        ans.pb(v);",
			"    }",
			"}",
			"",
			"void find_cutpoints() {",
			"    timer = 0;",
			"    visited.assign(n, false);",
			"    tin.assign(n, -1);",
			"    low.assign(n, -1);",
			"    vector<int > ans ;",
			"    for (int i = 0; i < n; ++i) {",
			"        if (!visited[i]){",
			"            dfs(i , -1 , ans);",
			"        }",
			"    }",
			"}"
		],
		"description": "Articulation points"
	},
	"binary lifting and lca": {
		"prefix": "binary lifting and lca",
		"body": [
			"/*",
			"",
			"Sparse Table: Binary lifting can be seen as a type of sparse table data structure ",
			"that is customized for trees. It precomputes and stores information about the ",
			"ancestors of each node, allowing for quick LCA queries.",
			"Binary lifting is primarily used for finding the lowest common ancestor (LCA) of two nodes in a tree",
			"this technique itself is applicable to both rooted and unrooted trees not for graphs.",
			"Preprocessing: In binary lifting, you typically preprocess the tree to create ",
			"a data structure that helps answer LCA queries efficiently. This data structure ",
			"often involves storing the ancestors of each node at various power-of-2 levels in the tree.",
			"Time = O(logn) for each query",
			"",
			"*/",
			"struct BinaryLifting {",
			"    int n ;",
			"    int maxLog ;",
			"    int maxRequirement ;",
			"    vector<vector<int > > parent ;",
			"    vector<int > logValues ;",
			"    bool precomputedLogs = false ;",
			"    // vector<int> *edges ----> meaning ----> // Declaring a pointer to a vector of integers",
			"    BinaryLifting(int n1 , vector<vector<int > > &edges , int requirement , int root) { // requirement is 1e9 ",
			"        n = n1 ;",
			"        parent.resize(n) ;",
			"        maxLog = log2(requirement + 1) ;",
			"        maxRequirement = requirement ;",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            parent[i].resize(maxLog + 1) ;",
			"            for (int j = 0; j <= maxLog; ++j) {",
			"                parent[i][j] = -1 ;",
			"            }",
			"        }",
			"        fillParentTable(root , edges) ;",
			"        if (maxRequirement <= 1000000LL){ // 1e6",
			"            precomputeLogs() ;",
			"        }",
			"    }",
			"    void fillParentTable(int root , vector<vector<int > > &edges) {",
			"        vector<bool > visited(n) ;",
			"        dfsBinaryLifting(root, edges, visited) ;",
			"        int intermediate = -1 ;",
			"        for (int i = 1; i <= maxLog; ++i) {",
			"            for (int j = 0; j < n; ++j) {",
			"                intermediate = parent[j][i - 1] ;",
			"                if (intermediate != -1) {",
			"                    parent[j][i] = parent[intermediate][i - 1] ;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfsBinaryLifting(int root , vector<vector<int > > &edges , vector<bool > &visited) {",
			"        visited[root] = true ;",
			"        for (auto &i : edges[root]) {",
			"            if (!visited[i]) {",
			"                parent[i][0] = root ;",
			"                dfsBinaryLifting(i , edges , visited) ;",
			"            }",
			"        }",
			"    }",
			"    void precomputeLogs() {",
			"        precomputedLogs = true ;",
			"        logValues.resize(maxRequirement + 1) ;",
			"        logValues[1] = 0 ;",
			"        for (int i = 2 ; i <= maxRequirement ; ++i) {",
			"            logValues[i] = logValues[i / 2] + 1 ;",
			"        }",
			"    }",
			"    int kthParent(int start, int k) { // k can be upto 1e9, In this we have only one node and we have to calculate its parent by traversing in powers of 2 ",
			"        int a = start ;",
			"        while (k > 0) {",
			"            int x = getLog(k) ;",
			"            a = parent[a][x] ;",
			"            if (a == -1){",
			"                return a ;",
			"            }",
			"            k -= (1 << x) ;",
			"        }",
			"        return a ; ",
			"    }",
			"    inline int getLog(int x) {",
			"        return precomputedLogs ? logValues[x] : log2(x) ;",
			"    }",
			"};",
			"",
			"struct LCA { // Lowest Common Ancestor ",
			"    int n ; // number of nodes",
			"    vector<int > level ; // level of each node",
			"    LCA(int n1 , vector<vector<int > > &edges , int root) { // edges is the adjacency list of the tree",
			"        n = n1 ; // number of nodes",
			"        level.resize(n) ; // level of each node",
			"        dfsLCA(root, edges, -1) ; // -1 is the parent of root",
			"    }",
			"    void dfsLCA(int root , vector<vector<int > > &edges , int parent) { ",
			"        for (auto &i : edges[root]) { // ",
			"            if (i != parent) {",
			"                level[i] = level[root] + 1 ;",
			"                dfsLCA(i, edges, root) ;",
			"            }",
			"        }",
			"    }",
			"    int getLCA(int a , int b , BinaryLifting &bl_object) { // bl_object is the object of BinaryLifting class",
			"        if (level[a] > level[b]) {",
			"            swap(a , b) ;",
			"        }",
			"        // for calculating distance multiply by two",
			"        b = bl_object.kthParent(b , level[b] - level[a]) ; // kth parent of b at level (level[b] - level[a])",
			"        if (a == b) {",
			"            return a ; ",
			"        }"
			"        for (int i = bl_object.maxLog ; i >= 0 ; --i) {",
			"            int parent1 = bl_object.parent[a][i] ; ",
			"            int parent2 = bl_object.parent[b][i] ; ",
			"            if (parent2 != parent1 && parent1 != -1 && parent2 != -1) {",
			"                a = parent1 ; ",
			"                b = parent2 ; ",
			"            }",
			"        }",
			"        return bl_object.parent[a][0] ; ",
			"    }",
			"};"
		],
		"description": "binary lifting and lca"
	},
	"SCC": {
		"prefix": "Strongly Connected Component",
		"body": [
			"struct SCC { // only valid for directed graph // scc_using_kosaraju_algorithm_not_using_tarjan_algorithm ",
			"    vector<vector<int > > edges , redges ;",
			"    vector<bool > used ;",
			"    vector<int > order , component ;",
			"    int n ;",
			"",
			"    void init(int _n) {",
			"        n = _n ;",
			"        edges = vector<vector<int > > (n) ;",
			"        redges = vector<vector<int > > (n) ;",
			"        order.clear() ;",
			"        component.clear() ;",
			"    }",
			"",
			"    void edge(int u , int v) {",
			"        edges[u].push_back(v) ;",
			"        redges[v].push_back(u) ;",
			"    }",
			"",
			"    void dfs1(int v) {",
			"        used[v] = true ;",
			"        for (size_t i = 0 ; i < edges[v].size() ; ++i) {",
			"            if (!used[edges[v][i]]) {",
			"                dfs1(edges[v][i]) ;",
			"            }",
			"        }",
			"        order.push_back(v) ; // time of exit from the node matters (starting time and finishing time) ",
			"    }",
			"",
			"    void dfs2(int v) {",
			"        used[v] = true ;",
			"        component.push_back(v) ;",
			"        for (size_t i = 0 ; i < redges[v].size() ; ++i) {",
			"            if (!used[redges[v][i]]) {",
			"                dfs2(redges[v][i]) ;",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<vector<int > > run() {",
			"        vector<vector<int > > components ;",
			"        used.assign(n , false) ;",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            if (!used[i]) {",
			"                dfs1(i) ;",
			"            }",
			"        }",
			"",
			"        used.assign(n , false);",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            int v = order[n - 1 - i] ;",
			"            if (!used[v]) {",
			"                dfs2(v) ;",
			"                components.push_back(component) ;",
			"                component.clear() ;",
			"            }",
			"        }",
			"",
			"        return components ;",
			"    }",
			"",
			"	bool visited(int v) {",
			"		return used[v] ;",
			"	}",
			"	void clear() {",
			"		used.assign(n , false) ;",
			"	}",
			"};"
		],
		"description": "SCC"
	},
	"block cut tree": {
		"prefix": "block cut tree",
		"body": [
			"struct BlockCutTree {",
			"    int n ;",
			"    std::vector<std::vector<int>> adj;",
			"    std::vector<int > dfn , low , stk ;",
			"    int cnt , cur ;",
			"    std::vector<std::pair<int, int > > edges ;",
			"    ",
			"    BlockCutTree() {}",
			"    BlockCutTree(int n) {",
			"        init(n) ;",
			"    }",
			"    ",
			"    void init(int n) {",
			"        this->n = n ;",
			"        adj.assign(n , {}) ;",
			"        dfn.assign(n , -1) ;",
			"        low.resize(n) ;",
			"        stk.clear() ;",
			"        cnt = cur = 0 ;",
			"        edges.clear() ;",
			"    }",
			"    ",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v) ;",
			"        adj[v].push_back(u) ;",
			"    }",
			"    ",
			"    void dfs(int x) {",
			"        stk.push_back(x);",
			"        dfn[x] = low[x] = cur++;",
			"        ",
			"        for (auto &y : adj[x]) {",
			"            if (dfn[y] == -1) {",
			"                dfs(y);",
			"                low[x] = std::min(low[x], low[y]) ;",
			"                if (low[y] == dfn[x]) {",
			"                    int v ;",
			"                    do {",
			"                        v = stk.back() ;",
			"                        stk.pop_back() ;",
			"                        edges.emplace_back(n + cnt, v) ;",
			"                    } while (v != y) ;",
			"                    edges.emplace_back(x, n + cnt) ;",
			"                    cnt++;",
			"                }",
			"            } else {",
			"                low[x] = std::min(low[x], dfn[y]);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    std::pair<int, std::vector<std::pair<int, int > > > work() {",
			"        for (int i = 0; i < n; i++) {",
			"            if (dfn[i] == -1) {",
			"                stk.clear() ;",
			"                dfs(i) ;",
			"            }",
			"        }",
			"        return {cnt, edges} ;",
			"    }",
			"};"
		],
		"description": "block cut tree"
	},
	"heavy light decomposition": {
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"/*",
			"Heavy-Light Decomposition can be very useful in scenarios where you need to efficiently",
			"process and query trees, such as in dynamic programming or graph algorithms. ",
			"It's particularly handy in problems that involve finding LCA, range queries, ",
			"or path-based operations. When used correctly, HLD can significantly improve ",
			"the efficiency of tree-related computations.",
			"*/",
			"    int n;",
			"    std::vector<int> siz, top, dep, parent, in, out, seq;",
			"    std::vector<std::vector<int>> adj;",
			"    int cur;",
			"    ",
			"    HLD() {}",
			"    HLD(int n) {",
			"        init(n);",
			"    }",
			"    void init(int n) {",
			"        this->n = n;",
			"        siz.resize(n);",
			"        top.resize(n);",
			"        dep.resize(n);",
			"        parent.resize(n);",
			"        in.resize(n);",
			"        out.resize(n);",
			"        seq.resize(n);",
			"        cur = 0;",
			"        adj.assign(n, {});",
			"    }",
			"    void addEdge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"    }",
			"    void work(int root = 0) {",
			"        top[root] = root;",
			"        dep[root] = 0;",
			"        parent[root] = -1;",
			"        dfs1(root);",
			"        dfs2(root);",
			"    }",
			"    void dfs1(int u) {",
			"        if (parent[u] != -1) {",
			"            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));",
			"        }",
			"        ",
			"        siz[u] = 1;",
			"        for (auto &v : adj[u]) {",
			"            parent[v] = u;",
			"            dep[v] = dep[u] + 1;",
			"            dfs1(v);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[adj[u][0]]) {",
			"                std::swap(v, adj[u][0]);",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u) {",
			"        in[u] = cur++;",
			"        seq[in[u]] = u;",
			"        for (auto v : adj[u]) {",
			"            top[v] = v == adj[u][0] ? top[u] : v;",
			"            dfs2(v);",
			"        }",
			"        out[u] = cur;",
			"    }",
			"    int lca(int u, int v) {",
			"        while (top[u] != top[v]) {",
			"            if (dep[top[u]] > dep[top[v]]) {",
			"                u = parent[top[u]];",
			"            } else {",
			"                v = parent[top[v]];",
			"            }",
			"        }",
			"        return dep[u] < dep[v] ? u : v;",
			"    }",
			"    ",
			"    int dist(int u, int v) {",
			"        return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
			"    }",
			"    ",
			"    int jump(int u, int k) {",
			"        if (dep[u] < k) {",
			"            return -1;",
			"        }",
			"        ",
			"        int d = dep[u] - k;",
			"        ",
			"        while (dep[top[u]] > d) {",
			"            u = parent[top[u]];",
			"        }",
			"        ",
			"        return seq[in[u] - dep[u] + d];",
			"    }",
			"    ",
			"    bool isAncester(int u, int v) {",
			"        return in[u] <= in[v] && in[v] < out[u];",
			"    }",
			"    ",
			"    int rootedParent(int u, int v) {",
			"        std::swap(u, v);",
			"        if (u == v) {",
			"            return u;",
			"        }",
			"        if (!isAncester(u, v)) {",
			"            return parent[u];",
			"        }",
			"        auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {",
			"            return in[x] < in[y];",
			"        }) - 1;",
			"        return *it;",
			"    }",
			"    ",
			"    int rootedSize(int u, int v) {",
			"        if (u == v) {",
			"            return n;",
			"        }",
			"        if (!isAncester(v, u)) {",
			"            return siz[v];",
			"        }",
			"        return n - siz[rootedParent(u, v)];",
			"    }",
			"    ",
			"    int rootedLca(int a, int b, int c) {",
			"        return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
			"    }",
			"};"
		],
		"description": "heavy light decomposition"
	},
	"dinic": {
		"prefix": "dinic",
		"body": [
			"template <typename F>",
			"struct Dinic {",
			"    struct edge {",
			"        int to;",
			"        F cap;",
			"        int rev;",
			"        edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev) {}",
			"    };",
			"",
			"    vector<vector<edge>> es;",
			"    vector<int> d, pos;",
			"    const F zero_F, INF_F;",
			"    const int n;",
			"",
			"    Dinic(int n, F zero_F = 0, F INF_F = numeric_limits<F>::max() / 2) : es(n), d(n), pos(n), zero_F(zero_F), INF_F(INF_F), n(n) {}",
			"",
			"    void add_edge(int from, int to, F cap, bool directed = true) {",
			"        es[from].emplace_back(to, cap, (int)es[to].size());",
			"        es[to].emplace_back(from, directed ? zero_F : cap, (int)es[from].size() - 1);",
			"    }",
			"",
			"    bool _bfs(int s, int t) {",
			"        fill(begin(d), end(d), -1);",
			"        queue<int> que;",
			"        d[s] = 0;",
			"        que.push(s);",
			"        while (!que.empty()) {",
			"            int i = que.front();",
			"            que.pop();",
			"            for (auto &e : es[i]) {",
			"                if (e.cap > zero_F && d[e.to] == -1) {",
			"                    d[e.to] = d[i] + 1;",
			"                    que.push(e.to);",
			"                }",
			"            }",
			"        }",
			"        return d[t] != -1;",
			"    }",
			"",
			"    F _dfs(int now, int t, F flow) {",
			"        if (now == t) return flow;",
			"        for (int &i = pos[now]; i < (int)es[now].size(); i++) {",
			"            edge &e = es[now][i];",
			"            if (e.cap > zero_F && d[e.to] > d[now]) {",
			"                F f = _dfs(e.to, t, min(flow, e.cap));",
			"                if (f > zero_F) {",
			"                    e.cap -= f;",
			"                    es[e.to][e.rev].cap += f;",
			"                    return f;",
			"                }",
			"            }",
			"        }",
			"        return zero_F;",
			"    }",
			"",
			"    // 操作後の d 配列は最小カットの 1 つを表す (0 以上なら s 側、-1 なら t 側)",
			"    F max_flow(int s, int t) {",
			"        F flow = zero_F;",
			"        while (_bfs(s, t)) {",
			"            fill(begin(pos), end(pos), 0);",
			"            F f = zero_F;",
			"            while ((f = _dfs(s, t, INF_F)) > zero_F) flow += f;",
			"        }",
			"        return flow;",
			"    }",
			"};",
			"",
			"struct edge {",
			"    int to, cap, flow;",
			"    edge* inv;",
			"    edge(int to1, int cap1) : to(to1), cap(cap1), flow(0), inv(nullptr) {}",
			"    int spare() {",
			"        return cap - flow;",
			"    }",
			"    void add(int f) {",
			"        flow += f;",
			"        inv->flow -= f;",
			"    }",
			"};",
			" ",
			"struct dinic{",
			"    int size, s, e;",
			"    vi level, work;",
			"    vector<vector<edge*>> adj;",
			"    void init(int n){",
			"        size = n;",
			"        s = n - 2;",
			"        e = n - 1;",
			"        adj.resize(n);",
			"    }",
			"    void add(int u, int v, int w){",
			"        edge* e1 = new edge(v, w);",
			"        edge* e2 = new edge(u, 0);",
			"        e1 -> inv = e2; e2 -> inv = e1;",
			"        adj[u].push_back(e1);",
			"        adj[v].push_back(e2);        ",
			"    }",
			"    void sadd(int u, int w){",
			"        add(s, u, w);",
			"    }",
			"    void eadd(int u, int w){",
			"        add(u, e, w);",
			"    }",
			"    bool make_level(void){",
			"        level.clear(); level.resize(size, -1);",
			"        work.clear(); work.resize(size);",
			"        level[s] = 0;",
			"        queue<int> q; q.push(s);",
			"        while(!q.empty()){",
			"            int cur = q.front(); q.pop();",
			"            for(edge* e : adj[cur]){",
			"                if(level[e->to] == -1 && e->spare()){",
			"                    level[e->to] = level[cur] + 1;",
			"                    q.push(e->to);",
			"                }",
			"            }",
			"        }",
			"        if(level[e] == -1) return false;",
			"        else return true;",
			"    }",
			"    int dfs(int cur, int f){",
			"        if(cur == e) return f;",
			"        for(int& i = work[cur]; i < adj[cur].size(); i++){",
			"            int nxt = adj[cur][i] -> to;",
			"            if(level[nxt] == level[cur] + 1 && adj[cur][i] -> spare()){",
			"                int ff = dfs(nxt, min(f, adj[cur][i] -> spare()));",
			"                if(ff){",
			"                    adj[cur][i]->add(ff);",
			"                    return ff;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    int operate(void){",
			"        int total = 0;",
			"        while(make_level()){",
			"            while(1){",
			"                int curflow = dfs(s, 1e18);",
			"                if(!curflow) break;",
			"                total += curflow;",
			"            }",
			"        }",
			"        return total;",
			"    }",
			"}G;"
		],
		"description": "dinic"
	},
	"2_SAT": {
		"prefix": "2_SAT",
		"body": [
			"struct TwoSAT",
			"{",
			"	static const int MAXV=1e5+5;",
			"",
			"	int n, cnt;",
			"	vector<int> g[MAXV], rg[MAXV]; //g=forward, rg=backward",
			"	bool vis[MAXV];",
			"	int order[MAXV], comp[MAXV];",
			"",
			"	void init(int curn)",
			"	{",
			"		n=curn;",
			"		for(int i=0;i<n;i++)",
			"		{	",
			"			g[i].clear();",
			"			rg[i].clear();",
			"		}",
			"	}",
			"",
			"	void add(int u, int v)",
			"	{",
			"		g[u].push_back(v);",
			"		rg[v].push_back(u);",
			"	}",
			"",
			"	void dfs1(int u)",
			"	{",
			"		vis[u] = true;",
			"		for(auto it:g[u])",
			"			if(!vis[it])",
			"				dfs1(it);",
			"		order[cnt++] = u;",
			"	}",
			"",
			"	void dfs2(int u, int c)",
			"	{",
			"		comp[u] = c;",
			"		for(auto it:rg[u])",
			"			if(comp[it]==-1)",
			"				dfs2(it, c);",
			"	}",
			"",
			"	int solve(vector<int> &ans)",
			"	{",
			"		cnt=0;",
			"		memset(vis, 0, sizeof(vis));",
			"		for(int i=0;i<n;i++)",
			"			if(!vis[i])",
			"				dfs1(i);",
			"		memset(comp, -1, sizeof(comp));",
			"		int grp=0;",
			"		for(int i=n-1;i>=0;i--)",
			"		{",
			"			int u=order[i];",
			"			if(comp[u] == -1)",
			"				dfs2(u, grp++);",
			"		}",
			"",
			"		for(int i=0;i<n;i+=2)",
			"			if(comp[i]==comp[i^1])",
			"				return 0;",
			"",
			"		ans.clear();",
			"",
			"		for(int i=0;i<n;i+=2)",
			"		{",
			"			int choose = (comp[i] > comp[i^1]) ? i : (i^1);",
			"			ans.push_back(choose);",
			"		}",
			"",
			"		return 1;",
			"	}",
			"};",
			"",
			"// Sample Problem 1: https://codeforces.com/contest/228/problem/E",
			"// Sample Solution 1: https://codeforces.com/contest/228/submission/39775751",
			"",
			"// Sample Problem 2: http://codeforces.com/contest/776/problem/D",
			"// Sample Solution 2: http://codeforces.com/contest/776/submission/39776230"
		],
		"description": "2_SAT"
	},
	"Tarjan": {
		"prefix": "tarjan",
		"body": [
			"struct Tarjan {",
			"    int n,dn,rt;",
			"    vector<vector<int>> g;",
			"    vector<vector<int>> vcc;",
			"    vector<int> dfn,low,cut;",
			"    stack<int> st;",
			"    Tarjan(int n):n(n),dn(0),g(n),dfn(n),low(n),cut(n) {}",
			"    void addEdge(int u,int v) {",
			"        g[u].emplace_back(v);",
			"        g[v].emplace_back(u);",
			"    }",
			"    void tarjan(int u) {",
			"        dfn[u]=low[u]=++dn;",
			"        st.push(u);",
			"        int chd=0;",
			"        for(int v:g[u]) {",
			"            if(!dfn[v]) {",
			"                tarjan(v);",
			"                low[u]=min(low[u], low[v]);",
			"                if(dfn[u]<=low[v]) {",
			"                    if(u!=rt||++chd>1) cut[u]=1;// 割点",
			"                    vcc.push_back({u});",
			"                    for (int x=-1; x!=v; st.pop())",
			"                        vcc.back().push_back(x=st.top());",
			"                }",
			"            }else {// 返祖边",
			"                // 求vcc判不判回头边无所谓",
			"                low[u]=min(low[u], dfn[v]);",
			"            }",
			"        }",
			"        if(u==rt&&chd==0)// 孤点",
			"            vcc.push_back({u});",
			"    }",
			"    void converge() {",
			"        for(rt=0; rt<n; ++rt) ",
			"            if(!dfn[rt]) tarjan(rt);",
			"    }",
			"    // 圆方树/森林",
			"    auto newTree() {",
			"        vector<vector<int>> tr(n+vcc.size());",
			"        for(int i=0; i<vcc.size(); ++i)",
			"            for(int x:vcc[i]) {",
			"                tr[n+i].push_back(x);// 方点向圆点连边",
			"                tr[x].push_back(n+i);",
			"            }",
			"        return tr;",
			"    }",
			"};"
		],
		"description": "Tarjan"
	},
	"Biconnected component": {
		"prefix": "biconnected component",
		"body": [
			"struct biconnected_components{",
			"	int n, attempt = 0;",
			"	biconnected_components(int n): n(n), pos(n), was(n, -1){ }",
			"	vector<int> pos, stack, was;",
			"	// O(n + m) where n and m are the number of reachable nodes and edges respectively.",
			"	// Requires graph",
			"	template<class T>",
			"	void run(const graph<T> &g, const vector<int> &init, auto act_comp, auto act_bridge){",
			"		assert(n == g.n);",
			"		int it = 0;",
			"		auto dfs = [&](auto self, int u, int pe)->int{",
			"			int top = pos[u] = ++ it;",
			"			was[u] = attempt;",
			"			for(auto id: g.adj[u]){",
			"				if(g.ignore && g.ignore(id) || id == pe) continue;",
			"				int v = u ^ g.edge[id].from ^ g.edge[id].to;",
			"				if(was[v] != attempt){",
			"					was[v] = attempt;",
			"					pos[v] = 0;",
			"				}",
			"				if(pos[v]){",
			"					top = min(top, pos[v]);",
			"					if(pos[v] < pos[u]) stack.push_back(id);",
			"				}",
			"				else{",
			"					int sz = (int)stack.size(), up = self(self, v, id);",
			"					top = min(top, up);",
			"					if(up == pos[u]){",
			"						stack.push_back(id);",
			"						act_comp(vector<int>{stack.begin() + sz, stack.end()});",
			"						stack.resize(sz);",
			"					}",
			"					else if(up < pos[u]) stack.push_back(id);",
			"					else act_bridge(id);",
			"				}",
			"			}",
			"			return top;",
			"		};",
			"		for(auto u: init) if(was[u] != attempt) dfs(dfs, u, -1);",
			"		++ attempt;",
			"	}",
			"	template<class T>",
			"	void run_all(const graph<T> &g, auto act_comp, auto act_bridge){",
			"		assert(n == g.n);",
			"		vector<int> init(n);",
			"		iota(init.begin(), init.end(), 0);",
			"		run(g, init, act_comp, act_bridge);",
			"	}",
			"};"
		],
		"description": "Biconnected component"
	},
	"bitwise": {
		"prefix": "bitwise_TRIE",
		"body": [
			"class Trie {",
			"public:",
			"    struct BITS_TRIE {",
			"        private:",
			"        struct node {",
			"            int start = 0 ;",
			"            int end = 0 ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            node* next[2] ;",
			"            node() {",
			"                next[1] = next[0] = NULL ;",
			"            }",
			"        };",
			"",
			"        node root ;",
			"",
			"        public:",
			"        void insert(int val) {",
			"            node* temp = &root;",
			"            temp->cnt++ ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                if(temp->next[bit] == NULL) {",
			"                    temp->next[bit] = new node() ;",
			"                }",
			"",
			"                temp = temp->next[bit] ;",
			"                temp->cnt++ ;",
			"            }",
			"        }",
			"",
			"        void remove(int val) {",
			"            node* temp = &root;",
			"            temp->cnt-- ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                temp = temp->next[bit] ;",
			"                temp->cnt-- ;",
			"            }",
			"        }",
			"",
			"        int max_xor(int val) {",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = 1 - bit ; // what we want to maximize opposite of bit because 1 ^ 0 = 1 and 0 ^ 1 = 1",
			"",
			"                if(temp->next[req] == NULL) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else {",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"",
			"        int min_xor(int val){",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i){",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0){",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = bit ; // what we want to minimize",
			"",
			"                if(temp->next[req] == NULL){",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0){",
			"                    ans += (1 << i) ;",
			"                    temp=temp->next[1 - req] ;",
			"                }",
			"                else{",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"    };",
			"};"
		],
		"description": "bitwise"
	},
	"stringwise_trie": {
		"prefix": "stringwise_trie",
		"body": [
			"class Trie {",
			"public:",
			"    struct STRING_TRIE {",
			"        private:",
			"        struct Node {",
			"            Node* next[26] ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            int cntEndWith = 0 ;",
			"            int cntPrefix = 0 ;  ",
			"",
			"            bool containsKey(char ch) {",
			"                return (next[ch - 'a'] != nullptr) ; ",
			"            }",
			"            Node* get(char ch) {",
			"                return next[ch - 'a'] ; ",
			"            }",
			"            void put(char ch, Node* node) {",
			"                next[ch - 'a'] = node ; ",
			"            }",
			"            void setEnd() { // comes to the end of the word after inserting set its refernce trie block to true",
			"                flag = true ; ",
			"            }",
			"            bool isEnd() { // check prefix ",
			"                return flag ; ",
			"            }",
			"            void increaseEnd() {",
			"                cntEndWith++ ;  ",
			"            }",
			"            void increasePrefix() {",
			"                cntPrefix++ ; ",
			"            }",
			"            void deleteEnd() {",
			"                cntEndWith-- ; ",
			"            }",
			"            void reducePrefix() {",
			"                cntPrefix-- ; ",
			"            }",
			"            int getEnd() {",
			"                return cntEndWith ; ",
			"            }",
			"            int getPrefix() {",
			"                return cntPrefix ; ",
			"            }",
			"        };",
			"",
			"        Node *root ;",
			"",
			"        public:",
			"        /** Inserts a word into the trie. */",
			"        void insert(string &word) {",
			"            Node *node = root ;",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    node->put(word[i] , new Node()) ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"                node->increasePrefix();  // Increment prefix count for each character ",
			"            }",
			"            node->setEnd() ; ",
			"            node->increaseEnd();  // Increment end count for the last character",
			"        }",
			"",
			"        /** Returns if the word is in the trie. */",
			"        bool search(string &word) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"            }",
			"            if(node->isEnd()) {",
			"                return true ; ",
			"            }",
			"            return false ; ",
			"        }",
			"",
			"        /** Returns if there is any word in the trie that starts with the given prefix. */",
			"        bool startsWith(string &prefix) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < prefix.size() ; ++i) {",
			"                if(!node->containsKey(prefix[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(prefix[i]) ; ",
			"            }",
			"            return true ; ",
			"        }",
			"",
			"        /** Returns inumber of words equal to given word */",
			"        int countWordsEqualTo(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getEnd() ; ",
			"        }",
			"",
			"        /** ... */",
			"        int countWordsStartingWith(string &word){",
			"            Node* node = root;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getPrefix() ; ",
			"        }",
			"",
			"        /** Actually it do not remove the blocks but it decreases the count of that word */",
			"        void erase(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                    node->reducePrefix() ;  // Decrease prefix count for each character",
			"                }",
			"                else {",
			"                    return ;",
			"                }",
			"            }",
			"            node->deleteEnd() ;  // Decrease end count for the last character",
			"        }",
			"",
			"        /** ... */",
			"        bool checkIfAllPrefixExists(string word) {",
			"            Node *node = root;",
			"            bool flag = true; ",
			"            for(int i = 0;i<word.size();i++) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]); ",
			"                    flag = flag & node->isEnd(); ",
			"                }",
			"                else {",
			"                    return false; ",
			"                } ",
			"            }",
			"            return flag; ",
			"        }",
			"",
			"        /** ... */",
			"        string completeString(int n, vector<string> &a){",
			"            Node *node = root;",
			"            for(auto word : a) insert(word); ",
			"            string longest = \"\"; ",
			"            for(auto &word: a) {",
			"                if(checkIfAllPrefixExists(word)) {",
			"                    if(word.size() > longest.size()) {",
			"                        longest = word; ",
			"                    }",
			"                    else if(word.size() == longest.size() && word < longest) {",
			"                        longest = word; ",
			"                    }",
			"                }",
			"            }",
			"            if(longest == \"\") return \"None\"; ",
			"            return longest; ",
			"        }",
			"",
			"        /** ... */",
			"        int countDistinctSubstrings(string &s) {",
			"            Node* node = root;",
			"            int cnt = 0; ",
			"            int n = s.size(); ",
			"            for(int i = 0 ; i < n ; ++i)",
			"            {",
			"                Node* node = root; ",
			"                for(int j = i ; j < n ; ++j) {",
			"                    if(!node->containsKey(s[j])) {",
			"                        node->put(s[j], new Node()) ;  ",
			"                        cnt++ ; ",
			"                    }",
			"                    node = node->get(s[j]) ; ",
			"                }",
			"            }",
			"            return cnt + 1 ; //    Write your code here.",
			"        }",
			"",
			"    };",
			"};",
			"",
			"/*",
			"",
			"So, how to declare Trie in this case.",
			"",
			"Trie::STRING_TRIE trie ;",
			"trie.insert(\"apple\"); , trie.search(\"apple\"); , trie.countWordsEqualTo(\"app\"); , trie.erase(\"app\");",
			"",
			"*/"
		],
		"description": "stringwise_trie"
	},
	"matrix expo": {
		"prefix": "matrix expo",
		"body": [
			"template<typename T>",
			"class Matrix {",
			"public:",
			"    vector<vector<T>> mat;",
			"",
			"    Matrix() {}",
			"",
			"    Matrix(int _n, int _m, T init) {",
			"        mat = vector<vector<T>>(_n, vector<T>(_m, init));",
			"    }",
			"",
			"    Matrix(const vector<vector<T>>& a) {",
			"        mat = a;",
			"    }",
			"",
			"    void set(T init) {",
			"        for(int i = 0; i < rows(); i++) {",
			"            for(int j = 0; j < cols(); j++) {",
			"                mat[i][j] = init;",
			"            }",
			"        }",
			"    }",
			"",
			"    int rows() const {",
			"        return mat.size();",
			"    }",
			"",
			"    int cols() const {",
			"        return mat[0].size();",
			"    }",
			"",
			"    Matrix operator*(const Matrix<T>& obj) const {",
			"        assert(cols() == obj.rows());",
			"        vector<vector<T>> res(rows(), vector<T>(obj.cols()));",
			"        for(int r = 0; r < rows(); r++) {",
			"            for(int c = 0; c < obj.cols(); c++) {",
			"                for(int k = 0; k < cols(); k++) {",
			"                    res[r][c] += mat[r][k] * obj.mat[k][c];",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<T>& operator[](int index) {",
			"        return mat[index];",
			"    }",
			"};",
			"",
			"template<typename T>",
			"ostream& operator<<(ostream& os, Matrix<T>& mat) {",
			"    int n = mat.rows(), m = mat.cols();",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < m; j++) {",
			"            os << mat[i][j] << \" \";",
			"        }",
			"        os << endl;",
			"    }",
			"    return os;",
			"}",
			"",
			"template<typename T>",
			"Matrix<T> power(Matrix<T> res, Matrix<T> a, long long b) {",
			"    while(b > 0) {",
			"        if(b & 1) ",
			"            res = a * res;",
			"        a = a * a;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "matrix expo"
	},
	"Chinese Remainder Theorem": {
		"prefix": "Chinese Remainder Theorem",
		"body": [
			"int mod_inv(int c, int m) {",
			"    int m0 = m;",
			"    int y = 0, x = 1;",
			"",
			"    if (m == 1) return 0;",
			"",
			"    while (c > 1) {",
			"        int q = c / m;",
			"        int t = m;",
			"        m = c % m;",
			"        c = t;",
			"        t = y;",
			"        y = x - q * y;",
			"        x = t;",
			"    }",
			"",
			"    if (x < 0) x += m0;",
			"    return x;",
			"}",
			"",
			"int CRT(vector<pair<int, int>> congru) {",
			"    int M = 1;",
			"",
			"    for (auto var : congru) {",
			"        M *= var.second;",
			"    }",
			"",
			"    int solution = 0;",
			"",
			"    for (auto var : congru) {",
			"        int a_i = var.first;",
			"        int M_i = M / var.second;",
			"        int N_i = mod_inv(M_i, var.second);",
			"        solution = (solution + a_i * (M_i % M) * N_i) % M;",
			"    }",
			"",
			"    return solution;",
			"}",
			""
		],
		"description": "Chinese Remainder Theorem"
	},
	"Extended Euclidean Algorithm": {
		"prefix": "Extended Euclidean Algorithm",
		"body": [
			"// used to find the greatest common divisor (GCD) of two integers.",
			"// also finds the coefficients of Bézout's identity. Bézout's identity states that for any two integers a and b, there exist integers x and y such that:",
			"// ax + by = gcd(a, b)",
			"int ex_gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"",
			"    int x1, y1;",
			"    int d = ex_gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"",
			"    return d;",
			"}",
			""
		],
		"description": "Extended Euclidean Algorithm"
	},
	"convexhullgrahamscan": {
		"prefix": "convexhull",
		"body": [
			"void cc(vector<pair<ll, ll>>& points) {",
			" ",
			"    auto ccw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) > 0;",
			"    };",
			"    auto cw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) < 0;",
			"    };",
			" ",
			"    auto cmp = [](pair<ll, ll>& p, pair<ll, ll>& pp) {",
			"        if (p.first == pp.first) return p.second < pp.second;",
			"        return p.first < pp.first;",
			"    };",
			" ",
			"    sort(all(points), cmp); ll n = points.size();",
			"    pair<ll, ll>a = points[0], c = points[n - 1];",
			"    vector<pair<ll, ll>>up, down;",
			"    up.push_back(a); down.push_back(a);",
			"    for (ll i = 1; i < points.size(); i++) {",
			"        if (i == n - 1 || !ccw(a, points[i], c)) {",
			"            // upper half and colinear",
			"            while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], points[i])) {",
			"                up.pop_back();",
			"            }",
			"            up.push_back(points[i]);",
			"        }",
			"        if (i == n - 1 || !cw(a, points[i], c)) {",
			"            //lower Half and colinear",
			"            while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], points[i])) {",
			"                down.pop_back();",
			"            }",
			"            down.push_back(points[i]);",
			"        }",
			"    }",
			"    points.clear();",
			"    for (size_t i = 0; i < up.size(); i++)  points.push_back(up[i]);",
			"    for (size_t i = 0; i < down.size(); i++) points.push_back(down[i]);",
			" ",
			"    // Points vector has duplicate values also ",
			"    // as which belongs both upper half and lower half",
			"    // https://codeforces.com/contest/1858/submission/218957587",
			" ",
			"}"
		],
		"description": "convexhullgrahamscan"
	},
	"geometry": {
		"prefix": "geometry",
		"body": [
			"struct point",
			"{",
			"	int x, y, idx;",
			"};",
			"",
			"//Finds squared euclidean distance between two points",
			"int dist(point &a, point &b)",
			"{",
			"	return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);",
			"}",
			"",
			"//Checks if angle ABC is a right angle",
			"int isOrthogonal(point &a, point &b, point &c)",
			"{",
			"	return (b.x-a.x) * (b.x-c.x) + (b.y-a.y) * (b.y-c.y) == 0;",
			"}",
			"",
			"//Checks if ABCD form a rectangle (in that order)",
			"int isRectangle(point &a, point &b, point &c, point &d)",
			"{",
			"	return isOrthogonal(a, b, c) && isOrthogonal(b, c, d) && isOrthogonal(c, d, a);",
			"}",
			"",
			"//Checks if ABCD form a rectangle, in any orientation",
			"int isRectangleAnyOrder(point &a, point &b, point &c, point &d)",
			"{",
			"	return isRectangle(a, b, c, d) || isRectangle(b, c, a, d) | isRectangle(c, a, b, d);",
			"}",
			"",
			"//Checks if ABCD form a square (in that order)",
			"int isSquare(point &a, point &b, point &c, point &d)",
			"{",
			"	return isRectangle(a, b, c, d) && dist(a, b) == dist(b, c);",
			"}",
			"",
			"//Checks if ABCD form a square, in any orientation",
			"int isSquareAnyOrder(point &a, point &b, point &c, point &d)",
			"{",
			"	return isSquare(a, b, c, d) || isSquare(b, c, a, d) | isSquare(c, a, b, d);",
			"}"
		],
		"description": "geometry"
	}
}
