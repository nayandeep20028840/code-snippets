// {
// 	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
// 	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
// 	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
// 	// same ids are connected.
// 	// Example:
// 	// "Print to console": {
// 	// 	"prefix": "log",
// 	// 	"body": [
// 	// 		"console.log('$1');",
// 	// 		"$2"
// 	// 	],
// 	// 	"description": "Log output to console"
// 	// }
// }

{
	"simple_main.": {
		"prefix": "man",
		"body": [
			"#include<bits/stdc++.h> ",
			"using namespace std ; ",
			"",
			"int main() { ",
			"    ",
			"\t$1",
			"    ",
			"    return 0 ;",
			"}"
		],
		"description": "simple_main."
	},
	"input output file": {
		"prefix": "input output file",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\",\"r\",stdin);",
			"    freopen(\"output.txt\",\"w\",stdout);",
			"    freopen(\"error.txt\", \"w\", stderr);",
			"#endif "
		],
		"description": "input output file"
	},
	"Mathematics": {
		"prefix": "Mathematics",
		"body": [
			"const int MOD = 1000000007 ; // 998244353 ",
			"const long long inf = 1000000000000000000LL; // 18 zero's // LLONG_MAX = 9223372036854775807 - 19 digits",
			"",
			"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor",
			"int LCM(int a, int b){return ((long long)a / (long long)GCD(a, b) * (long long)b) ;}",
			"int modpower(int x, int y, int m){long long res = 1; x = x % m; while(y > 0){if(y&1) res = (res * (long long)x) % MOD; y = y >> 1; x = ((long long)x * (long long)x) % MOD ;}return res ;} ",
			"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}",
			"int mod_DIVISION(int a, int b, int m){a %= m , b %= m; return mod_MULTIPLICATION(a , modpower(b , m - 2 , MOD) , m);}",
			"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}",
			"int modinv(int x){return modpower(x , MOD - 2 , MOD) ;} ",
			"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.first != b.first){return a.first < b.first ;}return a.second > b.second ;}"
		],
		"description": "Mathematics"
	},
	"my hash define": {
		"prefix": "my hash define",
		"body": [
			"#define nl                \"\\n\"",
			"#define ll                long long",
			"#define int               ll",
			"#define ld                long double",
			"#define iv(a , n)         vector<int>a(n); for(int i=0;i<n;++i){cin>>a[i];}",
			"#define im(a , n , m)     vector<vector<int>>a(n,vector<int>(m)); for(int i=0;i<n;++i){for(int j=0;j<m;++j){cin>>a[i][j];}}",
			"#define yes               cout << \"YES\" << nl ;",
			"#define no                cout << \"NO\" << nl ;",
			"#define all(v)            v.begin(),v.end()",
			"#define F                 first",
			"#define S                 second",
			"#define check1(v)         for(auto &i : v){ cout<<i<<\" \"; } cout<<nl ;",
			"#define check2(v)         for(auto &i : v){ cout<<i.F<<\" \"<<i.S<<nl ; } ",
			"#define check3(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S<<nl; } ",
			"#define check4(v)         for(auto &i : v){ cout<<i.F.F<<\" \"<<i.F.S<<\" \"<<i.S.F<<\" \"<<i.S.S<<nl; }",
			"#define pb                push_back",
			"#define lb                lower_bound",
			"#define ub                upper_bound",
			"#define bpp               __builtin_popcountll",
			"#define Pi                3.1415926535897932384626",
			"#define EPS               1e-9"
		],
		"description": "my hash define"
	},
	"pbds": {
		"prefix": "pbds",
		"body": [
			"// Policy based data structures(PBDS) C++ STL",
			"// find_by_order(k): returns the iterator of the k-th element in a set (0-index)",
			"// order_of_key(k): returns count of elements strictly smaller than k ",
			"// Time complexity: O(logn) for both",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template<class T > using pbds_SET = tree< T , null_type , less<T>, rb_tree_tag, tree_order_statistics_node_update > ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree_SET<pair<int , int > > s; for pairs",
			"template<class T > using pbds_MULTISET = tree< T , null_type , less_equal<T>, rb_tree_tag, tree_order_statistics_node_update > ; // here T can be anything like pair,vector,map,pair_of_pair // USE it like Tree_MULTISET<pair<int , int > > s; for pairs"
		],
		"description": "pbds"
	},
	"hash define functions": {
		"prefix": "hash define functions",
		"body": [
			"\"int GCD(int a, int b){if(b == 0){return a;} return GCD(b, a % b);} // Euclidean algorithm for computing the greatest common divisor\",",
			"\"int LCM(int a, int b){return ((long long)a / (long long)GCD(a, b) * (long long)b) ;}\",",
			"\"int modpower(int x, int y, int m){long long res = 1; x = x % m; while(y > 0){if(y&1) res = (res * (long long)x) % MOD; y = y >> 1; x = ((long long)x * (long long)x) % MOD ;}return res ;} \",",
			"\"int mod_ADDITION(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\",",
			"\"int mod_SUBTRACTION(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\",",
			"\"int mod_MULTIPLICATION(int a, int b, int m) {a = a % m; b = b % m; return ((((long long)a * (long long)b) % m) + m) % m;}\",",
			"\"int mod_DIVISION(int a, int b, int m){a %= m , b %= m; return mod_MULTIPLICATION(a , modpower(b , m - 2 , MOD) , m);}\",",
			"\"long long power(long long x, long long y){long long res = 1 ; while(y > 0) {if(y & 1) res = (res * (long long)x) ; x = ((long long)x * (long long)x) ; y = y >> 1 ;} return res ;}\",",
			"\"int modinv(int x){return modpower(x , MOD - 2 , MOD) ;} \",",
			"\"bool isPowerOfTwo(int n){if(n==0) {return false;} return (ceil(log2(n)) == floor(log2(n)));}\",",
			"\"bool comparatorfunction(pair<int,int> &a, pair<int,int> &b){if(a.F != b.F){return a.F < b.F ;}return a.S > b.S ;}\",",
			"\"vector<int > giveme_it_isprime_or_not(int n){vector<int > isPrime(n+1, 1);isPrime[0]=isPrime[1]=false;for(int i = 2; i * i <= n; ++i){if(isPrime[i] == true){for(int j = 2 * i; j <= n; j += i){isPrime[j] = false;}}} return isPrime;} // Time Complexity - O(n * sqrt(n) * log(n)) \",",
			"\"vector<int> givemeprimes(int n) {int*arr = new int[n + 1](); vector<int> vect; for(int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for(int j = i * i; j <= n; j += i)arr[j] = 1;} return vect;} // can be calculated in O(n) \",",
			"\"vector<vector<int>> givemedivisors(int n){int*arr = new int[n + 1]();vector<vector<int > > vect(n + 1);for(int i = 2; i <= n; ++i){if(arr[i] == 0){for(int j = i; j <= n; j += i){vect[j].pb(i);arr[i] = 1;}}} return vect ;}\",",
			"\"vector<int > givemesmallestprimefactors(int n){vector<int > SPF(n + 1);for(int i = 0; i <= n; ++i){SPF[i] = i;}for(int i = 2; i <= n; ++i){if(SPF[i] == i){for(int j = i; j <= n; j += i){if(SPF[j] == j){SPF[j] = i;}}}}return SPF ;} // SPF is the smallest prime number that divides a given number without leaving a remainder\",",
			"\"int sqrtprecision(int l,int r,int target){while(r-l>EPS){int mid=(l+(r-l)/2);if(mid*mid<target)l=mid;else r=mid;}return l+(r-l)/2;}\",",
			"\"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} \",",
			"\"int errichtokabinary(int l,int r,vector<int>&a,int target){int ans=-1; while(l <= r){int mid=(l+(r-l)/2); if(a[mid]==target){ans=mid;return ans;}if(a[mid]<target)l=mid+1;else r=mid-1;}return ans;}\",",
			"\"int isqrt(int n){long long x = sqrtl(n);while (x*x>n){--x;} while((x+1) * (x+1)<=n){++x;}return x;}\","
		],
		"description": "hash define functions"
	},
	"kashi..": {
		"prefix": "main2",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(3, \"Ofast\", \"inline\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"#define int long long",
			"",
			"bool solve()",
			"{",
			"\t$1",
			"    return true;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"    int t;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        if (solve())",
			"        {",
			"            ",
			"        }",
			"        else",
			"        {",
			"            ",
			"        }",
			"    }",
			"    return 0;",
			"}",
			"",
			"",
			"",
			// " // Assume worst when things happens to you. Do best when you can.",
			// " // Talk is Cheap. Show me the code ",
			// " // Don't overthink and try to prove your idea. ",
			// "// Think twice, code once. // rab ne bana di jodi "
		],
		"description": "kashi.."
	},
	"kashi.": {
		"prefix": "main1",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(3, \"Ofast\", \"inline\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"#define int long long",
			"",
			"bool solve()",
			"{",
			"\t$1",
			"    return true;",
			"}",
			"",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"    int t = 1;",
			"    while (t--)",
			"    {",
			"        if (solve())",
			"        {",
			"            ",
			"        }",
			"        else",
			"        {",
			"            ",
			"        }",
			"    }",
			"    return 0;",
			"}",
			"",
			// " // Talk is Cheap. Show me the code ",
			""
		],
		"description": "kashi."
	},
	"jaishrimahakal": {
		"prefix": "leetcode",
		"body": [
			"#include<bits/stdc++.h> ",
			//"#include \"atcoder/all\" ",
			//"#include \"atcoder/modint\" ",
			//"#include <atcoder/convolution> ",
			"using namespace std; ",
			//"using namespace atcoder; ",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(3, \"Ofast\", \"inline\")",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
			"",
			"auto init = []() ",
			"{",
			"   ios::sync_with_stdio(false);",
			"   cin.tie(nullptr);",
			"   cout.tie(nullptr);",
			"   return 'c';",
			"}();",
			"",
			""
		],
		"description": "jaishrimahakal"
	},
	"wow": {
		"prefix": "nayan",
		"body": [
			"function<void(int,int)> func=[&](int child,int parent)->void{",
			"\t$1",
			"};"
		],
		"description": "wow"
	},
	"StressTesting": {
		"prefix": "stresstesting",
		"body": [
			"int rnd(int a, int b){",
			"    return a + rand() % (b - a + 1);",
			"}",
			"int generator(){",
			"    // This function acts as a generator.",
			"    int w = rnd(1, 100);",
			"    return w;",
			"}",
			"string solve(int w){",
			"    // This function acts as the WA solution to test.",
			"    if(w%2==0)return \"YES\";",
			"    return \"NO\";",
			"}",
			"",
			"string bruteForce(int w){",
			"    // This function acts as the brute force solution.",
			"    for(int i=1;i<w;i++){",
			"        int j = w - i;",
			"        if(i%2==0 && j%2==0)return \"YES\";",
			"    }",
			"    return \"NO\";",
			"}",
			"void check(int w, string myAnswer, string correctAnswer){",
			"    // This function acts as the checker.",
			"    if(myAnswer == correctAnswer)return;",
			"    cout<<\"Found the WA test\"<<\"\\n\";",
			"    cout<<\"W = \"<<w<<\"\\n\";",
			"    cout<<\"myAnswer = \"<<myAnswer<<\"\\n\";",
			"    cout<<\"correctAnswer = \"<<correctAnswer<<\"\\n\";",
			"    exit(0);",
			"}",
			"int main() {",
			"    for(int i = 1 ; ; i++){",
			"        int w = generator() ;",
			"        string myAnswer = solve(w) ;",
			"        string correctAnswer = bruteForce(w) ;",
			"        check(w, myAnswer, correctAnswer) ;",
			"        cout<<\"Passed test: \"<<i<<\"\\n\" ;",
			"    }",
			"}"
		],
		"description": "StressTesting"
	},
	"Doubly Linked List": {
		"prefix": "Doubly Linked List",
		"body": [
			"struct Node {",
			"    Node* prev;",
			"    Node* next;",
			"    int val;",
			"",
			"    Node(int value) : val(value), prev(nullptr), next(nullptr) {}",
			"};",
			"",
			"class DoublyLinkedList {",
			"private:",
			"    Node* head;",
			"    Node* tail;",
			"",
			"public:",
			"    DoublyLinkedList() {",
			"        head = new Node(-1); // Dummy head node",
			"        tail = new Node(-1); // Dummy tail node",
			"        head->next = tail;",
			"        tail->prev = head;",
			"    }",
			"",
			"    ~DoublyLinkedList() {",
			"        // Destructor to deallocate memory of all nodes",
			"        Node* current = head;",
			"        while (current) {",
			"            Node* temp = current;",
			"            current = current->next;",
			"            delete temp;",
			"        }",
			"    }",
			"",
			"    // Function to add a new node after a given node",
			"    Node* addAfter(Node* node, int value) {",
			"        Node* newNode = new Node(value);",
			"        newNode->prev = node;",
			"        newNode->next = node->next;",
			"        node->next->prev = newNode;",
			"        node->next = newNode;",
			"        return newNode;",
			"    }",
			"",
			"    // Function to delete a node from the list",
			"    void remove(Node* node) {",
			"        node->prev->next = node->next;",
			"        node->next->prev = node->prev;",
			"        delete node;",
			"    }",
			"",
			"    // Function to print the list",
			"    void printList() {",
			"        Node* current = head->next; // Skipping dummy head",
			"        while (current != tail) {",
			"            std::cout << current->val << \" \";",
			"            current = current->next;",
			"        }",
			"        std::cout << std::endl;",
			"    }",
			"};"
		],
		"description": "Doubly Linked List"
	},
	"deadlypillow": {
		"prefix": "deadlypillowncr",
		"body": [
			"const int N = 2e6 + 1 ;",
			"int F[N], iF[N]; // Don't forget to change the value of N. factorial,Inverse Factorial Array",
			"// if you want to use without any mod than mod will be INF ",
			"",
			"int fast(int a, int b) {",
			"    int res = 1 ;",
			"    while (b > 0) {",
			"        if (b & 1)",
			"            res = res * a % MOD ;",
			"        a = a * a % MOD ;",
			"        b >>= 1 ;",
			"    }",
			"    return res ;",
			"}",
			"",
			"void init() {",
			"",
			"    F[0] = 1 ;",
			"",
			"    for(int i = 1 ; i < N ; ++i) ", 
			"        F[i] = (F[i - 1] * i) % MOD ;", 
			"", 
			"    iF[N - 1] = fast(F[N - 1] , MOD - 2) ; // it finds the inverse of F[N - 1] ",
			"", 
			"    for (int i = N - 2 ; i >= 0 ; --i)",
			"        iF[i] = iF[i + 1] * (i + 1) % MOD ;",
			"}",
			"",
			"int NCR(int n, int r) {",
			"    if (r > n || r < 0)",
			"        return 0 ;",
			"",
			"    return iF[r] * F[n] % MOD * iF[n - r] % MOD ;",
			"}"
		],
		"description": "deadlypillow"
	},
	"ababbaba":{
		"prefix": "concepts",
		"body": [
		"//lower bound of p mtlb p se just badda ya uske equal agr lower bound ke it ko -- kra to just chota milega agr ye it s.end hai to mtlb vo element ya usse badda element nhi hai aur agr ye sbegin hai to uss element se chota element nhi hai",
		"//upper bound of p mtlb p se just badda uske equal nhi agr ye s.end() hai to mtlb uss element se badda element nhi hai aur agr iske it ko it-- kre to uss p se just chota ya uske equal element milega but agr ye s.begin hai to usme koi bhi element p ya p se chota nhi hai",
		"If Inserting / pushing elements in a set / priority_queue it takes (nlog n) time complexity.",
		"Never use map< pair<int , int > , int > mp instead use vector<unordered_map<int , int > > v(n)",
		],
		"description": "ababbaba"
	},
	"heapiFy": {
		"prefix": "heapiFy",
		"body": [
			"    class minHeap {",
			"public:",
			"",
			"    // Constructor for the class.",
			"    vector<int > heap ;",
			"    int siz , cap ;",
			"    minHeap(int n) {",
			"        heap.resize(n) ;",
			"        siz = 0 ;",
			"        cap = n ;",
			"    }",
			"",
			"    void heapiFy(int i){",
			"        int smallest = i ;",
			"        int left = 2*i + 1 ;",
			"        int right = 2*i + 2 ;",
			"        if(left < siz && heap[left] < heap[smallest]){",
			"            smallest = left ;",
			"        }",
			"        if(right < siz && heap[right] < heap[smallest]){",
			"            smallest = right ;",
			"        }",
			"        if(smallest != i){",
			"            swap(heap[i] , heap[smallest]) ;",
			"            heapiFy(smallest) ;",
			"        }",
			"    }",
			"    // Implement the function to remove minimum element.",
			"    int extractMinElement() {",
			"        // Write you code here.",
			"        if(siz == 0){",
			"            return -1 ;",
			"        }",
			"        int ans = heap[0] ;",
			"        swap(heap[0] , heap[siz - 1]) ;",
			"        siz-- ;",
			"        heapiFy(0) ;",
			"        return ans ;",
			"    }",
			"",
			"    // Implement the function to delete an element.",
			"    void deleteElement(int ind) {",
			"        // Write you code here.",
			"        if(ind >= siz){",
			"            return ;",
			"        }",
			"        swap(heap[ind] , heap[siz - 1]) ;",
			"        siz-- ;",
			"        heapiFy(ind) ;",
			"",
			"    }",
			"",
			"    // Implement the function to insert 'val' in the heap.",
			"    void insert(int val) {",
			"        // Write you code here.",
			"        if(siz == cap){",
			"            return ;",
			"        }",
			"        heap[siz] = val ;",
			"        int i = siz ;",
			"        while(i > 0 && heap[(i - 1)/2] > heap[i]){",
			"            swap(heap[(i - 1)/2] , heap[i]) ;",
			"            i = (i - 1)/2 ;",
			"        }",
			"        siz++ ;",
			"",
			"    }",
			"};",
			"",
			"void btup heapiFy(vector<int > &a , int n){ // min heap not for max heap",
			"    for(int i = n / 2 - 1 ; i >= 0 ; --i){",
			"        int item = a[i] ;",
			"        int child = 2 * i + 1 ;",
			"        while(child <= n - 1){",
			"            if(child + 1 <= n - 1 && a[child + 1] < a[child]){ // for max heap a[child + 1] > a[child]",
			"                child++ ;",
			"            }",
			"            if(a[child] < item){ // for max heap a[child] > item",
			"                a[i] = a[child] ;",
			"            }",
			"            else{",
			"                break ;",
			"            }",
			"            child = 2 * child + 1 ; ",
			"        }",
			"        a[i] = item ;",
			"    }",
			"}",
			"",
			"void tpdn heapiFy(vector<int > &a , int n){ // min heap not for max heap",
			"    for(int i = 1 ; i <= n - 1 ; ++i){",
			"        int key = a[i] ;",
			"        int child = i ;",
			"        int parent = (child - 1) / 2 ;",
			"        while(c > 0 && a[parent] < key){ // for max heap a[parent] > key and for min heap a[parent] < key",
			"            a[child] = a[parent] ;",
			"            child = parent ;",
			"            parent = (child - 1) / 2 ;",
			"            a[child] = key ;",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "heapiFy"
	},
	"lps-longestprefixsuffix": {
		"prefix": "lps-longestprefixsuffix",
		"body": [
			"// LPS (Longest Prefix Suffix) Algorithm:",
			"",
			"// Purpose: The LPS algorithm is primarily used to find the length of the longest proper prefix which is also a proper suffix of a given string for each position in the string.",
			"",
			"// Key Concept: It calculates an array where each element at index i represents the length of the longest proper prefix of the substring ending at position i that is also a proper suffix of the substring.",
			"",
			"// Usage: It is used as a building block in other string matching algorithms, like the KMP algorithm.",
			"",
			"vector<int > longestprefixsuffix(string s){",
			"    int n = s.size();",
			"    vector<int > lps(n , 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            len++ ;  ",
			"            lps[i] = len ;",
			"            i++ ;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1] ;",
			"            }else{",
			"                lps[i] = 0 ;",
			"                i++ ;",
			"            }",
			"        }",
			"    }",
			"    return lps ;",
			"}"
		],
		"description": "lps-longestprefixsuffix"
	},
	"z_function": {
		"prefix": "z_function",
		"body": [
			"// Z Algorithm:",
			"",
			"// Purpose: The Z Algorithm is designed to efficiently find all occurrences",
			"// of a pattern within a text.",
			"",
			"// Key Concept: It calculates an array where each element at index i represents the length",
			"// of the longest substring starting from the ith position that matches the prefix of the text.",
			"",
			"// Usage: The Z Algorithm is used as a standalone linear time string matching algorithm",
			"// It is particularly useful when you need to find all occurrences of a pattern in a text.",
			"",
			"// Implementation: The Z Algorithm involves maintaining an interval [l, r] such that the",
			"// substring [l, r] matches the prefix of the text, and it efficiently computes the",
			"// Z values for each position in the text.",
			"",
			"vector<int > z_function(string s){",
			"    int n = s.size() ;",
			"    int i = 1 ;",
			"    int l = 0 ;",
			"    int r = 0 ;",
			"    vector<int > z(n , 0) ;",
			"    while(i < n){",
			"        if(i <= r){",
			"            // copy because in range ",
			"            z[i] = min(z[i - l] , r - i + 1) ;",
			"        }",
			"        // our basic logic goes here ",
			"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]){",
			"            z[i]++ ;",
			"        }",
			"        if(i + z[i] - 1 > r){",
			"            // update the range",
			"            l = i ;",
			"            r = i + z[i] - 1 ;",
			"        }",
			"        i++ ;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "z_function"
	},
	"kmp": {
		"prefix": "kmp",
		"body": [
			"/*",
			"KMP (Knuth-Morris-Pratt) Algorithm:",
			"Purpose: KMP is a more comprehensive algorithm used to efficiently search for a ",
			"pattern within a text while avoiding unnecessary character comparisons.",
			"Key Concept: It constructs a prefix array (also known as the LPS array) for the",
			"pattern and uses this array to skip characters in the text during the search, ",
			"reducing the number of character comparisons.",
			"Advantages: KMP is known for its linear time complexity, making it efficient for large texts.",
			"Usage: It's widely used in text searching, text processing, and string matching applications.",
			"",
			"*/",
			"",
			"vector<int > longestprefixsuffix(string s){",
			"    int n = s.size();",
			"    vector<int > lps(n , 0);",
			"    lps[0] = 0;",
			"    int len = 0;",
			"    int i = 1;",
			"    while(i < n){",
			"        if(s[i] == s[len]){",
			"            len++ ;  ",
			"            lps[i] = len ;",
			"            i++ ;",
			"        }else{",
			"            if(len != 0){",
			"                len = lps[len - 1] ;",
			"            }else{",
			"                lps[i] = 0 ;",
			"                i++ ;",
			"            }",
			"        }",
			"    }",
			"    return lps ;",
			"}",
			"",
			"int kmp(string p, string s){",
			"    int plen = p.size() ; // pattern length // we have to find this pattern in the string ",
			"    int slen = s.size() ; // string length ",
			"    if(plen == 0) return 0 ; // if string length is zero ",
			"    vector<int > pattern_lps = longestprefixsuffix(p) ;",
			"    int len = 0 ;",
			"    int i = 0 ;",
			"    int cnt = 0 ;",
			"    while(i < slen){",
			"        if(s[i] == p[len]){",
			"            len++ ;",
			"            i++ ;",
			"        }",
			"        else{",
			"            if(len != 0){",
			"                len = pattern_lps[len - 1] ;",
			"            }else{",
			"                i++ ;",
			"            }",
			"        }",
			"        if(len == plen){",
			"            cnt++ ;",
			"            len = pattern_lps[len - 1] ;",
			"        }",
			"    }",
			"    return cnt ; // cnt is the number of times the pattern occurs in the string s ",
			"}"
		],
		"description": "kmp"
	},
	"rabin karp": {
		"prefix": "rabin karp",
		"body": [
			"vector<int> rabin_karp(string const& s, string const& t) {",
			"    const int p = 31;",
			"    const int m = 1e9 + 9;",
			"    int S = s.size(); // pattern size // we need to find this pattern in the text ",
			"    int T = t.size();",
			"",
			"    // Precompute powers of p",
			"    vector<long long> p_pow(max(S, T));",
			"    p_pow[0] = 1;",
			"    for (int i = 1; i < (int)p_pow.size(); i++) {",
			"        p_pow[i] = (p_pow[i-1] * p) % m;",
			"    }",
			"",
			"    // Compute hash values for the entire text",
			"    vector<long long> h(T + 1, 0);",
			"    for (int i = 0; i < T; i++) {",
			"        h[i+1] = (h[i] + (t[i] - 'a' + 1) * p_pow[i]) % m;",
			"    }",
			"",
			"    // Compute hash value for the pattern",
			"    long long h_s = 0;",
			"    for (int i = 0; i < S; i++) {",
			"        h_s = (h_s + (s[i] - 'a' + 1) * p_pow[i]) % m;",
			"    }",
			"",
			"    // Store occurrences",
			"    vector<int> occurrences;",
			"    for (int i = 0; i + S - 1 < T; i++) {",
			"        long long cur_h = (h[i + S] + m - h[i]) % m;",
			"        if (cur_h == h_s * p_pow[i] % m) {",
			"            occurrences.push_back(i);",
			"        }",
			"    }",
			"",
			"    return occurrences;",
			"}"
		],
		"description": "rabin karp"
	},
	"manacher": {
		"prefix": "manacher",
		"body": [
			"// USES - Longest Palindromic Substring , ",
			"// Pattern Matching:to find occurrences of a specific",
			"// palindromic pattern within a given text.",
			"/*",
			"",
			"aba -->#a#b#a#",
			"abba -->#a#b#b#a#",
			"",
			"how to build manacher",
			"m.build(s) ;",
			"",
			"*/",
			"struct manacher {",
			"    vector<int > p ;",
			"    int n ;",
			"    string s1 ;",
			"    void run_manacher(string s) {",
			"        int n = s.length() ;",
			"        s = \"$\" + s + \"^\" ;",
			"        // cout << s << \"\\n\" ; ",
			"        s1 = s ; ",
			"        p.assign(n + 2 , 0) ; // don't use resize(fcuk)",
			"        int l = 1 ; // l and r are not inclusive ",
			"        int r = 1 ;",
			"        for(int i = 1 ; i <= n ; ++i){",
			"            p[i] = max(0ll , min(p[l + r - i] , r - i)) ;",
			"            while(i - p[i] >= 0 && i + p[i] <= n && s[i - p[i]] == s[i + p[i]]){",
			"                p[i]++ ;",
			"            }",
			"            if(i + p[i] > r){ // or",
			"                l = i - p[i] ;",
			"                r = i + p[i] ;",
			"            }",
			"        }",
			"        // for(auto &v : p){",
			"        //     cout << v << \" \" ;",
			"        // }",
			"        // cout << \"\\n\" ;",
			"    }",
			"    void build(string s){ // so that every substring is odd length ",
			"        string t ;",
			"        for (auto it : s){",
			"            t += string(\"#\") + it ; // making every substring odd length ",
			"        }",
			"        run_manacher(t + \"#\") ;",
			"    }",
			"    vector<int > get_vector_p(){",
			"        return p ;  ",
			"    }",
			"    string get_string_s(){",
			"        return s1 ;  ",
			"    }",
			"    // abbabba // 0 based indexing ",
			"    // centre = 1 , odd = 1 length = 1 this means we have to odd length palindrome with centre as 1 ",
			"    // centre = 1 , odd = 0 length = 4 this means we have to even length palindrome with centre as 1 ",
			"    int getlongest(int centre, bool odd) { // I can't understanding this(fcuk) ",
			"        int pos = 2 * centre + odd + 1 + (!odd) ;",
			"        return (p[pos] - 1) ;",
			"    }",
			"    bool checkPal(int l, int r) {",
			"        if ((r - l + 1) <= getlongest((r + l) / 2, l % 2 == r % 2)) {",
			"            return 1 ;",
			"        }",
			"        return 0 ;  ",
			"    }",
			"} man;",
			""
		],
		"description": "manacher"
	},
	// "vector<unordered_map<int , int > >": {
	// 	"prefix": "gp_hash_table<int, ll> dp[N];",
	// 	"body": [
	// 		"struct custom_hash {",
	// 		"  static uint64_t splitmix64(uint64_t x) {",
	// 		"    x += 0x9e3779b97f4a7c15;",
	// 		"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
	// 		"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
	// 		"    return x ^ (x >> 31);",
	// 		"  }",
	// 		"  size_t operator()(uint64_t x) const {",
	// 		"    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
	// 		"    return splitmix64(x + FIXED_RANDOM);",
	// 		"  }",
	// 		"};"
	// 	],
	// 	"description": "vector<unordered_map<int , int > >"
	// },
	"Template 5": {
		"prefix": "interactive..interactor",
		"body": [
			"struct Interactor{",
			"    int hiddenNumber ;",
			"    int limitQueries = 0 ;",
			"    int queries = 0 ;",
			"    Interactor(){ // it is constructor of this struct",
			"        hiddenNumber = getRandomNumber(1 , 1000) ; // initialize this variable called hiddenNumber",
			"        limitQueries = 100 ; // limit by your self for debuging.",
			"    }",
			"    char query(int x , bool printOutput){",
			"        if(queries >= limitQueries){",
			"            cout << \"You have exceeded the number of queries\" << \"\\n\" ;",
			"        }else{",
			"            queries ++ ;",
			"        }",
			"        // assert(queries < limitQueries) // Your code stops here if this is false give out a runtime error.",
			"        char ans = '=' ;",
			"        if(x > hiddenNumber){",
			"            ans = '>' ;",
			"        }",
			"        else if(x < hiddenNumber){",
			"            ans = '<' ;",
			"        }",
			"        else{",
			"            ans = '=' ;",
			"        }",
			"        if(printOutput){",
			"            cout << ans << \"\\n\" ;",
			"        }",
			"        return ans ;",
			"    }",
			"    bool correctOutput(int x){",
			"        if(x == hiddenNumber){",
			"            cout << \"Passed for \" << x << \"\\n\" ;",
			"        }else{",
			"            cout << \"Failed\" << \"\\n\" ;",
			"            cout << \"Hidden Number: \" << hiddenNumber << \"\\n\" ;",
			"            cout << \"Output Given: \" << x << \"\\n\" ;",
			"        }",
			"        return x == hiddenNumber ;",
			"    }",
			"}"
		],
		"description": "Template 5"
	},
	"binary indexed tree": {
		"prefix": "binary indexed tree",
		"body": [
			"template <typename T> class BIT {",
			"public:",
			"    vector<T> bit;",
			"    int n;",
			"",
			"    BIT() { n = 0; }",
			"",
			"    BIT(int _n) {",
			"        n = _n;",
			"        bit.assign(n, 0);",
			"    }",
			"",
			"    // increase the value of element at idx idxex i.e a[idx]",
			"    void inc(int idx, T val) {",
			"        // assert(0 <= idx and idx < n);",
			"        for (int i = idx + 1; i <= n; i += (i & -i))",
			"            bit[i - 1] += val;",
			"    }",
			"",
			"    // sum of all the elements in [0..idx]",
			"    T query(int idx) {",
			"        // assert(0 <= idx and idx < n);",
			"        T res = 0;",
			"        for (int i = idx + 1; i > 0; i -= (i & -i))",
			"            res += bit[i - 1];",
			"        return res;",
			"    }",
			"",
			"    // get the value of element at idx index i.e a[idx]",
			"    T at(int idx) {",
			"        // assert(0 <= idx and idx < n);",
			"        return query(idx) - (idx - 1 >= 0 ? query(idx - 1) : 0);",
			"    }",
			"",
			"    // sum of all the element [l..r]",
			"    T at(int l, int r) {",
			"        // assert(0 <= l and l <= r and r < n);",
			"        return query(r) - (l - 1 >= 0 ? query(l - 1) : 0);",
			"    }",
			"};",
			"",
			"template <typename T> class FT {",
			"public:",
			"    BIT<T> f1, f2;",
			"    int n;",
			"",
			"    FT() { n = 0; }",
			"",
			"    FT(int _n) {",
			"        n = _n;",
			"        f1 = f2 = BIT<T>(_n + 1);",
			"    }",
			"",
			"    // increase the value of element at idx idxex i.e a[idx]",
			"    void inc(int idx, T val) {",
			"        // assert(0 <= idx and idx < n);",
			"        inc(idx, idx, val);",
			"    }",
			"",
			"    // increase all the elements in [l..r] by val",
			"    void inc(int l, int r, T val) {",
			"        // assert(0 <= l and l <= r and r < n);",
			"        f1.inc(l, val);",
			"        f1.inc(r + 1, -val);",
			"        f2.inc(l, val * (l - 1));",
			"        f2.inc(r + 1, -val * r);",
			"    }",
			"",
			"    // sum of all the elements in [0..idx]",
			"    T query(int idx) {",
			"        // assert(0 <= idx and idx < n);",
			"        return f1.query(idx) * idx - f2.query(idx);",
			"    }",
			"",
			"    // get the value of element at idx index i.e a[idx]",
			"    T at(int idx) {",
			"        // assert(0 <= idx and idx < n);",
			"        return query(idx) - (idx - 1 >= 0 ? query(idx - 1) : 0);",
			"    }",
			"",
			"    // get the sum of all the element [l..r]",
			"    T at(int l, int r) {",
			"        // assert(0 <= l and l <= r and r < n);",
			"        return query(r) - (l - 1 >= 0 ? query(l - 1) : 0);",
			"    }",
			"};"
		],
		"description": "binary indexed tree"
	},
	"segmenttree": {
		"prefix": "segmenttree",
		"body": [
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"SGT st(n , arr);",
			"",
			"*/",
			"",
			"struct SGT {",
			"    struct Node {",
			"        int val ; // may change",
			"        Node() { // Identity element",
			"            val = 0 ;    // may change // warning it is for query answers only what should be the output answer ",
			"            // val = power(2 , 30) - 1 ;    // may change",
			"            // val = INF ;    // may change",
			"            // val = -INF ;    // may change",
			"        }",
			"        Node(int p1) {  // Actual Node",
			"            val = p1 ; // may change",
			"        }",
			"        void merge(Node &l , Node &r) { // Merge two child nodes",
			"            val = (l.val + r.val) ;  // may change",
			"        }",
			"    };",
			"    struct Update { // note if mentioned about update then only it is used ",
			"        int val ; // may change",
			"        Update(int p1) { // Actual Update",
			"            val = p1 ; // may change",
			"        }",
			"        void apply(Node &a) { // apply update to given node",
			"            a.val = val ; // may change",
			"        }",
			"    };",
			"",
			"    vector<Node > tree ; // it will change according to the node ",
			"    vector<int > arr ; // type may change ",
			"    int n , s ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    SGT(int array_len, vector<int> &a) { // change if type updated",
			"        arr = a ;",
			"        n = array_len ; ",
			"        s = 1 ;",
			"        while(s < 2 * n) {",
			"            s = (s << 1);",
			"        }",
			"        tree.resize(s); ",
			"        fill(all(tree), Node()) ;",
			"        build(1 , 0 , n - 1) ;",
			"    }",
			"    void build(int index, int start, int end)  // Never change this",
			"    {",
			"        if(start == end){",
			"            tree[index] = Node(arr[start]) ; // may change ",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(2 * index, start, mid) ;",
			"        build(2 * index + 1, mid + 1, end) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void update( int index, int start, int end, int query_index, Update &u)  // Never Change this",
			"    {",
			"        if(start == end){",
			"            u.apply(tree[index]) ;",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        if(mid >= query_index)",
			"            update(2 * index, start, mid, query_index, u);",
			"        else",
			"            update(2 * index + 1, mid + 1, end, query_index, u) ;",
			"        tree[index].merge(tree[2 * index], tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int index, int start, int end, int left, int right) { // may change ",
			"        if(start > right || end < left) // may change // both if statements can be removed",
			"            return Node() ;",
			"        if(start >= left && end <= right) // may change // both if statements can be removed",
			"            return tree[index] ; ",
			"        int mid = (start + end) / 2 ; ",
			"        Node l , r , ans ; ",
			"        l = query(2 * index , start , mid , left, right) ; ",
			"        r = query(2 * index + 1 , mid + 1 , end , left , right) ; ",
			"        ans.merge(l , r) ; ",
			"        return ans ; ",
			"    }",
			"    void make_update(int index, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val); // may change",
			"        update(1 , 0 , n - 1 , index , new_update) ;",
			"    }",
			"    Node make_query(int left , int right) { // may change",
			"        return query(1 , 0 , n - 1 , left , right) ; // may change",
			"    }",
			"    int first(){",
			"        return tree[1].val ;",
			"    }",
			"    void output(){",
			"        for(int i = 1 ; i < s ; ++i){",
			"            cout << tree[i].val <<  \" \" ;",
			"        }",
			"        cout << \"\\n\" ;",
			"    }",
			"};",
			""
		],
		"description": "segmenttree"
	},
	"simple_lazysegmenttree": {
		"prefix": "simple_lazysegmenttree",
		"body": [
			"struct node{",
			"    int sum ;",
			"    int lazy ;",
			"    node(){",
			"        sum = 0 ;",
			"        lazy = 0 ;",
			"    }",
			"    node(int val){",
			"        sum = val ;",
			"        lazy = 0 ;",
			"    }",
			"    void merge(node &low , node &high){",
			"        sum = (low.sum + high.sum) ;",
			"    }",
			"};",
			"",
			"struct LazySegmentTree{",
			"    vector<node > tree ;",
			"    vector<int > arr ;",
			"    int N ;",
			"    LazySegmentTree(int n , vector<int > &vec){",
			"        N = n ;",
			"        arr = vec ;",
			"        tree.resize(4 * n,node());",
			"    }",
			"    void build(int index , int start , int end){",
			"        if(start == end){",
			"            tree[index] = node(arr[start]) ;",
			"            return ;",
			"        }",
			"        int mid = (end + start) / 2 ;",
			"        build(index * 2 , start , mid) ;",
			"        build(index * 2 + 1 , mid + 1 , end) ;",
			"        tree[index].merge(tree[index * 2] , tree[index * 2 + 1]) ;",
			"    }",
			"    void update(int index , int start , int end , int update_start , int update_end , int val){",
			"        push(index , start , end) ;",
			"        if(end < update_start || start > update_end){",
			"            return ;",
			"        }",
			"        if(update_start <= start and end <= update_end){",
			"            tree[index].lazy += val ;",
			"            push(index , start , end) ;",
			"            return ;",
			"        }",
			"        int mid = (end + start) / 2 ;",
			"        update(index * 2, start, mid, update_start, update_end, val);",
			"        update(index * 2 + 1, mid + 1, end, update_start, update_end, val);",
			"        tree[index].merge(tree[index * 2], tree[index * 2 + 1]);",
			"    }",
			"    void push(int index , int start , int end){ // make update to this than push",
			"        if(tree[index].lazy){",
			"            // if there is a lazy, apply and push down",
			"            // apply logic",
			"            tree[index].sum += (end - start + 1) * tree[index].lazy ;",
			"",
			"            // push down logic",
			"            if(start != end){",
			"                tree[index * 2].lazy += tree[index].lazy ;",
			"                tree[index * 2 + 1].lazy += tree[index].lazy ;",
			"            }",
			"",
			"            // clear",
			"            tree[index].lazy = 0 ;",
			"        }",
			"    }",
			"    node query(int index, int start, int end, int q_start, int q_end){",
			"        push(index, start, end);",
			"",
			"        if(end < q_start || q_end < start){",
			"            return node();",
			"        } ",
			"        if(q_start <= start && end <= q_end){",
			"            return tree[index];",
			"        }",
			"        int mid = (start + end) / 2;",
			"        node left = query(index * 2, start, mid, q_start, q_end);",
			"        node right = query(index * 2 + 1, mid + 1, end, q_start, q_end);",
			"        node ans = node();",
			"        ans.merge(left, right);",
			"        return ans;",
			"    }",
			"    void ouput_tree(){",
			"        for(int i=0;i<N*4;++i){",
			"            cout<<tree[i].sum<<\" \";",
			"        }",
			"        cout << nl;",
			"    }",
			"};"
		],
		"description": "simple_lazysegmenttree"
	},
	"mosalgorithm": {
		"prefix": "mosalgorithm",
		"body": [
		  "const int NN = 2e5+1 ; // warning don't exceed 1e7+1e6 ;",
			"int block_size ;",
			"vector<int > v(NN) ;",
			"vector<int > freq(NN) ;",
			"int answer = 0 ;",
			"",
			"struct Query { // name of the structure",
			"    int l , r , idx ;",
			"",
			"    Query(int _l , int _r , int _idx) : l(_l) , r(_r) , idx(_idx) { // These lines initialize the member variables with the values passed as arguments to the constructor.",
			"",
			"    } // defining a constructor for a structure. The constructor initializes three member variables: l, r, and idx, presumably within the context of that structure.",
			"",
			"    bool operator<(Query other) const // sort the queries",
			"    {",
			"        return make_pair(l / block_size, r) <            // jaadu",
			"                make_pair(other.l / block_size, other.r);",
			"    }",
			"};",
			"",
			"void remove(int idx) { // TODO: remove value at idx from data structure",
			"    ",
			"}  ",
			"void add(int idx) {  // TODO: add value at idx from data structure",
			"    ",
			"}    ",
			"int get_answer() { // TODO: extract the current answer of the data structure",
			"    return answer ;",
			"}  ",
			"",
			"vector<int > mo_s_algorithm(vector<Query > queries) {",
			"    vector<int > answers(queries.size()) ;",
			"    sort(queries.begin(), queries.end()) ;",
			"",
			"    // TODO: initialize data structure",
			"",
			"    int cur_l = 0 ;",
			"    int cur_r = -1 ;",
			"    // invariant: data structure will always reflect the range [cur_l, cur_r]",
			"    for (Query q : queries) {",
			"        while (cur_l > q.l) {",
			"            cur_l-- ;",
			"            freq[v[cur_l]] += 1 ;",
			"            add(cur_l) ;",
			"        }",
			"        while (cur_r < q.r) {",
			"            cur_r++ ;",
			"            freq[v[cur_r]] += 1 ;",
			"            add(cur_r) ;",
			"        }",
			"        while (cur_l < q.l) {",
			"            remove(cur_l) ;",
			"            freq[v[cur_l]] -= 1 ;",
			"            cur_l++ ;",
			"        }",
			"        while (cur_r > q.r) {",
			"            remove(cur_r) ;",
			"            freq[v[cur_r]] -= 1 ;",
			"            cur_r-- ;",
			"        }",
			"        answers[q.idx] = get_answer() ;",
			"    }",
			"    return answers ;",
			"}",
			"",
			"/*",
			"",
			"    Time complexity : very important O(Q * logQ) for sorting +(plus) Q * root(n)",
			"    for all query combined maximum range covered is root(n)",
			"",
			"    define block_size as",
			"    {",
			"        int sq = sqrtl(n) ;",
			"        block_size = sqrtl(n) + (n % sq == 0 ? 0 : 1) ;",
			"    }",
			"",
			"    vector<Query > queries ;",
			"    vector<int > got_it = mo_s_algorithm(queries) ;",
			"    for(int i = 0 ; i < q ; ++i){",
			"        cout << got_it[i] << nl ;",
			"    }",
			"",
			"*/"
		],
		"description": "mosalgorithm"
	},
	"lazysegmenttree": {
		"prefix": "priyansh_lazysegmenttree",
		"body": [
			"// Lazy Segment Tree with Range Updates and Range Queries",
			"// Supports multiple Segment Trees with just a change in the Node and Update",
			"// Very few changes required everytime",
			"",
			"",
			"struct LazySGT {",
			"    struct Node {",
			"        int val ; // may change",
			"        // int sum ;",
			"        // int sq ;",
			"        Node() { // Identity element",
			"            val = 0 ;    // may change // warning it is for query answers only what should be the output answer ",
			"            // val = power(2 , 30) - 1 ;",
			"            // val = INF ;",
			"            // val = -INF ;",
			"        }",
			"        Node(int p1) {  // Actual Node",
			"            val = p1 ; // may change",
			"        }",
			"        void merge(Node &l , Node &r) { // Merge two child nodes",
			"            val = (l.val + r.val) ;  // may change",
			"        }",
			"    };",
			"",
			"    struct Update {",
			"        int val ; // may change",
			"        // int sum ;",
			"        // int sq ;",
			"        Update(){ // Identity update",
			"            val = 0 ;",
			"        }",
			"        Update(int val1) { // Actual Update",
			"            val = val1 ;",
			"        }",
			"        void apply(Node &a, int start, int end) { // apply update to given node what should be the new value of a node if we are making a quesry to update a range",
			"            a.val = val * (end - start + 1) ; // may change",
			"            // a.val += val * (end - start + 1) ; ",
			"            // a.val = val ; ",
			"            // a.val += val ; ",
			"        }",
			"        void combine(Update& new_update , int start , int end){ // it is like over writing the value means ex:-> change all the value of elemnts to x then val = new_update.val else we can add , mult , divide or sub",
			"            val = new_update.val ;",
			"            // val += new_update.val ;",
			"        }",
			"    };",
			"",
			"    vector<Node > tree ; // no change",
			"    vector<bool > lazy ; // no change",
			"    vector<Update > updates ; // no change",
			"    vector<int > arr ; // type may change",
			"    int n ;",
			"    int sz ; // 2^k where k is the least integer which satisfy 2^k >= n",
			"    LazySGT(int array_len , vector<int > &a) { // change if type updated",
			"        arr = a ;",
			"        n = array_len ;",
			"        sz = 1 ;",
			"        while(sz < 2 * n){",
			"            sz = (sz << 1) ;",
			"        }",
			"        tree.resize(sz) ; fill(all(tree) , Node()) ;",
			"        lazy.resize(sz) ; fill(all(lazy) , false) ;",
			"        updates.resize(sz) ; fill(all(updates) , Update()) ;",
			"        build(1 , 0 , n - 1) ;",
			"    }",
			"    void build(int index , int start , int end) { // Never change this",
			"        if (start == end)   {",
			"            tree[index] = Node(arr[start]) ; // no changes",
			"            return ;",
			"        }",
			"        int mid = (start + end) / 2 ;",
			"        build(2 * index, start , mid) ;",
			"        build(2 * index + 1 , mid + 1 , end) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    void pushdown(int index , int start , int end){",
			"        if(lazy[index]){",
			"            int mid = (start + end) / 2 ; ",
			"            apply(2 * index , start , mid , updates[index]) ;",
			"            apply(2 * index + 1 , mid + 1 , end , updates[index]) ;",
			"            updates[index] = Update() ;",
			"            lazy[index] = 0 ;",
			"        }",
			"    }",
			"    void apply(int index , int start , int end , Update& u){",
			"        if(start != end){",
			"            lazy[index] = 1 ; // no changes",
			"            updates[index].combine(u , start , end) ; // it is applied on non array elements that is the parent elements on the array elements it used for new updates ",
			"        }",
			"        u.apply(tree[index] , start , end) ; // it is applied on one element only change according to the question ",
			"    }",
			"    void update(int index, int start, int end, int left, int right, Update &u) {  // Never Change this // O(logn) ",
			"        if(start > right || end < left)",
			"            return ;",
			"        if(start >= left && end <= right){",
			"            pushdown(index , start , end) ;",
			"            apply(index , start , end , u) ;",
			"            return ;",
			"        }",
			"        pushdown(index , start , end) ; // doing for both query and updates ",
			"        int mid = (start + end) / 2 ;",
			"        update(2 * index , start , mid , left , right , u) ;",
			"        update(2 * index + 1 , mid + 1 , end , left , right , u) ;",
			"        tree[index].merge(tree[2 * index] , tree[2 * index + 1]) ;",
			"    }",
			"    Node query(int index, int start, int end, int left, int right) { // Never change this",
			"        if (start > right || end < left)",
			"            return Node(); // warning it is for query answers only what should be the output answer",
			"        if (start >= left && end <= right){",
			"            pushdown(index , start , end) ;",
			"            return tree[index] ;",
			"        }",
			"        pushdown(index , start , end) ; // doing for both query and updates ",
			"        int mid = (start + end) / 2 ;",
			"        Node l , r , ans ;",
			"        l = query(2 * index , start , mid , left , right) ;",
			"        r = query(2 * index + 1 , mid + 1 , end , left , right) ;",
			"        ans.merge(l , r) ;",
			"        return ans ;",
			"    }",
			"    void make_update(int left, int right, int val) {  // pass in as many parameters as required",
			"        Update new_update = Update(val) ; // may change",
			"        update(1 , 0 , n - 1 , left , right , new_update) ;",
			"    }",
			"    Node make_query(int left, int right) {",
			"        return query(1 , 0 , n - 1 , left , right) ;",
			"    }",
			"    int first(){",
			"        return tree[1].val ;",
			"    }",
			"    void output1(){",
			"        for(int i = 0 ; i < sz ; ++i){",
			"            cout << tree[i].val <<  \" \" ;",
			"        }",
			"        cout << \"\\n\" ;",
			"    }",
			"    void output2(){",
			"        for(int i = 0 ; i < sz ; ++i){",
			"            cout << updates[i].val <<  \" \" ;",
			"        }",
			"        cout << \"\\n\" ;",
			"    }",
			"};",
			"",
			"",
			"/*",
			"",
			"How to define our segment tree in the main function",
			"vector<int > arr = {1 , 2 , 3 , 4} ;",
			"",
			"LazySGT lst(n , arr)",
			"",
			"*/"
		],
		"description": "lazysegmenttree"
	},
	"Template 1": {
		"prefix": "dsu",
		"body": [
		"struct DSU {",
		"    int S ; ",
		"    struct node {",
		"        int p; int siz; int rnk; // by rank, it's based on the height of the trees, while by size, it's based on the number of elements in the sets. ",
		"        // Merging the smaller tree into the larger one helps maintain a more balanced structure.",
		"    };",
		"    vector<node > dsu ; ",
		"    vector<pair<int , node > > history ; // Store history for rollback ",
		"",
		"    DSU(int n) { ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0; ",
		"            dsu.push_back(tmp) ; ",
		"        }",
		"    }",
		"",
		"    void reset(int n) {",
		"        dsu.clear() ; ",
		"        S = n ; ",
		"        for(int i = 0 ; i < n ; ++i) {",
		"            node tmp ; ",
		"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0; ",
		"            dsu.push_back(tmp) ; ",
		"        }",
		"    }",
		"",
		"    int parent(int u) {",
		"        if(dsu[u].p == u) return u;",
		"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
		"        return dsu[u].p ; ",
		"    }",
		"",
		"    void mergebysize(int u, int v) {",
        "        u = parent(u); v = parent(v);",
        "        if(u == v) return ;",
        "        if(dsu[u].siz < dsu[v].siz) swap(u , v) ; ",
        "        history.push_back({u, dsu[u]}) ;",
        "        history.push_back({v, dsu[v]}) ;",
        "        dsu[v].p = u ; ",
        "        dsu[u].siz += dsu[v].siz ; ",
        "    }",
        "",
        "    void mergebyrank(int u, int v) {",
        "        u = parent(u); v = parent(v);",
        "        if(u == v) return ;",
        "        history.push_back({u, dsu[u]}) ;",
        "        history.push_back({v, dsu[v]}) ;",
        "        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v ;",
        "        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u ;",
        "        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1 ; ",
        "    }",
        "",
        "    void rollback() { // Each union operation typically involves merging two sets (represented by their representatives) into one. Therefore, when rolling back a union operation, you need to undo the changes for both sets involved in that operation.",
        "        if(history.empty()) return ; // Nothing to rollback",
        "        auto &i = history.back() ; // Retrieve the information about the last union operation",
        "        int u = i.first ;",
        "        auto state_u = i.second ;",
        "        history.pop_back() ;",
        "        dsu[u] = state_u ;",
        "",
        "        if(!history.empty()) {",
        "            pair<int,node> ii = history.back() ; // Retrieve the information about the second-to-last union operation",
        "            int v = ii.first ;",
        "            node state_v = ii.second ; // try to avoid auto because it makes error while using long long",
        "            history.pop_back() ;",
        "            dsu[v] = state_v ;",
        "        }",
        "    }",
		"",
		"    bool same(int u, int v) {",
		"        if(parent(u) == parent(v)) return true ; ",
		"        return false ; ",
		"    }",
		"",
		"    int get_size(int u) {",
		"        return dsu[parent(u)].siz ; ",
		"    }",
		"};"
		],
		"description": "Template 1"
	},
	"template 7": {
		"prefix": "dijkstra",
		"body": [
			"// // O(VlogV + ElogV) " ,
			"class Solution",
			"{",
			"public:",
			"    vector<int> shortestPath(int n, int m, vector<vector<int>> &edges)",
			"    {",
			"        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}",
			"        // where the edge weight is the weight of the edge from node1 to node2.",
			"        vector< pair< int , int > > adj[n + 1] ;",
			"        for (auto &i : edges)",
			"        {",
			"            adj[i[0]].push_back({i[1], i[2]});",
			"            adj[i[1]].push_back({i[0], i[2]});",
			"        }",
			"        // Create a priority queue for storing the nodes along with distances ",
			"        // in the form of a pair { dist, node }.",
			"        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int , int> > > pq;",
			"",
			"        // Create a dist array for storing the updated distances and a parent array for storing the nodes from where the current nodes represented by indices of the parent array came from.",
			"        vector<int > dist(n + 1 , 1e9) , parent(n + 1) , vis(n + 1 , 0) ;",
			"        for (int i = 1 ; i <= n ; ++i)",
			"            parent[i] = i ;",
			"",
			"        dist[1] = 0 ;",
			"",
			"        // Push the source node to the queue.",
			"        pq.push({0, 1});",
			"        // keeping visited vector is important because it was giving TLE for cses problem shortest route 1 for two test cases",
			"        while (!pq.empty())",
			"        {",
			"            // Topmost element of the priority queue is with minimum distance value.",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int dis = it.first ;",
			"            if(vis[node]) continue ;" ,
			"            vis[node] = 1 ;" ,
			"",
			"            // Iterate through the adjacent nodes of the current popped node.",
			"            for (auto it : adj[node])",
			"            {",
			"                int adjNode = it.first;",
			"                int edW = it.second;",
			"",
			"                // Check if the previously stored distance value is greater than the current computed value or not, if yes then update the distance value.",
			"                if (dis + edW < dist[adjNode])",
			"                {",
			"                    dist[adjNode] = dis + edW;",
			"                    pq.push({dis + edW, adjNode});",
			"",
			"                    // Update the parent of the adjNode to the recent node where it came from.",
			"                    parent[adjNode] = node;",
			"                }",
			"            }",
			"        }",
			"",
			"        // If distance to a node could not be found, return an array containing -1.",
			"        if (dist[n] == 1e9)",
			"            return {-1};",
			"",
			"        // Store the final path in the path array.",
			"        vector<int> path ;",
			"        int node = n ;",
			"",
			"        // Iterate backwards from destination to source through the parent array.",
			"        while (parent[node] != node)",
			"        {",
			"            path.push_back(node) ;",
			"            node = parent[node] ;",
			"        }",
			"        path.push_back(1) ;",
			"",
			"        // Since the path stored is in a reverse order, we reverse the array to get the final answer and then return the array.",
			"        reverse(path.begin() , path.end()) ;",
			"        return path ;",
			"    }",
			"};"
		],
		"description": "template 7"
	},
	"template 8": {
		"prefix": "bellmanford",
		"body": [
			"// Problem Statement: Given a weighted, directed and connected graph ",
			"// of V vertices and E edges, Find the shortest distance of all the ",
			"// vertices from the source vertex S for negative edges.",
			"class Solution {",
			"public:",
			"    /*  Function to implement Bellman Ford",
			"    *   edges: vector of vectors which represents the graph",
			"    *   S: source vertex to start traversing graph with",
			"    *   V: number of vertices",
			"    */",
			"    vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {",
			"        vector<int > dist(V + 1 , 1e8) ; // when the vertices are starting from 1 (V + 1) else (V)",
			"        dist[S] = 0 ;",
			"        for (int i = 0 ; i < V ; ++i) { // when the vertices are starting from 1 (V) else (V - 1)",
			"            for (auto it : edges) {",
			"                int u = it[0] ;",
			"                int v = it[1] ;",
			"                int wt = it[2] ;",
			"                if (dist[u] + wt < dist[v]){ // will not be using dist[u] != 1e8 it showed wrong answer on coding ninjas",
			"                    dist[v] = dist[u] + wt ;",
			"                }",
			"            }",
			"        }",
			"        // Nth relaxation to check negative cycle // only when it is not mentioned that it will form a cycle",
			"        for (auto it : edges) {",
			"            int u = it[0] ;",
			"            int v = it[1] ;",
			"            int wt = it[2] ;",
			"            if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {",
			"                return {-1} ;",
			"            }",
			"        }",
			"",
			"        return dist ;",
			"    }",
			"};"
		],
		"description": "template 8"
	},
	"template 9": {
		"prefix": "floydwarshall",
		"body": [
			"// Problem Statement: The problem is to find the shortest distances between ",
			"// every pair of vertices in a given edge-weighted directed graph. ",
			"// The graph is represented as an adjacency matrix of size n*n. ",
			"// Matrix[i][j] denotes the weight of the edge from i to j. ",
			"// If Matrix[i][j]=-1, it means there is no edge from i to j.",
			"class Solution {",
			"public:",
			"    void shortest_distance(vector<vector<int>>&matrix) {",
			"        int n = matrix.size();",
			"        // required when dirently using in the main function",
			"        // vector<vector<long long > > matrix(n + 1 , vector<long long > (n + 1 , -1)) ; // required when dirently using in the main function",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0 ; j < n ; ++j){",
			"                if (matrix[i][j] == -1){",
			"                    matrix[i][j] = 1e9 ;",
			"                }",
			"                if (i == j) matrix[i][j] = 0 ;",
			"            }",
			"        }",
			"",
			"        for (int k = 0 ; k < n ; ++k){ // asked in dp with bit masking problems ",
			"            for (int i = 0 ; i < n ; ++i){",
			"                for (int j = 0 ; j < n ; ++j){",
			"                    if(matrix[i][k] != 1e9 and matrix[k][j] != 1e9){ // important giving wrong answer on coding ninjas",
			"                        matrix[i][j] = min(matrix[i][j] , matrix[i][k] + matrix[k][j]) ;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        // required according to the problem statement ",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < n; j++) {",
			"                if (matrix[i][j] == 1e9) {",
			"                    matrix[i][j] = -1;",
			"                }",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "template 9"
	},
	"prims": {
		"prefix": "prim'salgorithm",
		"body": [
			"// Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.(A Minimum Spanning Tree (MST) is a subset of edges of a connected weighted undirected graph that connects all the vertices together with the minimum possible total edge weight.)",
			"// (Sometimes it may be asked to find the MST as well, where in the MST the edge-informations will be stored in the form {u, v}(u = starting node, v = ending node).)",
			"#include <bits/stdc++.h>",
			"using namespace std ;",
			"",
			"class Solution {",
			"public:",
			"    // Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[]) {",
			"        priority_queue<pair<int, int > , vector<pair<int, int > > , greater<pair<int, int > > > pq ;",
			"",
			"        vector<int> vis(V , 0) ;",
			"",
			"        // {wt, node}",
			"        pq.push({0 , 0}) ;",
			"        int sum = 0 ;",
			"        while(!pq.empty()) {",
			"            auto it = pq.top() ;",
			"            pq.pop() ;",
			"            int node = it.second ;",
			"            int wt = it.first ;",
			"",
			"            if (vis[node] == 1) continue ;",
			"            vis[node] = 1 ;",
			"            sum += wt ;",
			"",
			"            for (auto it : adj[node]) {",
			"                int adjNode = it[0] ;",
			"                int edW = it[1] ;",
			"                if(!vis[adjNode]) {",
			"                    pq.push({edW , adjNode}) ;",
			"                }",
			"            }",
			"        }",
			"",
			"        return sum ;",
			"    }",
			"};",
			"",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int > > adj[V] ;",
			"    for (auto it : edges) {",
			"        vector<int> tmp(2) ;",
			"        tmp[0] = it[1] ;",
			"        tmp[1] = it[2] ;",
			"        adj[it[0]].push_back(tmp) ;",
			"",
			"        tmp[0] = it[0] ;",
			"        tmp[1] = it[2] ;",
			"        adj[it[1]].push_back(tmp) ;",
			"    }",
			"",
			"    Solution obj ; // creating an instance(object) of the Solution class. ",
			"    // By creating an object of the class you can access its methods and attributes",
			"    int sum = obj.spanningTree(V , adj) ;",
			"    cout << \"The sum of all the edge weights: \" << sum << \"\\n\";",
			"",
			"    return 0;",
			"}"
		],
		"description": "prims"
	},
	"kruskal": {
		"prefix": "kruskal'salgorithm",
		"body": [
			"// Problem Statement: Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"struct DSU {",
			"    int S ; ",
			"    struct node {",
			"        int p; int siz; int rnk;",
			"    };",
			"    vector<node > dsu ; ",
			"",
			"    DSU(int n) { ",
			"        S = n ; ",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            node tmp ; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp) ; ",
			"        }",
			"    }",
			"",
			"    void reset(int n) {",
			"        dsu.clear() ; ",
			"        S = n ; ",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            node tmp ; ",
			"            tmp.p = i; tmp.siz = 1; tmp.rnk = 0;",
			"            dsu.push_back(tmp) ; ",
			"        }",
			"    }",
			"",
			"    int parent(int u) {",
			"        if(dsu[u].p == u) return u;",
			"        dsu[u].p = parent(dsu[u].p) ; // Time Complexity O(log n)",
			"        return dsu[u].p ; ",
			"    }",
			"",
			"    void mergebysize(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return ;",
			"        if(dsu[u].siz < dsu[v].siz) swap(u , v) ; ",
			"        dsu[v].p = u ; ",
			"        dsu[u].siz += dsu[v].siz ; ",
			"    }",
			"",
			"    void mergebyrank(int u, int v) {",
			"        u = parent(u); v = parent(v);",
			"        if(u == v) return ;",
			"        if(dsu[u].rnk < dsu[v].rnk) dsu[u].p = v ;",
			"        if(dsu[u].rnk > dsu[v].rnk) dsu[v].p = u ;",
			"        if(dsu[u].rnk == dsu[v].rnk) dsu[v].p = u , dsu[u].rnk += 1 ; ",
			"    }",
			"",
			"    bool same(int u, int v) {",
			"        if(parent(u) == parent(v)) return true ; ",
			"        return false ; ",
			"    }",
			"",
			"    int get_size(int u) {",
			"        return dsu[parent(u)].siz ; ",
			"    }",
			"};",
			"",
			"struct edge {",
			"    int u ;",
			"    int v ;",
			"    int weight ;",
			"};",
			"",
			"class Solution {",
			"public:",
			"    //Function to find sum of weights of edges of the Minimum Spanning Tree.",
			"    int spanningTree(int V, vector<vector<int>> adj[]) { // spanningTree is a method of the class Solution",
			"",
			"        vector<edge> edges;",
			"        for (int i = 0; i < V; i++) {",
			"            for (auto it : adj[i]) {",
			"                int adjNode = it[0];",
			"                int wt = it[1];",
			"                int node = i;",
			"",
			"                edge e ; // Create an instance of the edge struct",
			"                e.u = node ;",
			"                e.v = adjNode ;",
			"                e.weight = wt ;",
			"                edges.push_back(e) ; // Add the edge to the edges vector",
			"            }",
			"        }",
			"        DSU dsu(V) ;",
			"        sort(edges.begin(), edges.end()); ",
			"        int mstWt = 0;",
			"        // time complexity o(no. of Edges * 4 * aplha * 2) ",
			"        for (auto &[src , dest , weight] : edges) { // it will work on codeforces but won't work on many platforms",
			"            int wt = weight ;",
			"            int u = src ;",
			"            int v = dest ;",
			"",
			"            if (dsu.parent(u) != dsu.parent(v)) {",
			"                mstWt += wt;",
			"                dsu.mergebysize(u, v);",
			"            }",
			"        }",
			"",
			"        return mstWt;",
			"    }",
			"};",
			"",
			"int main() {",
			"",
			"    int V = 5;",
			"    vector<vector<int > > edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};",
			"    vector<vector<int > > adj[V] ;",
			"    for (auto &it : edges) {",
			"        vector<int> tmp(2);",
			"        tmp[0] = it[1];",
			"        tmp[1] = it[2];",
			"        adj[it[0]].push_back(tmp);",
			"",
			"        tmp[0] = it[0];",
			"        tmp[1] = it[2];",
			"        adj[it[1]].push_back(tmp);",
			"    }",
			"",
			"    Solution obj ; // creating an instance(object) of the Solution class. ",
			"    // By creating an object of the class you can access its methods and attributes",
			"    int mstWt = obj.spanningTree(V , adj) ;",
			"    cout << \"The sum of all the edge weights: \" << mstWt << \"\\n\" ;",
			"    return 0 ;",
			"}"
		],
		"description": "kruskal"
	},
	"bridges in graph": {
		"prefix": "bridges in graph",
		"body": [
			"int n; // number of nodes",
			"vector<vector<int>> adj ; // adjacency list of graph",
			"vector<bool> visited;",
			"vector<int> tin, low;",
			"int timer;",
			"",
			"void dfs(int v, int p , vector<vector<int>> &bridges) {",
			"    visited[v] = true;",
			"    tin[v] = low[v] = timer++;",
			"    for(int to : adj[v]){",
			"        if(to==p) continue;",
			"        if(visited[to]) {",
			"            low[v] = min(low[v], tin[to]);",
			"        } ",
			"        else{",
			"            dfs(to, v, bridges);",
			"            low[v] = min(low[v], low[to]);",
			"            if (low[to] > tin[v]){",
			"                bridges.push_back({v, to});",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"void find_bridges() {",
			"    timer = 0;",
			"    visited.assign(n, false);",
			"    tin.assign(n, -1);",
			"    low.assign(n, -1);",
			"    vector<vector<int>> bridges ;",
			"    for (int i = 0; i < n; ++i){",
			"        if (!visited[i]){",
			"            dfs(i, -1, bridges);",
			"        }",
			"    }",
			"}"
		],
		"description": "bridges in graph"
	},
	"Articulation points": {
		"prefix": "Articulation points",
		"body": [
			"int n; // number of nodes",
			"vector<vector<int > > adj; // adjacency list of graph",
			"vector<bool > visited;",
			"vector<int > tin , low;",
			"int timer;",
			"",
			"void dfs(int v, int p , vector<int > &ans) {",
			"    visited[v] = true;",
			"    tin[v] = low[v] = timer++;",
			"",
			"    int children = 0;",
			"",
			"    for (int to : adj[v]) {",
			"        if (to == p) continue;",
			"",
			"        if (visited[to]) {",
			"            low[v] = min(low[v], tin[to]);",
			"        } ",
			"        else {",
			"            dfs(to , v , ans);",
			"            low[v] = min(low[v], low[to]);",
			"",
			"            if (low[to] >= tin[v] && p != -1){",
			"                if(ans.find(v) == ans.end())",
			"                   ans.pb(v);",
			"            }",
			"",
			"            ++children;",
			"        }",
			"    }",
			"",
			"    if (p == -1 && children > 1){",
			"        ans.pb(v);",
			"    }",
			"}",
			"",
			"void find_cutpoints() {",
			"    timer = 0;",
			"    visited.assign(n, false);",
			"    tin.assign(n, -1);",
			"    low.assign(n, -1);",
			"    vector<int > ans ;",
			"    for (int i = 0; i < n; ++i) {",
			"        if (!visited[i]){",
			"            dfs(i , -1 , ans);",
			"        }",
			"    }",
			"}"
		],
		"description": "Articulation points"
	},
	"binary lifting and lca": {
		"prefix": "binary lifting and lca",
		"body": [
			"",
			"/*",
			"Sparse Table: Binary lifting can be seen as a type of sparse table data structure ",
			"that is customized for trees. It precomputes and stores information about the ",
			"ancestors of each node, allowing for quick LCA queries.",
			"Binary lifting is primarily used for finding the lowest common ancestor (LCA) of two nodes in a tree",
			"this technique itself is applicable to both rooted and unrooted trees not for graphs.",
			"Preprocessing: In binary lifting, you typically preprocess the tree to create ",
			"a data structure that helps answer LCA queries efficiently. This data structure ",
			"often involves storing the ancestors of each node at various power-of-2 levels in the tree.",
			"Time = O(logn) for each query",
			"*/",
			"",
			"",
			"int n ; // number of nodesi",
			"vector<vector<int > > adj ; // adjacency list of the tree",
			"vector<vector<int > > parent ; // parent[i][j] is the 2^j-th ancestor of node i",
			"vector<int > level ; // level of each node",
			"int maxlog = 30 ; // maximum value of x such that 2^x <= n",
			"vector<int > logValues ; // logValues[] is the largest x such that 2^x <= i",
			"vector<bool > visited ;",
			"// vector<int> *edges ----> meaning ----> // Declaring a pointer to a vector of integers",
			"",
			"void BinaryLifting(int n , int root) { ",
			"    parent.resize(n) ;",
			"    level.resize(n) ;",
			"    visited.resize(n) ;",
			"    for (int i = 0 ; i < n ; ++i) {",
			"        parent[i].resize(maxlog + 1) ;",
			"        for (int j = 0; j <= maxlog; ++j) {",
			"            parent[i][j] = -1 ;",
			"        }",
			"    }",
			"    precomputeLogs() ;",
			"    getLevel(root , -1) ;",
			"    dfsBinaryLifting(root, visited) ;",
			"    fillParentTable(root) ;",
			"}",
			"",
			"void fillParentTable(int root) {",
			"    int intermediate = -1 ;",
			"    for (int i = 1; i <= maxlog; ++i) {",
			"        for (int j = 0; j < n; ++j) {",
			"            intermediate = parent[j][i - 1] ;",
			"            if (intermediate != -1) {",
			"                parent[j][i] = parent[intermediate][i - 1] ;",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"void dfsBinaryLifting(int root , vector<bool > &visited) {",
			"    visited[root] = true ;",
			"    for (auto &i : adj[root]) {",
			"        if (!visited[i]) {",
			"            parent[i][0] = root ; // 2^0-th parent of i",
			"            dfsBinaryLifting(i, visited) ;",
			"        }",
			"    }",
			"}",
			"",
			"void getLevel(int root , int parent) { ",
			"    for (auto &i : adj[root]) { // ",
			"        if (i != parent) {",
			"            level[i] = level[root] + 1 ;",
			"            getLevel(i, root) ;",
			"        }",
			"    }",
			"}",
			"",
			"void precomputeLogs() {",
			"    logValues.resize(maxlog + 1) ;",
			"    logValues[1] = 0 ;",
			"    for (int i = 2 ; i <= maxlog ; ++i) {",
			"        logValues[i] = logValues[i / 2] + 1 ;",
			"    }",
			"}",
			"",
			"int kthParent(int start, int k) { // k can be upto 1e9, In this we have only one node and we have to calculate its parent by traversing in powers of 2 ",
			"    int a = start ;",
			"    while (k > 0) { // k is the distance from the start node",
			"        int x = getLog(k) ;",
			"        a = parent[a][x] ; // 2^x-th parent of a",
			"        if (a == -1){",
			"            return a ;",
			"        }",
			"        k -= (1 << x) ; // subtracting 2^x from k",
			"    }",
			"    return a ; ",
			"}",
			"",
			"int getLog(int x) { // returns the largest x such that 2^x <= i",
			"    return logValues[x] ;",
			"}",
			"",
			"",
			"int getLCA(int a , int b ){",
			"    if (level[a] > level[b]) {",
			"        swap(a , b) ;",
			"    }",
			"    // for calculating distance multiply by two",
			"    b = kthParent(b , level[b] - level[a]) ; // kth parent of b at level (level[b] - level[a])",
			"    if (a == b) {",
			"        return a ; ",
			"    }",
			"    for (int i = maxlog; i >= 0; --i) {",
			"        if (parent[a][i] != parent[b][i] && parent[a][i] != -1 && parent[b][i] != -1) {",
			"            a = parent[a][i] ;",
			"            b = parent[b][i] ;",
			"        }",
			"    }",
			"    return parent[a][0] ;",
			"}",
			""
		],
		"description": "binary lifting and lca"
	},
	"SCC": {
		"prefix": "Strongly Connected Component",
		"body": [
			"struct SCC { // only valid for directed graph // scc_using_kosaraju_algorithm_not_using_tarjan_algorithm ",
			"    vector<vector<int > > edges , redges ;",
			"    vector<bool > used ;",
			"    vector<int > order , component ;",
			"    int n ;",
			"",
			"    void init(int _n) {",
			"        n = _n ;",
			"        edges = vector<vector<int > > (n) ;",
			"        redges = vector<vector<int > > (n) ;",
			"        order.clear() ;",
			"        component.clear() ;",
			"    }",
			"",
			"    void edge(int u , int v) {",
			"        edges[u].push_back(v) ;",
			"        redges[v].push_back(u) ;",
			"    }",
			"",
			"    void dfs1(int v) {",
			"        used[v] = true ;",
			"        for (size_t i = 0 ; i < edges[v].size() ; ++i) {",
			"            if (!used[edges[v][i]]) {",
			"                dfs1(edges[v][i]) ;",
			"            }",
			"        }",
			"        order.push_back(v) ; // time of exit from the node matters (starting time and finishing time) ",
			"    }",
			"",
			"    void dfs2(int v) {",
			"        used[v] = true ;",
			"        component.push_back(v) ;",
			"        for (size_t i = 0 ; i < redges[v].size() ; ++i) {",
			"            if (!used[redges[v][i]]) {",
			"                dfs2(redges[v][i]) ;",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<vector<int > > run() {",
			"        vector<vector<int > > components ;",
			"        used.assign(n , false) ;",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            if (!used[i]) {",
			"                dfs1(i) ;",
			"            }",
			"        }",
			"",
			"        used.assign(n , false);",
			"        for (int i = 0 ; i < n ; ++i) {",
			"            int v = order[n - 1 - i] ;",
			"            if (!used[v]) {",
			"                dfs2(v) ;",
			"                components.push_back(component) ;",
			"                component.clear() ;",
			"            }",
			"        }",
			"",
			"        return components ;",
			"    }",
			"",
			"    bool visited(int v) {",
			"        return used[v] ;",
			"    }",
			"    void clear() {",
			"        used.assign(n , false) ;",
			"    }",
			"};"
		],
		"description": "SCC"
	},
	"sparse": {
		"prefix": "sparsetable",
		"body": [
			"// O(1) for idempotent O(logN) for general",
			"",
			"struct SparseTable {",
			"    struct Node {",
			"        int val ; // store more info if required // may change",
			"        Node() { // Identity Element",
			"            val = 0 ; // may change",
			"        }",
			"        Node(int v) {",
			"            val = v ;",
			"        }",
			"        void merge(Node &l , Node &r) { // problem",
			"            val = (l.val ^ r.val) ;",
			"        }",
			"    };",
			"",
			"    // here everything is in long long int",
			"    vector<vector<Node > > table ;",
			"    vector<int > logValues ;",
			"    int n ;",
			"    int maxLog ;",
			"    vector<int > a ;",
			"    SparseTable(int n , vector<int > &arr) {",
			"        this->n = n ;",
			"        a = arr ;",
			"        table.resize(n + 1) ;",
			"        maxLog = 60 ;",
			"        logValues.resize(max(maxLog, n + 1)) ;",
			"        logValues[1] = 0 ;",
			"        // 0 1 1 2 2 2 2 3 3 3  3  3  3  3  3  4  . . . . // log values ",
			"        // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . . . . ",
			"        for(int i = 2 ; i <= n ; ++i) {",
			"            logValues[i] = logValues[i / 2] + 1 ;",
			"        }",
			"        for(int i = 0 ; i < n ; ++i) {",
			"            table[i].resize(maxLog + 1) ;",
			"            fill(all(table[i]) , Node()) ;",
			"        }",
			"        build() ;",
			"    }",
			"    void build() {",
			"        for(int i = 0; i < n; i++) {",
			"            table[i][0] = Node(a[i]) ;",
			"        }",
			"        for(int i = 1 ; i <= maxLog ; ++i) {",
			"            for(int j = 0 ; (j + (1ll << i)) <= n ; ++j) {",
			"                table[j][i].merge(table[j][i - 1] , table[j + (1ll << (i - 1))][i - 1]) ;",
			"            }",
			"        }",
			"    }",
			"    Node queryNormal(int left , int right) { // O(log(n))",
			"        Node ans = Node() ;",
			"        for(int j = logValues[right - left + 1] ; j >= 0 ; --j) {",
			"            if((1 << j) <= right - left + 1) {",
			"                ans.merge(ans, table[left][j]) ;",
			"                left += (1ll << j) ; // will not be (j - 1)",
			"            }",
			"        }",
			"        return ans ; ",
			"    }",
			"    Node queryIdempotent(int left, int right) { // O(1)",
			"        int j = logValues[right - left + 1] ;",
			"        Node ans = Node() ;",
			"        ans.merge(table[left][j] , table[right - (1ll << j) + 1][j]) ;",
			"        return ans ;",
			"    }",
			"};",
			""
		],
		"description": "sparse"
	},
	"bitwise": {
		"prefix": "bitwise_TRIE",
		"body": [
			"class Trie {",
			"public:",
			"    struct BITS_TRIE {",
			"        private:",
			"        struct node {",
			"            int start = 0 ;",
			"            int end = 0 ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            node* next[2] ;",
			"            node() {",
			"                next[1] = next[0] = NULL ;",
			"            }",
			"        };",
			"",
			"        node root ;",
			"",
			"        public:",
			"        void insert(int val) {",
			"            node* temp = &root;",
			"            temp->cnt++ ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                if(temp->next[bit] == NULL) {",
			"                    temp->next[bit] = new node() ;",
			"                }",
			"",
			"                temp = temp->next[bit] ;",
			"                temp->cnt++ ;",
			"            }",
			"        }",
			"",
			"        void remove(int val) {",
			"            node* temp = &root;",
			"            temp->cnt-- ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                temp = temp->next[bit] ;",
			"                temp->cnt-- ;",
			"            }",
			"        }",
			"",
			"        int max_xor(int val) {",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i) {",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0) {",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = 1 - bit ; // what we want to maximize opposite of bit because 1 ^ 0 = 1 and 0 ^ 1 = 1",
			"",
			"                if(temp->next[req] == NULL) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0) {",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else {",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"",
			"        int min_xor(int val){",
			"            int ans = 0 ;",
			"            node* temp = &root ;",
			"            for(int i = 31 ; i >= 0 ; --i){",
			"                int bit = 1 ;",
			"                if((val & (1 << i)) == 0){",
			"                    bit = 0 ;",
			"                }",
			"",
			"                int req = bit ; // what we want to minimize",
			"",
			"                if(temp->next[req] == NULL){",
			"                    ans += (1 << i) ;",
			"                    temp = temp->next[1 - req] ;",
			"                }",
			"                else if(temp->next[req]->cnt == 0){",
			"                    ans += (1 << i) ;",
			"                    temp=temp->next[1 - req] ;",
			"                }",
			"                else{",
			"                    temp = temp->next[req] ;",
			"                }",
			"            }",
			"",
			"            return ans ;",
			"        }",
			"    };",
			"};"
		],
		"description": "bitwise"
	},
	"General_Trie": {
		"prefix": "General_Trie",
		"body": [
			"class Trie {",
			"public:",
			"    struct General_Trie {",
			"        struct node {",
			"            node* next[10] ; // declare size of next according to the problem",
			"            int cnt ; // declare cnt according to the problem",
			"            node() {",
			"                cnt = 0 ;",
			"                for(int i = 0 ; i < 10 ; ++i){",
			"                    next[i] = NULL ;",
			"                }",
			"            }",
			"        };",
			"",
			"        node root ;",
			"",
			"        void add(vector<int > &val) { // add function",
			"            node* temp = &root ;",
			"            for(auto &ele : val) {",
			"                if(temp->next[ele] == NULL){",
			"                    temp->next[ele] = new node() ;",
			"                }",
			"                temp = temp->next[ele] ;",
			"                temp->cnt++ ;",
			"            }",
			"        }",
			"",
			"        void remove(vector<int > &val) { // remove function",
			"            node* temp = &root ;",
			"            for(auto &ele : val) {",
			"                if(temp->next[ele] == NULL){",
			"                    break ;",
			"                }",
			"                temp = temp->next[ele] ;",
			"                temp->cnt-- ;",
			"            }",
			"        }",
			"",
			"        int query(vector<int > &val) { // query function",
			"            node* temp = &root ;",
			"            int ans = 0 ;",
			"            for(auto &ele : val) {",
			"                if(temp->next[ele] == NULL){",
			"                    break ;",
			"                }",
			"                ans++ ;",
			"                temp = temp->next[ele] ;",
			"            }",
			"            return ans  ;",
			"        }",
			"    };",
			"};"
		],
		"description": "General_Trie"
	},
	"stringwise_trie": {
		"prefix": "stringwise_trie",
		"body": [
			"class Trie {",
			"public:",
			"    struct STRING_TRIE {",
			"        private:",
			"        struct Node {",
			"            Node* next[26] ;",
			"            bool flag = false ;",
			"            int cnt = 0 ;",
			"            int mn_idx = -1 ;",
			"            int mx_idx = -1 ;",
			"            int max_len = -INT_MAX ;",
			"            int min_len = INT_MAX ;",
			"            int cntEndWith = 0 ;",
			"            int cntPrefix = 0 ;  ",
			"            int end = -1 ;",
			"",
			"            Node(){",
			"                for(int i = 0 ; i < 26 ; ++i){",
			"                    next[i] = nullptr ;",
			"                }",
			"            }",
			"",
			"            bool containsKey(char ch) {",
			"                return (next[ch - 'a'] != nullptr) ; ",
			"            }",
			"            Node* get(char ch) {",
			"                return next[ch - 'a'] ; ",
			"            }",
			"            void put(char ch, Node* node) {",
			"                next[ch - 'a'] = node ; ",
			"            }",
			"            void setEnd() { // comes to the end of the word after inserting set its refernce trie block to true",
			"                flag = true ; ",
			"            }",
			"            bool isEnd() { // check prefix ",
			"                return flag ; ",
			"            }",
			"            void increaseEnd() {",
			"                cntEndWith++ ;  ",
			"            }",
			"            void increasePrefix() {",
			"                cntPrefix++ ; ",
			"            }",
			"            void deleteEnd() {",
			"                cntEndWith-- ; ",
			"            }",
			"            void reducePrefix() {",
			"                cntPrefix-- ; ",
			"            }",
			"            int getEnd() {",
			"                return cntEndWith ; ",
			"            }",
			"            int getPrefix() {",
			"                return cntPrefix ; ",
			"            }",
			"        };",
			"",
			"        Node *root ;",
			"",
			"        public:",
			"        STRING_TRIE() {",
			"            root = new Node(); // Initialize root in the constructor",
			"        }",
			"",
			"        public:",
			"        /** Inserts a word into the trie. */",
			"        void insert(string &word) {",
			"            Node *node = root ;",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    node->put(word[i] , new Node()) ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"                node->increasePrefix();  // Increment prefix count for each character ",
			"            }",
			"            node->setEnd() ; ",
			"            node->increaseEnd();  // Increment end count for the last character",
			"        }",
			"",
			"        /** Returns if the word is in the trie. */",
			"        bool search(string &word) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < word.size() ; ++i) {",
			"                if(!node->containsKey(word[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(word[i]) ; ",
			"            }",
			"            if(node->isEnd()) {",
			"                return true ; ",
			"            }",
			"            return false ; ",
			"        }",
			"",
			"        /** Returns if there is any word in the trie that starts with the given prefix. */",
			"        bool startsWith(string &prefix) {",
			"            Node *node = root ; ",
			"            for(int i = 0 ; i < prefix.size() ; ++i) {",
			"                if(!node->containsKey(prefix[i])) {",
			"                    return false ; ",
			"                }",
			"                node = node->get(prefix[i]) ; ",
			"            }",
			"            return true ; ",
			"        }",
			"",
			"        /** Returns inumber of words equal to given word */",
			"        int countWordsEqualTo(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getEnd() ; ",
			"        }",
			"",
			"        /** ... */",
			"        int countWordsStartingWith(string &word){",
			"            Node* node = root;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                }",
			"                else {",
			"                    return 0 ; ",
			"                }  ",
			"            }",
			"            return node->getPrefix() ; ",
			"        }",
			"",
			"        /** Actually it do not remove the blocks but it decreases the count of that word */",
			"        void erase(string &word){",
			"            Node* node = root ;",
			"            for(int i = 0 ; i < word.length() ; ++i) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]) ;",
			"                    node->reducePrefix() ;  // Decrease prefix count for each character",
			"                }",
			"                else {",
			"                    return ;",
			"                }",
			"            }",
			"            node->deleteEnd() ;  // Decrease end count for the last character",
			"        }",
			"",
			"        /** ... */",
			"        bool checkIfAllPrefixExists(string word) {",
			"            Node *node = root;",
			"            bool flag = true; ",
			"            for(int i = 0;i<word.size();i++) {",
			"                if(node->containsKey(word[i])) {",
			"                    node = node->get(word[i]); ",
			"                    flag = flag & node->isEnd(); ",
			"                }",
			"                else {",
			"                    return false; ",
			"                } ",
			"            }",
			"            return flag; ",
			"        }",
			"",
			"        /** ... */",
			"        string completeString(int n, vector<string> &a){",
			"            Node *node = root;",
			"            for(auto word : a) insert(word); ",
			"            string longest = \"\"; ",
			"            for(auto &word: a) {",
			"                if(checkIfAllPrefixExists(word)) {",
			"                    if(word.size() > longest.size()) {",
			"                        longest = word; ",
			"                    }",
			"                    else if(word.size() == longest.size() && word < longest) {",
			"                        longest = word; ",
			"                    }",
			"                }",
			"            }",
			"            if(longest == \"\") return \"None\"; ",
			"            return longest; ",
			"        }",
			"",
			"        /** ... */",
			"        int countDistinctSubstrings(string &s) {",
			"            Node* node = root;",
			"            int cnt = 0; ",
			"            int n = s.size(); ",
			"            for(int i = 0 ; i < n ; ++i)",
			"            {",
			"                Node* node = root; ",
			"                for(int j = i ; j < n ; ++j) {",
			"                    if(!node->containsKey(s[j])) {",
			"                        node->put(s[j], new Node()) ;  ",
			"                        cnt++ ; ",
			"                    }",
			"                    node = node->get(s[j]) ; ",
			"                }",
			"            }",
			"            return cnt + 1 ; //    Write your code here.",
			"        }",
			"",
			"    };",
			"};",
			"",
			"/*",
			"",
			"So, how to declare Trie in this case.",
			"",
			"Trie::STRING_TRIE trie ;",
			"trie.insert(\"apple\"); , trie.search(\"apple\"); , trie.countWordsEqualTo(\"app\"); , trie.erase(\"app\");",
			"",
			"*/"
		],
		"description": "stringwise_trie"
	},
	"Extended Euclidean Algorithm": {
		"prefix": "Extended Euclidean Algorithm",
		"body": [
			"// used to find the greatest common divisor (GCD) of two integers.",
			"// also finds the coefficients of Bzout's identity. Bzout's identity states",
			"// that for any two integers a and b, there exist integers x and y such that:",
			"// ax + by = gcd(a, b)",
			"int ex_gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"",
			"    int x1, y1;",
			"    int d = ex_gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"",
			"    return d;",
			"}",
			""
		],
		"description": "Extended Euclidean Algorithm"
	},
	"Linear Diophantine Equation": {
		"prefix": "Linear Diophantine Equation",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"    g = gcd(abs(a), abs(b), x0, y0);",
			"    if (c % g) {",
			"        return false;",
			"    }",
			"",
			"    x0 *= c / g;",
			"    y0 *= c / g;",
			"    if (a < 0) x0 = -x0;",
			"    if (b < 0) y0 = -y0;",
			"    return true;",
			"}",
			"",
			"void shift_solution(int & x, int & y, int a, int b, int cnt) {",
			"    x += cnt * b;",
			"    y -= cnt * a;",
			"}",
			"",
			"int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {",
			"    int x, y, g;",
			"    if (!find_any_solution(a, b, c, x, y, g))",
			"        return 0;",
			"    a /= g;",
			"    b /= g;",
			"",
			"    int sign_a = a > 0 ? +1 : -1;",
			"    int sign_b = b > 0 ? +1 : -1;",
			"",
			"    shift_solution(x, y, a, b, (minx - x) / b);",
			"    if (x < minx)",
			"        shift_solution(x, y, a, b, sign_b);",
			"    if (x > maxx)",
			"        return 0;",
			"    int lx1 = x;",
			"",
			"    shift_solution(x, y, a, b, (maxx - x) / b);",
			"    if (x > maxx)",
			"        shift_solution(x, y, a, b, -sign_b);",
			"    int rx1 = x;",
			"",
			"    shift_solution(x, y, a, b, -(miny - y) / a);",
			"    if (y < miny)",
			"        shift_solution(x, y, a, b, -sign_a);",
			"    if (y > maxy)",
			"        return 0;",
			"    int lx2 = x;",
			"",
			"    shift_solution(x, y, a, b, -(maxy - y) / a);",
			"    if (y > maxy)",
			"        shift_solution(x, y, a, b, sign_a);",
			"    int rx2 = x;",
			"",
			"    if (lx2 > rx2)",
			"        swap(lx2, rx2);",
			"    int lx = max(lx1, lx2);",
			"    int rx = min(rx1, rx2);",
			"",
			"    if (lx > rx)",
			"        return 0;",
			"    return (rx - lx) / abs(b) + 1;",
			"}"
		],
		"description": "Linear Diophantine Equation"
	},
	"Chinese Remainder Theorem": {
		"prefix": "Chinese Remainder Theorem",
		"body": [
			"int mod_inv(int c, int m) {",
			"    int m0 = m;",
			"    int y = 0, x = 1;",
			"",
			"    if (m == 1) return 0;",
			"",
			"    while (c > 1) {",
			"        int q = c / m;",
			"        int t = m;",
			"        m = c % m;",
			"        c = t;",
			"        t = y;",
			"        y = x - q * y;",
			"        x = t;",
			"    }",
			"",
			"    if (x < 0) x += m0;",
			"    return x;",
			"}",
			"",
			"int CRT(vector<pair<int, int>> congru) {",
			"    int M = 1;",
			"",
			"    for (auto var : congru) {",
			"        M *= var.second;",
			"    }",
			"",
			"    int solution = 0;",
			"",
			"    for (auto var : congru) {",
			"        int a_i = var.first;",
			"        int M_i = M / var.second;",
			"        int N_i = mod_inv(M_i, var.second);",
			"        solution = (solution + a_i * (M_i % M) * N_i) % M;",
			"    }",
			"",
			"    return solution;",
			"}",
			""
		],
		"description": "Chinese Remainder Theorem"
	},
	"matrix expo": {
		"prefix": "matrix expo",
		"body": [
			"template<typename T>",
			"class Matrix {",
			"public:",
			"    vector<vector<T>> mat;",
			"",
			"    Matrix() {}",
			"",
			"    Matrix(int _n, int _m, T init) {",
			"        mat = vector<vector<T>>(_n, vector<T>(_m, init));",
			"    }",
			"",
			"    Matrix(const vector<vector<T>>& a) {",
			"        mat = a;",
			"    }",
			"",
			"    void set(T init) {",
			"        for(int i = 0; i < rows(); i++) {",
			"            for(int j = 0; j < cols(); j++) {",
			"                mat[i][j] = init;",
			"            }",
			"        }",
			"    }",
			"",
			"    int rows() const {",
			"        return mat.size();",
			"    }",
			"",
			"    int cols() const {",
			"        return mat[0].size();",
			"    }",
			"",
			"    Matrix operator*(const Matrix<T>& obj) const {",
			"        assert(cols() == obj.rows());",
			"        vector<vector<T>> res(rows(), vector<T>(obj.cols()));",
			"        for(int r = 0; r < rows(); r++) {",
			"            for(int c = 0; c < obj.cols(); c++) {",
			"                for(int k = 0; k < cols(); k++) {",
			"                    res[r][c] += mat[r][k] * obj.mat[k][c];",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    vector<T>& operator[](int index) {",
			"        return mat[index];",
			"    }",
			"};",
			"",
			"template<typename T>",
			"ostream& operator<<(ostream& os, Matrix<T>& mat) {",
			"    int n = mat.rows(), m = mat.cols();",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < m; j++) {",
			"            os << mat[i][j] << \" \";",
			"        }",
			"        os << \"\\n\";",
			"    }",
			"    return os;",
			"}",
			"",
			"template<typename T>",
			"Matrix<T> power(Matrix<T> res, Matrix<T> a, long long b) {",
			"    while(b > 0) {",
			"        if(b & 1) ",
			"            res = a * res;",
			"        a = a * a;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "matrix expo"
	},
	"convexhullgrahamscan": {
		"prefix": "convexhull",
		"body": [
			"void cc(vector<pair<ll, ll>>& points) {",
			" ",
			"    auto ccw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) > 0;",
			"    };",
			"    auto cw = [](pair<ll, ll>& a, pair<ll, ll>& b, pair<ll, ll>& c) {",
			"        return ((a.first) * (b.second - c.second)) + ((b.first) * (c.second - a.second)) + ((c.first) * (a.second - b.second)) < 0;",
			"    };",
			" ",
			"    auto cmp = [](pair<ll, ll>& p, pair<ll, ll>& pp) {",
			"        if (p.first == pp.first) return p.second < pp.second;",
			"        return p.first < pp.first;",
			"    };",
			" ",
			"    sort(all(points), cmp); ll n = points.size();",
			"    pair<ll, ll>a = points[0], c = points[n - 1];",
			"    vector<pair<ll, ll>>up, down;",
			"    up.push_back(a); down.push_back(a);",
			"    for (ll i = 1; i < points.size(); i++) {",
			"        if (i == n - 1 || !ccw(a, points[i], c)) {",
			"            // upper half and colinear",
			"            while (up.size() >= 2 && ccw(up[up.size() - 2], up[up.size() - 1], points[i])) {",
			"                up.pop_back();",
			"            }",
			"            up.push_back(points[i]);",
			"        }",
			"        if (i == n - 1 || !cw(a, points[i], c)) {",
			"            //lower Half and colinear",
			"            while (down.size() >= 2 && cw(down[down.size() - 2], down[down.size() - 1], points[i])) {",
			"                down.pop_back();",
			"            }",
			"            down.push_back(points[i]);",
			"        }",
			"    }",
			"    points.clear();",
			"    for (size_t i = 0; i < up.size(); i++)  points.push_back(up[i]);",
			"    for (size_t i = 0; i < down.size(); i++) points.push_back(down[i]);",
			" ",
			"    // Points vector has duplicate values also ",
			"    // as which belongs both upper half and lower half",
			"    // https://codeforces.com/contest/1858/submission/218957587",
			" ",
			"}"
		],
		"description": "convexhullgrahamscan"
	},
	"geometry": {
		"prefix": "geometry",
		"body": [
			"struct point",
			"{",
			"   int x, y, idx;",
			"};",
			"",
			"//Finds squared euclidean distance between two points",
			"int dist(point &a, point &b)",
			"{",
			"   return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);",
			"}",
			"",
			"//Checks if angle ABC is a right angle",
			"int isOrthogonal(point &a, point &b, point &c)",
			"{",
			"   return (b.x-a.x) * (b.x-c.x) + (b.y-a.y) * (b.y-c.y) == 0;",
			"}",
			"",
			"//Checks if ABCD form a rectangle (in that order)",
			"int isRectangle(point &a, point &b, point &c, point &d)",
			"{",
			"   return isOrthogonal(a, b, c) && isOrthogonal(b, c, d) && isOrthogonal(c, d, a);",
			"}",
			"",
			"//Checks if ABCD form a rectangle, in any orientation",
			"int isRectangleAnyOrder(point &a, point &b, point &c, point &d)",
			"{",
			"   return isRectangle(a, b, c, d) || isRectangle(b, c, a, d) | isRectangle(c, a, b, d);",
			"}",
			"",
			"//Checks if ABCD form a square (in that order)",
			"int isSquare(point &a, point &b, point &c, point &d)",
			"{",
			"   return isRectangle(a, b, c, d) && dist(a, b) == dist(b, c);",
			"}",
			"",
			"//Checks if ABCD form a square, in any orientation",
			"int isSquareAnyOrder(point &a, point &b, point &c, point &d)",
			"{",
			"   return isSquare(a, b, c, d) || isSquare(b, c, a, d) | isSquare(c, a, b, d);",
			"}"
		],
		"description": "geometry"
	}
}
